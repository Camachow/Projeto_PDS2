{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\comment begin body}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
doctest.h\par \pard\plain 
{\tc\tcl2 \v C:/Users/Camacho_2/Documents/PDSII/Projeto_Final/third_party/doctest.h}
{\xe \v C:/Users/Camacho_2/Documents/PDSII/Projeto_Final/third_party/doctest.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Vá para a documentação desse arquivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // ======================================================================}\par
2 {\cf20 // == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==}\par
3 {\cf20 // ======================================================================}\par
4 {\cf20 //}\par
5 {\cf20 // doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD}\par
6 {\cf20 //}\par
7 {\cf20 // Copyright (c) 2016-2018 Viktor Kirilov}\par
8 {\cf20 //}\par
9 {\cf20 // Distributed under the MIT Software License}\par
10 {\cf20 // See accompanying file LICENSE.txt or copy at}\par
11 {\cf20 // https://opensource.org/licenses/MIT}\par
12 {\cf20 //}\par
13 {\cf20 // The documentation can be found at the library's page:}\par
14 {\cf20 // https://github.com/onqtam/doctest/blob/master/doc/markdown/readme.md}\par
15 {\cf20 //}\par
16 {\cf20 // =================================================================================================}\par
17 {\cf20 // =================================================================================================}\par
18 {\cf20 // =================================================================================================}\par
19 {\cf20 //}\par
20 {\cf20 // The library is heavily influenced by Catch - https://github.com/philsquared/Catch}\par
21 {\cf20 // which uses the Boost Software License - Version 1.0}\par
22 {\cf20 // see here - https://github.com/philsquared/Catch/blob/master/LICENSE.txt}\par
23 {\cf20 //}\par
24 {\cf20 // The concept of subcases (sections in Catch) and expression decomposition are from there.}\par
25 {\cf20 // Some parts of the code are taken directly:}\par
26 {\cf20 // - stringification - the detection of "ostream& operator<<(ostream&, const T&)" and StringMaker<>}\par
27 {\cf20 // - the Approx() helper class for floating point comparison}\par
28 {\cf20 // - colors in the console}\par
29 {\cf20 // - breaking into a debugger}\par
30 {\cf20 // - signal / SEH handling}\par
31 {\cf20 // - timer}\par
32 {\cf20 //}\par
33 {\cf20 // The expression decomposing templates are taken from lest - https://github.com/martinmoene/lest}\par
34 {\cf20 // which uses the Boost Software License - Version 1.0}\par
35 {\cf20 // see here - https://github.com/martinmoene/lest/blob/master/LICENSE.txt}\par
36 {\cf20 //}\par
37 {\cf20 // The type list and the foreach algorithm on it for C++98 are taken from Loki}\par
38 {\cf20 // - http://loki-lib.sourceforge.net/}\par
39 {\cf20 // - https://en.wikipedia.org/wiki/Loki_%28C%2B%2B%29}\par
40 {\cf20 // - https://github.com/snaewe/loki-lib}\par
41 {\cf20 // which uses the MIT Software License}\par
42 {\cf20 //}\par
43 {\cf20 // =================================================================================================}\par
44 {\cf20 // =================================================================================================}\par
45 {\cf20 // =================================================================================================}\par
46 \par
47 {\cf21 #ifndef DOCTEST_LIBRARY_INCLUDED}\par
48 {\cf21 #define DOCTEST_LIBRARY_INCLUDED}\par
49 \par
50 {\cf20 // =================================================================================================}\par
51 {\cf20 // == VERSION ======================================================================================}\par
52 {\cf20 // =================================================================================================}\par
53 \par
54 {\cf21 #define DOCTEST_VERSION_MAJOR 1}\par
55 {\cf21 #define DOCTEST_VERSION_MINOR 2}\par
56 {\cf21 #define DOCTEST_VERSION_PATCH 9}\par
57 {\cf21 #define DOCTEST_VERSION_STR "1.2.9"}\par
58 \par
59 {\cf21 #define DOCTEST_VERSION                                                                            \\}\par
60 {\cf21     (DOCTEST_VERSION_MAJOR * 10000 + DOCTEST_VERSION_MINOR * 100 + DOCTEST_VERSION_PATCH)}\par
61 \par
62 {\cf20 // =================================================================================================}\par
63 {\cf20 // == COMPILER VERSION =============================================================================}\par
64 {\cf20 // =================================================================================================}\par
65 \par
66 {\cf20 // ideas for the version stuff are taken from here: https://github.com/cxxstuff/cxx_detect}\par
67 \par
68 {\cf21 #define DOCTEST_COMPILER(MAJOR, MINOR, PATCH) ((MAJOR)*10000000 + (MINOR)*100000 + (PATCH))}\par
69 \par
70 {\cf21 #if defined(_MSC_VER) && defined(_MSC_FULL_VER)}\par
71 {\cf21 #if _MSC_VER == _MSC_FULL_VER / 10000}\par
72 {\cf21 #define DOCTEST_MSVC DOCTEST_COMPILER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)}\par
73 {\cf21 #else}\par
74 {\cf21 #define DOCTEST_MSVC                                                                               \\}\par
75 {\cf21     DOCTEST_COMPILER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)}\par
76 {\cf21 #endif}\par
77 {\cf21 #elif defined(__clang__) && defined(__clang_minor__)}\par
78 {\cf21 #define DOCTEST_CLANG DOCTEST_COMPILER(__clang_major__, __clang_minor__, __clang_patchlevel__)}\par
79 {\cf21 #elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) &&              \\}\par
80 {\cf21         !defined(__INTEL_COMPILER)}\par
81 {\cf21 #define DOCTEST_GCC DOCTEST_COMPILER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)}\par
82 {\cf21 #endif}\par
83 \par
84 {\cf21 #ifndef DOCTEST_MSVC}\par
85 {\cf21 #define DOCTEST_MSVC 0}\par
86 {\cf21 #endif }{\cf20 // DOCTEST_MSVC}\par
87 {\cf21 #ifndef DOCTEST_CLANG}\par
88 {\cf21 #define DOCTEST_CLANG 0}\par
89 {\cf21 #endif }{\cf20 // DOCTEST_CLANG}\par
90 {\cf21 #ifndef DOCTEST_GCC}\par
91 {\cf21 #define DOCTEST_GCC 0}\par
92 {\cf21 #endif }{\cf20 // DOCTEST_GCC}\par
93 \par
94 {\cf20 // =================================================================================================}\par
95 {\cf20 // == COMPILER WARNINGS HELPERS ====================================================================}\par
96 {\cf20 // =================================================================================================}\par
97 \par
98 {\cf21 #if DOCTEST_CLANG}\par
99 {\cf21 #ifdef __has_warning}\par
100 {\cf21 #define DOCTEST_CLANG_HAS_WARNING(x) __has_warning(x)}\par
101 {\cf21 #endif }{\cf20 // __has_warning}\par
102 {\cf21 #ifdef __has_feature}\par
103 {\cf21 #define DOCTEST_CLANG_HAS_FEATURE(x) __has_feature(x)}\par
104 {\cf21 #endif }{\cf20 // __has_feature}\par
105 {\cf21 #define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)}\par
106 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH _Pragma("clang diagnostic push"})\par
107 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH}\par
108 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_PUSH}\par
109 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(clang diagnostic ignored w)}\par
110 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING(w)}\par
111 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING(w)}\par
112 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_POP _Pragma("clang diagnostic pop"})\par
113 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_POP}\par
114 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_POP}\par
115 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)                                                \\}\par
116 {\cf21     DOCTEST_CLANG_SUPPRESS_WARNING_PUSH DOCTEST_CLANG_SUPPRESS_WARNING(w)}\par
117 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)}\par
118 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)}\par
119 {\cf21 #elif DOCTEST_GCC}\par
120 {\cf21 #define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)}\par
121 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH}\par
122 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH}\par
123 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 7, 0)}\par
124 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_PUSH _Pragma("GCC diagnostic push"})\par
125 {\cf21 #else }{\cf20 // GCC 4.7+}\par
126 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_PUSH}\par
127 {\cf21 #endif }{\cf20 // GCC 4.7+}\par
128 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING(w)}\par
129 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING(w)}\par
130 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(GCC diagnostic ignored w)}\par
131 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_POP}\par
132 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_POP}\par
133 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 7, 0)}\par
134 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_POP _Pragma("GCC diagnostic pop"})\par
135 {\cf21 #else }{\cf20 // GCC 4.7+}\par
136 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_POP}\par
137 {\cf21 #endif }{\cf20 // GCC 4.7+}\par
138 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)}\par
139 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)}\par
140 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)                                                  \\}\par
141 {\cf21     DOCTEST_GCC_SUPPRESS_WARNING_PUSH DOCTEST_GCC_SUPPRESS_WARNING(w)}\par
142 {\cf21 #elif DOCTEST_MSVC}\par
143 {\cf21 #define DOCTEST_PRAGMA_TO_STR(x)}\par
144 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH}\par
145 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH __pragma(warning(push))}\par
146 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_PUSH}\par
147 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING(w)}\par
148 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING(w) __pragma(warning(disable : w))}\par
149 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING(w)}\par
150 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_POP}\par
151 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_POP __pragma(warning(pop))}\par
152 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_POP}\par
153 {\cf21 #define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)}\par
154 {\cf21 #define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)                                                 \\}\par
155 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING_PUSH DOCTEST_MSVC_SUPPRESS_WARNING(w)}\par
156 {\cf21 #define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)}\par
157 {\cf21 #endif }{\cf20 // different compilers - warning suppression macros}\par
158 \par
159 {\cf21 #ifndef DOCTEST_CLANG_HAS_WARNING}\par
160 {\cf21 #define DOCTEST_CLANG_HAS_WARNING(x) 1}\par
161 {\cf21 #endif }{\cf20 // DOCTEST_CLANG_HAS_WARNING}\par
162 \par
163 {\cf21 #ifndef DOCTEST_CLANG_HAS_FEATURE}\par
164 {\cf21 #define DOCTEST_CLANG_HAS_FEATURE(x) 0}\par
165 {\cf21 #endif }{\cf20 // DOCTEST_CLANG_HAS_FEATURE}\par
166 \par
167 {\cf20 // =================================================================================================}\par
168 {\cf20 // == COMPILER WARNINGS ============================================================================}\par
169 {\cf20 // =================================================================================================}\par
170 \par
171 DOCTEST_CLANG_SUPPRESS_WARNING_PUSH\par
172 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wunknown-pragmas"})\par
173 DOCTEST_CLANG_SUPPRESS_WARNING("-Wnon-virtual-dtor")\par
174 DOCTEST_CLANG_SUPPRESS_WARNING("-Wweak-vtables")\par
175 DOCTEST_CLANG_SUPPRESS_WARNING("-Wpadded")\par
176 DOCTEST_CLANG_SUPPRESS_WARNING("-Wdeprecated")\par
177 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-prototypes")\par
178 DOCTEST_CLANG_SUPPRESS_WARNING("-Wunused-local-typedef")\par
179 DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++11-{\cf18 long}-{\cf18 long}")\par
180 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_WARNING("-Wzero-as-null-pointer-constant"})\par
181 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wzero-as-null-pointer-constant"})\par
182 {\cf21 #endif }{\cf20 // clang - 0 as null}\par
183 \par
184 DOCTEST_GCC_SUPPRESS_WARNING_PUSH\par
185 DOCTEST_GCC_SUPPRESS_WARNING({\cf22 "-Wunknown-pragmas"})\par
186 DOCTEST_GCC_SUPPRESS_WARNING("-Wpragmas")\par
187 DOCTEST_GCC_SUPPRESS_WARNING("-Weffc++")\par
188 DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-overflow")\par
189 DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-aliasing")\par
190 DOCTEST_GCC_SUPPRESS_WARNING("-Wctor-dtor-privacy")\par
191 DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-declarations")\par
192 DOCTEST_GCC_SUPPRESS_WARNING("-Wnon-virtual-dtor")\par
193 DOCTEST_GCC_SUPPRESS_WARNING("-Winline")\par
194 DOCTEST_GCC_SUPPRESS_WARNING("-Wlong-{\cf18 long}")\par
195 DOCTEST_GCC_SUPPRESS_WARNING("-Wzero-as-null-pointer-constant")\par
196 DOCTEST_GCC_SUPPRESS_WARNING("-Wunused-local-typedefs")\par
197 DOCTEST_GCC_SUPPRESS_WARNING("-Wuseless-cast")\par
198 \par
199 DOCTEST_MSVC_SUPPRESS_WARNING_PUSH\par
200 DOCTEST_MSVC_SUPPRESS_WARNING(4616) {\cf20 // invalid compiler warning}\par
201 DOCTEST_MSVC_SUPPRESS_WARNING(4619) {\cf20 // invalid compiler warning}\par
202 DOCTEST_MSVC_SUPPRESS_WARNING(4996) {\cf20 // The compiler encountered a deprecated declaration}\par
203 DOCTEST_MSVC_SUPPRESS_WARNING(4706) {\cf20 // assignment within conditional expression}\par
204 DOCTEST_MSVC_SUPPRESS_WARNING(4512) {\cf20 // 'class' : assignment operator could not be generated}\par
205 DOCTEST_MSVC_SUPPRESS_WARNING(4127) {\cf20 // conditional expression is constant}\par
206 DOCTEST_MSVC_SUPPRESS_WARNING(4820) {\cf20 // padding}\par
207 DOCTEST_MSVC_SUPPRESS_WARNING(4625) {\cf20 // copy constructor was implicitly defined as deleted}\par
208 DOCTEST_MSVC_SUPPRESS_WARNING(4626) {\cf20 // assignment operator was implicitly defined as deleted}\par
209 DOCTEST_MSVC_SUPPRESS_WARNING(5027) {\cf20 // move assignment operator was implicitly defined as deleted}\par
210 DOCTEST_MSVC_SUPPRESS_WARNING(5026) {\cf20 // move constructor was implicitly defined as deleted}\par
211 DOCTEST_MSVC_SUPPRESS_WARNING(4623) {\cf20 // default constructor was implicitly defined as deleted}\par
212 DOCTEST_MSVC_SUPPRESS_WARNING(4640) {\cf20 // construction of local static object is not thread-safe}\par
213 \par
214 {\cf20 // C4548 - expression before comma has no effect; expected expression with side - effect}\par
215 {\cf20 // C4986 - exception specification does not match previous declaration}\par
216 {\cf20 // C4350 - behavior change: 'member1' called instead of 'member2'}\par
217 {\cf20 // C4668 - 'x' is not defined as a preprocessor macro, replacing with '0' for '#if/#elif'}\par
218 {\cf20 // C4365 - conversion from 'int' to 'unsigned long', signed/unsigned mismatch}\par
219 {\cf20 // C4774 - format string expected in argument 'x' is not a string literal}\par
220 {\cf20 // C4820 - padding in structs}\par
221 \par
222 {\cf20 // only 4 should be disabled globally:}\par
223 {\cf20 // - C4514 # unreferenced inline function has been removed}\par
224 {\cf20 // - C4571 # SEH related}\par
225 {\cf20 // - C4710 # function not inlined}\par
226 {\cf20 // - C4711 # function 'x' selected for automatic inline expansion}\par
227 \par
228 {\cf21 #define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN                                 \\}\par
229 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \\}\par
230 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4548)                                                            \\}\par
231 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4986)                                                            \\}\par
232 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4350)                                                            \\}\par
233 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4668)                                                            \\}\par
234 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4365)                                                            \\}\par
235 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4774)                                                            \\}\par
236 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4820)                                                            \\}\par
237 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4625)                                                            \\}\par
238 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4626)                                                            \\}\par
239 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(5027)                                                            \\}\par
240 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(5026)                                                            \\}\par
241 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(4623)                                                            \\}\par
242 {\cf21     DOCTEST_MSVC_SUPPRESS_WARNING(5039)}\par
243 \par
244 {\cf21 #define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END DOCTEST_MSVC_SUPPRESS_WARNING_POP}\par
245 \par
246 {\cf20 // =================================================================================================}\par
247 {\cf20 // == FEATURE DETECTION ============================================================================}\par
248 {\cf20 // =================================================================================================}\par
249 \par
250 {\cf21 #if __cplusplus >= 201103L}\par
251 {\cf21 #ifndef DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
252 {\cf21 #define DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
253 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
254 {\cf21 #ifndef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
255 {\cf21 #define DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
256 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
257 {\cf21 #ifndef DOCTEST_CONFIG_WITH_NULLPTR}\par
258 {\cf21 #define DOCTEST_CONFIG_WITH_NULLPTR}\par
259 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_NULLPTR}\par
260 {\cf21 #ifndef DOCTEST_CONFIG_WITH_LONG_LONG}\par
261 {\cf21 #define DOCTEST_CONFIG_WITH_LONG_LONG}\par
262 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
263 {\cf21 #ifndef DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
264 {\cf21 #define DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
265 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
266 {\cf21 #ifndef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
267 {\cf21 #define DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
268 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
269 {\cf21 #endif }{\cf20 // __cplusplus >= 201103L}\par
270 \par
271 {\cf20 // MSVC C++11 feature support table: https://msdn.microsoft.com/en-us/library/hh567368.aspx}\par
272 {\cf20 // GCC C++11 feature support table: https://gcc.gnu.org/projects/cxx-status.html}\par
273 {\cf20 // MSVC version table:}\par
274 {\cf20 // MSVC++ 15.0 _MSC_VER == 1910 (Visual Studio 2017)}\par
275 {\cf20 // MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)}\par
276 {\cf20 // MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)}\par
277 {\cf20 // MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)}\par
278 {\cf20 // MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)}\par
279 {\cf20 // MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)}\par
280 {\cf20 // MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)}\par
281 \par
282 {\cf20 // deleted functions}\par
283 \par
284 {\cf21 #ifndef DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
285 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(18, 0, 0)}\par
286 {\cf21 #define DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
287 {\cf21 #endif }{\cf20 // MSVC}\par
288 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_FEATURE(cxx_deleted_functions)}\par
289 {\cf21 #define DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
290 {\cf21 #endif }{\cf20 // clang}\par
291 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 5, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
292 {\cf21 #define DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
293 {\cf21 #endif }{\cf20 // GCC}\par
294 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
295 \par
296 {\cf21 #if defined(DOCTEST_CONFIG_NO_DELETED_FUNCTIONS) && defined(DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS)}\par
297 {\cf21 #undef DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS}\par
298 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_DELETED_FUNCTIONS}\par
299 \par
300 {\cf20 // rvalue references}\par
301 \par
302 {\cf21 #ifndef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
303 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(16, 0, 0)}\par
304 {\cf21 #define DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
305 {\cf21 #endif }{\cf20 // MSVC}\par
306 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_FEATURE(cxx_rvalue_references)}\par
307 {\cf21 #define DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
308 {\cf21 #endif }{\cf20 // clang}\par
309 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 3, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
310 {\cf21 #define DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
311 {\cf21 #endif }{\cf20 // GCC}\par
312 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
313 \par
314 {\cf21 #if defined(DOCTEST_CONFIG_NO_RVALUE_REFERENCES) && defined(DOCTEST_CONFIG_WITH_RVALUE_REFERENCES)}\par
315 {\cf21 #undef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
316 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_RVALUE_REFERENCES}\par
317 \par
318 {\cf20 // nullptr}\par
319 \par
320 {\cf21 #ifndef DOCTEST_CONFIG_WITH_NULLPTR}\par
321 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_FEATURE(cxx_nullptr)}\par
322 {\cf21 #define DOCTEST_CONFIG_WITH_NULLPTR}\par
323 {\cf21 #endif }{\cf20 // clang}\par
324 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 6, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
325 {\cf21 #define DOCTEST_CONFIG_WITH_NULLPTR}\par
326 {\cf21 #endif }{\cf20 // GCC}\par
327 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(16, 0, 0)}\par
328 {\cf21 #define DOCTEST_CONFIG_WITH_NULLPTR}\par
329 {\cf21 #endif }{\cf20 // MSVC}\par
330 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_NULLPTR}\par
331 \par
332 {\cf21 #if defined(DOCTEST_CONFIG_NO_NULLPTR) && defined(DOCTEST_CONFIG_WITH_NULLPTR)}\par
333 {\cf21 #undef DOCTEST_CONFIG_WITH_NULLPTR}\par
334 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_NULLPTR}\par
335 \par
336 {\cf20 // variadic macros}\par
337 \par
338 {\cf21 #ifndef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
339 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(14, 0, 0) && !defined(__EDGE__)}\par
340 {\cf21 #define DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
341 {\cf21 #endif }{\cf20 // MSVC}\par
342 {\cf21 #if(DOCTEST_CLANG || DOCTEST_GCC >= DOCTEST_COMPILER(4, 1, 0)) &&                                  \\}\par
343 {\cf21         defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
344 {\cf21 #define DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
345 {\cf21 #endif }{\cf20 // GCC and clang}\par
346 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
347 \par
348 {\cf21 #if defined(DOCTEST_CONFIG_NO_VARIADIC_MACROS) && defined(DOCTEST_CONFIG_WITH_VARIADIC_MACROS)}\par
349 {\cf21 #undef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
350 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_VARIADIC_MACROS}\par
351 \par
352 {\cf20 // long long}\par
353 \par
354 {\cf21 #ifndef DOCTEST_CONFIG_WITH_LONG_LONG}\par
355 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(14, 0, 0)}\par
356 {\cf21 #define DOCTEST_CONFIG_WITH_LONG_LONG}\par
357 {\cf21 #endif }{\cf20 // MSVC}\par
358 {\cf21 #if(DOCTEST_CLANG || DOCTEST_GCC >= DOCTEST_COMPILER(4, 5, 0)) &&                                  \\}\par
359 {\cf21         defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
360 {\cf21 #define DOCTEST_CONFIG_WITH_LONG_LONG}\par
361 {\cf21 #endif }{\cf20 // GCC and clang}\par
362 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
363 \par
364 {\cf21 #if defined(DOCTEST_CONFIG_NO_LONG_LONG) && defined(DOCTEST_CONFIG_WITH_LONG_LONG)}\par
365 {\cf21 #undef DOCTEST_CONFIG_WITH_LONG_LONG}\par
366 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_LONG_LONG}\par
367 \par
368 {\cf20 // static_assert}\par
369 \par
370 {\cf21 #ifndef DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
371 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_FEATURE(cxx_static_assert)}\par
372 {\cf21 #define DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
373 {\cf21 #endif }{\cf20 // clang}\par
374 {\cf21 #if DOCTEST_GCC >= DOCTEST_COMPILER(4, 3, 0) && defined(__GXX_EXPERIMENTAL_CXX0X__)}\par
375 {\cf21 #define DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
376 {\cf21 #endif }{\cf20 // GCC}\par
377 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(16, 0, 0)}\par
378 {\cf21 #define DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
379 {\cf21 #endif }{\cf20 // MSVC}\par
380 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
381 \par
382 {\cf21 #if defined(DOCTEST_CONFIG_NO_STATIC_ASSERT) && defined(DOCTEST_CONFIG_WITH_STATIC_ASSERT)}\par
383 {\cf21 #undef DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
384 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_STATIC_ASSERT}\par
385 \par
386 {\cf20 // other stuff...}\par
387 \par
388 {\cf21 #if defined(DOCTEST_CONFIG_WITH_RVALUE_REFERENCES) || defined(DOCTEST_CONFIG_WITH_LONG_LONG) ||    \\}\par
389 {\cf21         defined(DOCTEST_CONFIG_WITH_DELETED_FUNCTIONS) || defined(DOCTEST_CONFIG_WITH_NULLPTR) ||  \\}\par
390 {\cf21         defined(DOCTEST_CONFIG_WITH_VARIADIC_MACROS) || defined(DOCTEST_CONFIG_WITH_STATIC_ASSERT)}\par
391 {\cf21 #define DOCTEST_NO_CPP11_COMPAT}\par
392 {\cf21 #endif }{\cf20 // c++11 stuff}\par
393 \par
394 {\cf21 #if defined(DOCTEST_NO_CPP11_COMPAT)}\par
395 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wc++98-compat"})\par
396 DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat-pedantic")\par
397 {\cf21 #endif }{\cf20 // DOCTEST_NO_CPP11_COMPAT}\par
398 \par
399 {\cf21 #if DOCTEST_MSVC && !defined(DOCTEST_CONFIG_WINDOWS_SEH)}\par
400 {\cf21 #define DOCTEST_CONFIG_WINDOWS_SEH}\par
401 {\cf21 #endif }{\cf20 // MSVC}\par
402 {\cf21 #if defined(DOCTEST_CONFIG_NO_WINDOWS_SEH) && defined(DOCTEST_CONFIG_WINDOWS_SEH)}\par
403 {\cf21 #undef DOCTEST_CONFIG_WINDOWS_SEH}\par
404 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_WINDOWS_SEH}\par
405 \par
406 {\cf21 #if !defined(_WIN32) && !defined(__QNX__) && !defined(DOCTEST_CONFIG_POSIX_SIGNALS)}\par
407 {\cf21 #define DOCTEST_CONFIG_POSIX_SIGNALS}\par
408 {\cf21 #endif }{\cf20 // _WIN32}\par
409 {\cf21 #if defined(DOCTEST_CONFIG_NO_POSIX_SIGNALS) && defined(DOCTEST_CONFIG_POSIX_SIGNALS)}\par
410 {\cf21 #undef DOCTEST_CONFIG_POSIX_SIGNALS}\par
411 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_POSIX_SIGNALS}\par
412 \par
413 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
414 {\cf21 #if(DOCTEST_GCC || DOCTEST_CLANG) && !defined(__EXCEPTIONS)}\par
415 {\cf21 #define DOCTEST_CONFIG_NO_EXCEPTIONS}\par
416 {\cf21 #endif }{\cf20 // clang and gcc}\par
417 {\cf20 // in MSVC _HAS_EXCEPTIONS is defined in a header instead of as a project define}\par
418 {\cf20 // so we can't do the automatic detection for MSVC without including some header}\par
419 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
420 \par
421 {\cf21 #ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS}\par
422 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
423 {\cf21 #define DOCTEST_CONFIG_NO_EXCEPTIONS}\par
424 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
425 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS}\par
426 \par
427 {\cf21 #if defined(DOCTEST_CONFIG_NO_EXCEPTIONS) && !defined(DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS)}\par
428 {\cf21 #define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS}\par
429 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS && !DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS}\par
430 \par
431 {\cf21 #if defined(DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN) && !defined(DOCTEST_CONFIG_IMPLEMENT)}\par
432 {\cf21 #define DOCTEST_CONFIG_IMPLEMENT}\par
433 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN}\par
434 \par
435 {\cf21 #if defined _WIN32 || defined __CYGWIN__}\par
436 {\cf21 #if DOCTEST_MSVC}\par
437 {\cf21 #define DOCTEST_SYMBOL_EXPORT __declspec(dllexport)}\par
438 {\cf21 #define DOCTEST_SYMBOL_IMPORT __declspec(dllimport)}\par
439 {\cf21 #else }{\cf20 // MSVC}\par
440 {\cf21 #define DOCTEST_SYMBOL_EXPORT __attribute__((dllexport))}\par
441 {\cf21 #define DOCTEST_SYMBOL_IMPORT __attribute__((dllimport))}\par
442 {\cf21 #endif }{\cf20 // MSVC}\par
443 {\cf21 #else  }{\cf20 // _WIN32}\par
444 {\cf21 #define DOCTEST_SYMBOL_EXPORT __attribute__((visibility("default"})))\par
445 {\cf21 #define DOCTEST_SYMBOL_IMPORT}\par
446 {\cf21 #endif }{\cf20 // _WIN32}\par
447 \par
448 {\cf21 #ifdef DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL}\par
449 {\cf21 #ifdef DOCTEST_CONFIG_IMPLEMENT}\par
450 {\cf21 #define DOCTEST_INTERFACE DOCTEST_SYMBOL_EXPORT}\par
451 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_IMPLEMENT}\par
452 {\cf21 #define DOCTEST_INTERFACE DOCTEST_SYMBOL_IMPORT}\par
453 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_IMPLEMENT}\par
454 {\cf21 #else  }{\cf20 // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL}\par
455 {\cf21 #define DOCTEST_INTERFACE}\par
456 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL}\par
457 \par
458 {\cf21 #if DOCTEST_MSVC}\par
459 {\cf21 #define DOCTEST_NOINLINE __declspec(noinline)}\par
460 {\cf21 #define DOCTEST_UNUSED}\par
461 {\cf21 #define DOCTEST_ALIGNMENT(x)}\par
462 {\cf21 #else }{\cf20 // MSVC}\par
463 {\cf21 #define DOCTEST_NOINLINE __attribute__((noinline))}\par
464 {\cf21 #define DOCTEST_UNUSED __attribute__((unused))}\par
465 {\cf21 #define DOCTEST_ALIGNMENT(x) __attribute__((aligned(x)))}\par
466 {\cf21 #endif }{\cf20 // MSVC}\par
467 \par
468 {\cf21 #ifndef DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK}\par
469 {\cf21 #define DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK 5}\par
470 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK}\par
471 \par
472 {\cf20 // =================================================================================================}\par
473 {\cf20 // == FEATURE DETECTION END ========================================================================}\par
474 {\cf20 // =================================================================================================}\par
475 \par
476 {\cf20 // internal macros for string concatenation and anonymous variable name generation}\par
477 {\cf21 #define DOCTEST_CAT_IMPL(s1, s2) s1##s2}\par
478 {\cf21 #define DOCTEST_CAT(s1, s2) DOCTEST_CAT_IMPL(s1, s2)}\par
479 {\cf21 #ifdef __COUNTER__ }{\cf20 // not standard and may be missing for some compilers}\par
480 {\cf21 #define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __COUNTER__)}\par
481 {\cf21 #else }{\cf20 // __COUNTER__}\par
482 {\cf21 #define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __LINE__)}\par
483 {\cf21 #endif }{\cf20 // __COUNTER__}\par
484 \par
485 {\cf20 // macro for making a string out of an identifier}\par
486 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
487 {\cf21 #define DOCTEST_TOSTR_IMPL(...) #__VA_ARGS__}\par
488 {\cf21 #define DOCTEST_TOSTR(...) DOCTEST_TOSTR_IMPL(__VA_ARGS__)}\par
489 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
490 {\cf21 #define DOCTEST_TOSTR_IMPL(x) #x}\par
491 {\cf21 #define DOCTEST_TOSTR(x) DOCTEST_TOSTR_IMPL(x)}\par
492 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
493 \par
494 {\cf20 // counts the number of elements in a C string}\par
495 {\cf21 #define DOCTEST_COUNTOF(x) (sizeof(x) / sizeof(x[0]))}\par
496 \par
497 {\cf21 #ifndef DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE}\par
498 {\cf21 #define DOCTEST_REF_WRAP(x) x&}\par
499 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE}\par
500 {\cf21 #define DOCTEST_REF_WRAP(x) x}\par
501 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE}\par
502 \par
503 {\cf20 // not using __APPLE__ because... this is how Catch does it}\par
504 {\cf21 #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)}\par
505 {\cf21 #define DOCTEST_PLATFORM_MAC}\par
506 {\cf21 #elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)}\par
507 {\cf21 #define DOCTEST_PLATFORM_IPHONE}\par
508 {\cf21 #elif defined(_WIN32)}\par
509 {\cf21 #define DOCTEST_PLATFORM_WINDOWS}\par
510 {\cf21 #else}\par
511 {\cf21 #define DOCTEST_PLATFORM_LINUX}\par
512 {\cf21 #endif}\par
513 \par
514 {\cf21 #define DOCTEST_GLOBAL_NO_WARNINGS(var)                                                            \\}\par
515 {\cf21     DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Wglobal-constructors"}) static int var DOCTEST_UNUSED\par
516 {\cf21 #define DOCTEST_GLOBAL_NO_WARNINGS_END() DOCTEST_CLANG_SUPPRESS_WARNING_POP}\par
517 \par
518 {\cf20 // should probably take a look at https://github.com/scottt/debugbreak}\par
519 {\cf21 #ifdef DOCTEST_PLATFORM_MAC}\par
520 {\cf21 #define DOCTEST_BREAK_INTO_DEBUGGER() __asm__("int $3\\n"} : :)\par
521 {\cf21 #elif DOCTEST_MSVC}\par
522 {\cf21 #define DOCTEST_BREAK_INTO_DEBUGGER() __debugbreak()}\par
523 {\cf21 #elif defined(__MINGW32__)}\par
524 {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 void} __stdcall DebugBreak();\par
525 {\cf21 #define DOCTEST_BREAK_INTO_DEBUGGER() ::DebugBreak()}\par
526 {\cf21 #else }{\cf20 // linux}\par
527 {\cf21 #define DOCTEST_BREAK_INTO_DEBUGGER() ((void)0)}\par
528 {\cf21 #endif }{\cf20 // linux}\par
529 \par
530 {\cf21 #if DOCTEST_CLANG}\par
531 {\cf20 // to detect if libc++ is being used with clang (the _LIBCPP_VERSION identifier)}\par
532 {\cf21 #include <ciso646>}\par
533 {\cf21 #endif }{\cf20 // clang}\par
534 \par
535 {\cf21 #ifdef _LIBCPP_VERSION}\par
536 {\cf20 // not forward declaring ostream for libc++ because I had some problems (inline namespaces vs c++98)}\par
537 {\cf20 // so the <iosfwd> header is used - also it is very light and doesn't drag a ton of stuff}\par
538 {\cf21 #include <iosfwd>}\par
539 {\cf21 #else }{\cf20 // _LIBCPP_VERSION}\par
540 {\cf21 #ifndef DOCTEST_CONFIG_USE_IOSFWD}\par
541 {\cf17 namespace }std\par
542 \{\par
543 {\cf17 template} <{\cf17 class} {\cf18 char}T>\par
544 {\cf17 struct }char_traits;\par
545 {\cf17 template} <>\par
546 {\cf17 struct }char_traits<char>;\par
547 {\cf17 template} <{\cf17 class} {\cf18 char}T, {\cf17 class} traits>\par
548 {\cf17 class }basic_ostream;\par
549 {\cf17 typedef} basic_ostream<char, char_traits<char> > ostream;\par
550 \} {\cf20 // namespace std}\par
551 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_USE_IOSFWD}\par
552 {\cf21 #include <iosfwd>}\par
553 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_USE_IOSFWD}\par
554 {\cf21 #endif }{\cf20 // _LIBCPP_VERSION}\par
555 \par
556 {\cf20 // static assert macro - because of the c++98 support requires that the message is an}\par
557 {\cf20 // identifier (no spaces and not a C string) - example without quotes: I_am_a_message}\par
558 {\cf20 // taken from here: http://stackoverflow.com/a/1980156/3162383}\par
559 {\cf21 #ifdef DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
560 {\cf21 #define DOCTEST_STATIC_ASSERT(expression, message) static_assert(expression, #message)}\par
561 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
562 {\cf21 #define DOCTEST_STATIC_ASSERT(expression, message)                                                 \\}\par
563 {\cf21     struct DOCTEST_CAT(__static_assertion_at_line_, __LINE__)                                      \\}\par
564 {\cf21     \{                                                                                              \\}\par
565 {\cf21         doctest::detail::static_assert_impl::StaticAssertion<static_cast<bool>((expression))>      \\}\par
566 {\cf21                 DOCTEST_CAT(DOCTEST_CAT(DOCTEST_CAT(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__),   \\}\par
567 {\cf21                                         _),                                                        \\}\par
568 {\cf21                             message);                                                              \\}\par
569 {\cf21     \};                                                                                             \\}\par
570 {\cf21     typedef doctest::detail::static_assert_impl::StaticAssertionTest<static_cast<int>(             \\}\par
571 {\cf21             sizeof(DOCTEST_CAT(__static_assertion_at_line_, __LINE__)))>                           \\}\par
572 {\cf21             DOCTEST_CAT(__static_assertion_test_at_line_, __LINE__)}\par
573 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
574 \par
575 {\cf21 #ifdef DOCTEST_CONFIG_WITH_NULLPTR}\par
576 {\cf21 #ifdef _LIBCPP_VERSION}\par
577 {\cf21 #include <cstddef>}\par
578 {\cf21 #else  }{\cf20 // _LIBCPP_VERSION}\par
579 {\cf17 namespace }std\par
580 \{\par
581 {\cf17 typedef} {\cf17 decltype}({\cf17 nullptr}) nullptr_t;\par
582 \}\par
583 {\cf21 #endif }{\cf20 // _LIBCPP_VERSION}\par
584 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_NULLPTR}\par
585 \par
586 {\cf21 #ifndef DOCTEST_CONFIG_DISABLE}\par
587 \par
588 {\cf21 #ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
589 {\cf21 #include <type_traits>}\par
590 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
591 \par
592 {\cf17 namespace }doctest\par
593 \{\par
594 {\cf17 namespace }detail\par
595 \{\par
596     {\cf17 struct }TestSuite\par
597     \{\par
598         {\cf17 const} {\cf18 char}* m_test_suite;\par
599         {\cf17 const} {\cf18 char}* m_description;\par
600         {\cf18 bool}        m_skip;\par
601         {\cf18 bool}        m_may_fail;\par
602         {\cf18 bool}        m_should_fail;\par
603         {\cf18 int}         m_expected_failures;\par
604         {\cf18 double}      m_timeout;\par
605 \par
606         TestSuite& operator*({\cf17 const} {\cf18 char}* in) \{\par
607             m_test_suite = in;\par
608             {\cf20 // clear state}\par
609             m_description       = 0;\par
610             m_skip              = {\cf17 false};\par
611             m_may_fail          = {\cf17 false};\par
612             m_should_fail       = {\cf17 false};\par
613             m_expected_failures = 0;\par
614             m_timeout           = 0;\par
615             {\cf19 return} *{\cf17 this};\par
616         \}\par
617 \par
618         {\cf17 template} <{\cf17 typename} T>\par
619         TestSuite& operator*({\cf17 const} T& in) \{\par
620             in.fill(*{\cf17 this});\par
621             {\cf19 return} *{\cf17 this};\par
622         \}\par
623     \};\par
624 \} {\cf20 // namespace detail}\par
625 \} {\cf20 // namespace doctest}\par
626 \par
627 {\cf20 // in a separate namespace outside of doctest because the DOCTEST_TEST_SUITE macro}\par
628 {\cf20 // introduces an anonymous namespace in which getCurrentTestSuite gets overridden}\par
629 {\cf17 namespace }doctest_detail_test_suite_ns\par
630 \{\par
631 DOCTEST_INTERFACE doctest::detail::TestSuite& getCurrentTestSuite();\par
632 \} {\cf20 // namespace doctest_detail_test_suite_ns}\par
633 \par
634 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
635 \par
636 {\cf17 namespace }doctest\par
637 \{\par
638 {\cf20 // A 24 byte string class (can be as small as 17 for x64 and 13 for x86) that can hold strings with length}\par
639 {\cf20 // of up to 23 chars on the stack before going on the heap - the last byte of the buffer is used for:}\par
640 {\cf20 // - "is small" bit - the highest bit - if "0" then it is small - otherwise its "1" (128)}\par
641 {\cf20 // - if small - capacity left before going on the heap - using the lowest 5 bits}\par
642 {\cf20 // - if small - 2 bits are left unused - the second and third highest ones}\par
643 {\cf20 // - if small - acts as a null terminator if strlen() is 23 (24 including the null terminator)}\par
644 {\cf20 //              and the "is small" bit remains "0" ("as well as the capacity left") so its OK}\par
645 {\cf20 // Idea taken from this lecture about the string implementation of facebook/folly - fbstring}\par
646 {\cf20 // https://www.youtube.com/watch?v=kPR8h4-qZdk}\par
647 {\cf20 // TODO:}\par
648 {\cf20 // - optimizations - like not deleting memory unnecessarily in operator= and etc.}\par
649 {\cf20 // - resize/reserve/clear}\par
650 {\cf20 // - substr}\par
651 {\cf20 // - replace}\par
652 {\cf20 // - back/front}\par
653 {\cf20 // - iterator stuff}\par
654 {\cf20 // - find & friends}\par
655 {\cf20 // - push_back/pop_back}\par
656 {\cf20 // - assign/insert/erase}\par
657 {\cf20 // - relational operators as free functions - taking const char* as one of the params}\par
658 {\cf17 class }DOCTEST_INTERFACE String\par
659 \{\par
660     {\cf17 static} {\cf17 const} {\cf18 unsigned} len  = 24;      \par
661     {\cf17 static} {\cf17 const} {\cf18 unsigned} last = len - 1; \par
662 \par
663     {\cf17 struct }view {\cf20 // len should be more than sizeof(view) - because of the final byte for flags}\par
664     \{\par
665         {\cf18 char}*    ptr;\par
666         {\cf18 unsigned} size;\par
667         {\cf18 unsigned} capacity;\par
668     \};\par
669 \par
670     {\cf17 union}\par
671     \{\par
672         {\cf18 char} buf[len];\par
673         view data;\par
674     \};\par
675 \par
676     {\cf18 void} copy({\cf17 const} String& other);\par
677 \par
678     {\cf18 void} setOnHeap() \{ *{\cf17 reinterpret_cast<}{\cf18 unsigned} {\cf18 char}*{\cf17 >}(&buf[last]) = 128; \}\par
679     {\cf18 void} setLast({\cf18 unsigned} in = last) \{ buf[last] = char(in); \}\par
680 \par
681 {\cf17 public}:\par
682     String() \{\par
683         buf[0] = {\cf23 '\\0'};\par
684         setLast();\par
685     \}\par
686 \par
687     String({\cf17 const} {\cf18 char}* in);\par
688 \par
689     String({\cf17 const} String& other) \{ copy(other); \}\par
690 \par
691     ~String() \{\par
692         {\cf19 if}(!isOnStack())\par
693             {\cf17 delete}[] data.ptr;\par
694     \}\par
695 \par
696     {\cf20 // GCC 4.9/5/6 report Wstrict-overflow when optimizations are ON and it got inlined in the vector class somewhere...}\par
697     {\cf20 // see commit 574ef95f0cd379118be5011704664e4b5351f1e0 and build https://travis-ci.org/onqtam/doctest/builds/230671611}\par
698     DOCTEST_NOINLINE String& operator=({\cf17 const} String& other) \{\par
699         {\cf19 if}({\cf17 this} != &other) \{\par
700             {\cf19 if}(!isOnStack())\par
701                 {\cf17 delete}[] data.ptr;\par
702 \par
703             copy(other);\par
704         \}\par
705 \par
706         {\cf19 return} *{\cf17 this};\par
707     \}\par
708     String& operator+=({\cf17 const} String& other);\par
709 \par
710     String operator+({\cf17 const} String& other){\cf17  const }\{ {\cf19 return} String(*{\cf17 this}) += other; \}\par
711 \par
712 {\cf21 #ifdef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
713     String(String&& other);\par
714     String& operator=(String&& other);\par
715 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
716 \par
717     {\cf18 bool} isOnStack(){\cf17  const }\{ {\cf19 return} (buf[last] & 128) == 0; \}\par
718 \par
719     {\cf18 char} operator[]({\cf18 unsigned} i){\cf17  const }\{ {\cf19 return} {\cf17 const_cast<}String*{\cf17 >}({\cf17 this})->{\cf17 operator}[](i); \} {\cf20 // NOLINT}\par
720     {\cf18 char}& operator[]({\cf18 unsigned} i) \{\par
721         {\cf19 if}(isOnStack())\par
722             {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(buf)[i];\par
723         {\cf19 return} data.ptr[i];\par
724     \}\par
725 \par
726     {\cf17 const} {\cf18 char}* c_str(){\cf17  const }\{ {\cf19 return} {\cf17 const_cast<}String*{\cf17 >}({\cf17 this})->c_str(); \} {\cf20 // NOLINT}\par
727     {\cf18 char}*       c_str() \{\par
728         {\cf19 if}(isOnStack())\par
729             {\cf19 return} {\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(buf);\par
730         {\cf19 return} data.ptr;\par
731     \}\par
732 \par
733     DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH({\cf22 "-Wmaybe-uninitialized"})\par
734     unsigned size(){\cf17  const }\{\par
735         {\cf19 if}(isOnStack())\par
736             {\cf19 return} last - (unsigned(buf[last]) & 31); {\cf20 // using "last" would work only if "len" is 32}\par
737         {\cf19 return} data.size;\par
738     \}\par
739     DOCTEST_GCC_SUPPRESS_WARNING_POP\par
740 \par
741     {\cf18 unsigned} capacity(){\cf17  const }\{\par
742         {\cf19 if}(isOnStack())\par
743             {\cf19 return} len;\par
744         {\cf19 return} data.capacity;\par
745     \}\par
746 \par
747     {\cf18 int} compare({\cf17 const} {\cf18 char}* other, {\cf18 bool} no_case = {\cf17 false}) {\cf17 const};\par
748     {\cf18 int} compare({\cf17 const} String& other, {\cf18 bool} no_case = {\cf17 false}) {\cf17 const};\par
749 \};\par
750 \par
751 {\cf20 // clang-format off}\par
752 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} lhs.compare(rhs) == 0; \}\par
753 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} lhs.compare(rhs) != 0; \}\par
754 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} lhs.compare(rhs) < 0; \}\par
755 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} lhs.compare(rhs) > 0; \}\par
756 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} (lhs != rhs) ? lhs.compare(rhs) < 0 : {\cf17 true}; \}\par
757 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} String& lhs, {\cf17 const} String& rhs) \{ {\cf19 return} (lhs != rhs) ? lhs.compare(rhs) > 0 : {\cf17 true}; \}\par
758 {\cf20 // clang-format on}\par
759 \par
760 DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, {\cf17 const} String& in);\par
761 \par
762 {\cf17 namespace }detail\par
763 \{\par
764 {\cf21 #ifndef DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
765     {\cf17 namespace }static_assert_impl\par
766     \{\par
767         {\cf17 template} <{\cf18 bool}>\par
768         {\cf17 struct }StaticAssertion;\par
769 \par
770         {\cf17 template} <>\par
771         {\cf17 struct }StaticAssertion<true>\par
772         \{\};\par
773 \par
774         {\cf17 template} <{\cf18 int} i>\par
775         {\cf17 struct }StaticAssertionTest\par
776         \{\};\par
777     \}  {\cf20 // namespace static_assert_impl}\par
778 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_STATIC_ASSERT}\par
779 \par
780     {\cf17 template} <{\cf18 bool} CONDITION, {\cf17 typename} TYPE = {\cf18 void}>\par
781     {\cf17 struct }enable_if\par
782     \{\};\par
783 \par
784     {\cf17 template} <{\cf17 typename} TYPE>\par
785     {\cf17 struct }enable_if<true, TYPE>\par
786     \{ {\cf17 typedef} TYPE type; \};\par
787 \par
788     {\cf17 template} <{\cf17 typename} T>\par
789     {\cf17 struct }deferred_false\par
790     {\cf20 // cppcheck-suppress unusedStructMember}\par
791     \{ {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 false}; \};\par
792 \par
793     {\cf20 // to silence the warning "-Wzero-as-null-pointer-constant" only for gcc 5 for the Approx template ctor - pragmas don't work for it...}\par
794     {\cf17 inline} {\cf18 void}* getNull() \{ {\cf19 return} 0; \}\par
795 \par
796     {\cf17 namespace }has_insertion_operator_impl\par
797     \{\par
798         {\cf17 typedef} {\cf18 char} no;\par
799         {\cf17 typedef} {\cf18 char} yes[2];\par
800 \par
801         {\cf17 struct }any_t\par
802         \{\par
803             {\cf17 template} <{\cf17 typename} T>\par
804             {\cf20 // cppcheck-suppress noExplicitConstructor}\par
805             any_t({\cf17 const} DOCTEST_REF_WRAP(T));\par
806         \};\par
807 \par
808         yes& testStreamable(std::ostream&);\par
809         no   testStreamable(no);\par
810 \par
811         no operator<<({\cf17 const} std::ostream&, {\cf17 const} any_t&);\par
812 \par
813         {\cf17 template} <{\cf17 typename} T>\par
814         {\cf17 struct }has_insertion_operator\par
815         \{\par
816             {\cf17 static} std::ostream& s;\par
817             {\cf17 static} {\cf17 const} DOCTEST_REF_WRAP(T) t;\par
818             {\cf17 static} {\cf17 const} {\cf18 bool} value = {\cf17 sizeof}(testStreamable(s << t)) == {\cf17 sizeof}(yes);\par
819         \};\par
820     \} {\cf20 // namespace has_insertion_operator_impl}\par
821 \par
822     {\cf17 template} <{\cf17 typename} T>\par
823     {\cf17 struct }has_insertion_operator : has_insertion_operator_impl::has_insertion_operator<T>\par
824     \{\};\par
825 \par
826     DOCTEST_INTERFACE {\cf18 void} my_memcpy({\cf18 void}* dest, {\cf17 const} {\cf18 void}* src, {\cf18 unsigned} num);\par
827 \par
828     DOCTEST_INTERFACE std::ostream* createStream();\par
829     DOCTEST_INTERFACE String getStreamResult(std::ostream*);\par
830     DOCTEST_INTERFACE {\cf18 void}   freeStream(std::ostream*);\par
831 \par
832     {\cf17 template} <{\cf18 bool} C>\par
833     {\cf17 struct }StringMakerBase\par
834     \{\par
835         {\cf17 template} <{\cf17 typename} T>\par
836         {\cf17 static} String convert({\cf17 const} DOCTEST_REF_WRAP(T)) \{\par
837             {\cf19 return} {\cf22 "\{?\}"};\par
838         \}\par
839     \};\par
840 \par
841     {\cf17 template} <>\par
842     {\cf17 struct }StringMakerBase<true>\par
843     \{\par
844         {\cf17 template} <{\cf17 typename} T>\par
845         {\cf17 static} String convert({\cf17 const} DOCTEST_REF_WRAP(T) in) \{\par
846             std::ostream* s = createStream();\par
847             *s << in;\par
848             String result = getStreamResult(s);\par
849             freeStream(s);\par
850             {\cf19 return} result;\par
851         \}\par
852     \};\par
853 \par
854     DOCTEST_INTERFACE String rawMemoryToString({\cf17 const} {\cf18 void}* {\cf18 object}, {\cf18 unsigned} size);\par
855 \par
856     {\cf17 template} <{\cf17 typename} T>\par
857     String rawMemoryToString({\cf17 const} DOCTEST_REF_WRAP(T) {\cf18 object}) \{\par
858         {\cf19 return} rawMemoryToString(&{\cf18 object}, {\cf17 sizeof}({\cf18 object}));\par
859     \}\par
860 \par
861     {\cf17 class }NullType\par
862     \{\par
863     \};\par
864 \par
865     {\cf17 template} <{\cf17 class} T, {\cf17 class} U>\par
866     {\cf17 struct }Typelist\par
867     \{\par
868         {\cf17 typedef} T Head;\par
869         {\cf17 typedef} U Tail;\par
870     \};\par
871 \par
872     {\cf20 // type of recursive function}\par
873     {\cf17 template} <{\cf17 class} TList, {\cf17 class} Callable>\par
874     {\cf17 struct }ForEachType;\par
875 \par
876     {\cf20 // Recursion rule}\par
877     {\cf17 template} <{\cf17 class} Head, {\cf17 class} Tail, {\cf17 class} Callable>\par
878     {\cf17 struct }ForEachType<Typelist<Head, Tail>, Callable> : {\cf17 public} ForEachType<Tail, Callable>\par
879     \{\par
880         {\cf17 enum}\par
881         \{\par
882             value = 1 + ForEachType<Tail, Callable>::value\par
883         \};\par
884 \par
885         {\cf17 explicit} ForEachType(Callable& callable)\par
886                 : ForEachType<Tail, Callable>(callable) \{\par
887 {\cf21 #if DOCTEST_MSVC && DOCTEST_MSVC < DOCTEST_COMPILER(19, 10, 0)}\par
888             callable.operator()<value, Head>();\par
889 {\cf21 #else  }{\cf20 // MSVC}\par
890             callable.template operator()<value, Head>();\par
891 {\cf21 #endif }{\cf20 // MSVC}\par
892         \}\par
893     \};\par
894 \par
895     {\cf20 // Recursion end}\par
896     {\cf17 template} <{\cf17 class} Head, {\cf17 class} Callable>\par
897     {\cf17 struct }ForEachType<Typelist<Head, NullType>, Callable>\par
898     \{\par
899     {\cf17 public}:\par
900         {\cf17 enum}\par
901         \{\par
902             value = 0\par
903         \};\par
904 \par
905         {\cf17 explicit} ForEachType(Callable& callable) \{\par
906 {\cf21 #if DOCTEST_MSVC && DOCTEST_MSVC < DOCTEST_COMPILER(19, 10, 0)}\par
907             callable.operator()<value, Head>();\par
908 {\cf21 #else  }{\cf20 // MSVC}\par
909             callable.template operator()<value, Head>();\par
910 {\cf21 #endif }{\cf20 // MSVC}\par
911         \}\par
912     \};\par
913 \par
914     {\cf17 template} <{\cf17 typename} T>\par
915     {\cf17 const} {\cf18 char}* type_to_string() \{\par
916         {\cf19 return} {\cf22 "<>"};\par
917     \}\par
918 \} {\cf20 // namespace detail}\par
919 \par
920 {\cf17 template} <{\cf17 typename} T1 = detail::NullType, {\cf17 typename} T2 = detail::NullType,\par
921           {\cf17 typename} T3 = detail::NullType, {\cf17 typename} T4 = detail::NullType,\par
922           {\cf17 typename} T5 = detail::NullType, {\cf17 typename} T6 = detail::NullType,\par
923           {\cf17 typename} T7 = detail::NullType, {\cf17 typename} T8 = detail::NullType,\par
924           {\cf17 typename} T9 = detail::NullType, {\cf17 typename} T10 = detail::NullType,\par
925           {\cf17 typename} T11 = detail::NullType, {\cf17 typename} T12 = detail::NullType,\par
926           {\cf17 typename} T13 = detail::NullType, {\cf17 typename} T14 = detail::NullType,\par
927           {\cf17 typename} T15 = detail::NullType, {\cf17 typename} T16 = detail::NullType,\par
928           {\cf17 typename} T17 = detail::NullType, {\cf17 typename} T18 = detail::NullType,\par
929           {\cf17 typename} T19 = detail::NullType, {\cf17 typename} T20 = detail::NullType,\par
930           {\cf17 typename} T21 = detail::NullType, {\cf17 typename} T22 = detail::NullType,\par
931           {\cf17 typename} T23 = detail::NullType, {\cf17 typename} T24 = detail::NullType,\par
932           {\cf17 typename} T25 = detail::NullType, {\cf17 typename} T26 = detail::NullType,\par
933           {\cf17 typename} T27 = detail::NullType, {\cf17 typename} T28 = detail::NullType,\par
934           {\cf17 typename} T29 = detail::NullType, {\cf17 typename} T30 = detail::NullType,\par
935           {\cf17 typename} T31 = detail::NullType, {\cf17 typename} T32 = detail::NullType,\par
936           {\cf17 typename} T33 = detail::NullType, {\cf17 typename} T34 = detail::NullType,\par
937           {\cf17 typename} T35 = detail::NullType, {\cf17 typename} T36 = detail::NullType,\par
938           {\cf17 typename} T37 = detail::NullType, {\cf17 typename} T38 = detail::NullType,\par
939           {\cf17 typename} T39 = detail::NullType, {\cf17 typename} T40 = detail::NullType,\par
940           {\cf17 typename} T41 = detail::NullType, {\cf17 typename} T42 = detail::NullType,\par
941           {\cf17 typename} T43 = detail::NullType, {\cf17 typename} T44 = detail::NullType,\par
942           {\cf17 typename} T45 = detail::NullType, {\cf17 typename} T46 = detail::NullType,\par
943           {\cf17 typename} T47 = detail::NullType, {\cf17 typename} T48 = detail::NullType,\par
944           {\cf17 typename} T49 = detail::NullType, {\cf17 typename} T50 = detail::NullType,\par
945           {\cf17 typename} T51 = detail::NullType, {\cf17 typename} T52 = detail::NullType,\par
946           {\cf17 typename} T53 = detail::NullType, {\cf17 typename} T54 = detail::NullType,\par
947           {\cf17 typename} T55 = detail::NullType, {\cf17 typename} T56 = detail::NullType,\par
948           {\cf17 typename} T57 = detail::NullType, {\cf17 typename} T58 = detail::NullType,\par
949           {\cf17 typename} T59 = detail::NullType, {\cf17 typename} T60 = detail::NullType>\par
950 {\cf17 struct }Types\par
951 \{\par
952 {\cf17 private}:\par
953     {\cf17 typedef} {\cf17 typename} Types<T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17,\par
954                            T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31,\par
955                            T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,\par
956                            T46, T47, T48, T49, T50, T51, T52, T53, T54, T55, T56, T57, T58, T59,\par
957                            T60>::Result TailResult;\par
958 \par
959 {\cf17 public}:\par
960     {\cf17 typedef} detail::Typelist<T1, TailResult> Result;\par
961 \};\par
962 \par
963 {\cf17 template} <>\par
964 {\cf17 struct }Types<>\par
965 \{ {\cf17 typedef} detail::NullType Result; \};\par
966 \par
967 {\cf17 template} <{\cf17 typename} T>\par
968 {\cf17 struct }StringMaker : detail::StringMakerBase<detail::has_insertion_operator<T>::value>\par
969 \{\};\par
970 \par
971 {\cf17 template} <{\cf17 typename} T>\par
972 {\cf17 struct }StringMaker<T*>\par
973 \{\par
974     {\cf17 template} <{\cf17 typename} U>\par
975     {\cf17 static} String convert(U* p) \{\par
976         {\cf19 if}(p)\par
977             {\cf19 return} detail::rawMemoryToString(p);\par
978         {\cf19 return} {\cf22 "NULL"};\par
979     \}\par
980 \};\par
981 \par
982 {\cf17 template} <{\cf17 typename} R, {\cf17 typename} C>\par
983 {\cf17 struct }StringMaker<R C::*>\par
984 \{\par
985     {\cf17 static} String convert(R C::*p) \{\par
986         {\cf19 if}(p)\par
987             {\cf19 return} detail::rawMemoryToString(p);\par
988         {\cf19 return} {\cf22 "NULL"};\par
989     \}\par
990 \};\par
991 \par
992 {\cf17 template} <{\cf17 typename} T>\par
993 String toString({\cf17 const} DOCTEST_REF_WRAP(T) value) \{\par
994     {\cf19 return} StringMaker<T>::convert(value);\par
995 \}\par
996 \par
997 {\cf21 #ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
998 DOCTEST_INTERFACE String toString({\cf18 char}* in);\par
999 DOCTEST_INTERFACE String toString({\cf17 const} {\cf18 char}* in);\par
1000 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1001 DOCTEST_INTERFACE String toString({\cf18 bool} in);\par
1002 DOCTEST_INTERFACE String toString({\cf18 float} in);\par
1003 DOCTEST_INTERFACE String toString({\cf18 double} in);\par
1004 DOCTEST_INTERFACE String toString({\cf18 double} {\cf18 long} in);\par
1005 \par
1006 DOCTEST_INTERFACE String toString({\cf18 char} in);\par
1007 DOCTEST_INTERFACE String toString({\cf18 char} {\cf18 signed} in);\par
1008 DOCTEST_INTERFACE String toString({\cf18 char} {\cf18 unsigned} in);\par
1009 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 short} in);\par
1010 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 short} {\cf18 unsigned} in);\par
1011 DOCTEST_INTERFACE String toString({\cf18 int} in);\par
1012 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 unsigned} in);\par
1013 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 long} in);\par
1014 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 long} {\cf18 unsigned} in);\par
1015 \par
1016 {\cf21 #ifdef DOCTEST_CONFIG_WITH_LONG_LONG}\par
1017 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 long} {\cf18 long} in);\par
1018 DOCTEST_INTERFACE String toString({\cf18 int} {\cf18 long} {\cf18 long} {\cf18 unsigned} in);\par
1019 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
1020 \par
1021 {\cf21 #ifdef DOCTEST_CONFIG_WITH_NULLPTR}\par
1022 DOCTEST_INTERFACE String toString(std::nullptr_t in);\par
1023 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_NULLPTR}\par
1024 \par
1025 {\cf17 class }DOCTEST_INTERFACE Approx\par
1026 \{\par
1027 {\cf17 public}:\par
1028     {\cf17 explicit} Approx({\cf18 double} value);\par
1029 \par
1030     Approx operator()({\cf18 double} value){\cf17  const }\{\par
1031         Approx approx(value);\par
1032         approx.epsilon(m_epsilon);\par
1033         approx.scale(m_scale);\par
1034         {\cf19 return} approx;\par
1035     \}\par
1036 \par
1037 {\cf21 #ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1038     {\cf17 template} <{\cf17 typename} T>\par
1039     {\cf17 explicit} Approx({\cf17 const} T& value,\par
1040                     {\cf17 typename} detail::enable_if<std::is_constructible<double, T>::value>::type* =\par
1041                             {\cf17 static_cast<}T*{\cf17 >}(detail::getNull())) \{\par
1042         *{\cf17 this} = Approx({\cf17 static_cast<}{\cf18 double}{\cf17 >}(value));\par
1043     \}\par
1044 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1045 \par
1046     {\cf20 // clang-format off}\par
1047     {\cf20 // overloads for double - the first one is necessary as it is in the implementation part of doctest}\par
1048     {\cf20 // as for the others - keeping them for potentially faster compile times}\par
1049     DOCTEST_INTERFACE {\cf17 friend} {\cf18 bool} operator==({\cf18 double} lhs, Approx {\cf17 const}& rhs);\par
1050     {\cf17 friend} {\cf18 bool} operator==(Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} operator==(rhs, lhs); \}\par
1051     {\cf17 friend} {\cf18 bool} operator!=({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{ {\cf19 return} !operator==(lhs, rhs); \}\par
1052     {\cf17 friend} {\cf18 bool} operator!=(Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} !operator==(rhs, lhs); \}\par
1053     {\cf17 friend} {\cf18 bool} operator<=({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{ {\cf19 return} lhs < rhs.m_value || lhs == rhs; \}\par
1054     {\cf17 friend} {\cf18 bool} operator<=(Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} lhs.m_value < rhs || lhs == rhs; \}\par
1055     {\cf17 friend} {\cf18 bool} operator>=({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{ {\cf19 return} lhs > rhs.m_value || lhs == rhs; \}\par
1056     {\cf17 friend} {\cf18 bool} operator>=(Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} lhs.m_value > rhs || lhs == rhs; \}\par
1057     {\cf17 friend} {\cf18 bool} operator< ({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{ {\cf19 return} lhs < rhs.m_value && lhs != rhs; \}\par
1058     {\cf17 friend} {\cf18 bool} operator< (Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} lhs.m_value < rhs && lhs != rhs; \}\par
1059     {\cf17 friend} {\cf18 bool} operator> ({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{ {\cf19 return} lhs > rhs.m_value && lhs != rhs; \}\par
1060     {\cf17 friend} {\cf18 bool} operator> (Approx {\cf17 const}& lhs, {\cf18 double} rhs) \{ {\cf19 return} lhs.m_value > rhs && lhs != rhs; \}\par
1061 \par
1062 {\cf21 #ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1063 {\cf21 #define DOCTEST_APPROX_PREFIX \\}\par
1064 {\cf21     template <typename T> friend typename detail::enable_if<std::is_constructible<double, T>::value, bool>::type}\par
1065 \par
1066     DOCTEST_APPROX_PREFIX operator==({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} operator==({\cf18 double}(lhs), rhs); \}\par
1067     DOCTEST_APPROX_PREFIX operator==({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} operator==(rhs, lhs); \}\par
1068     DOCTEST_APPROX_PREFIX operator!=({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} !operator==(lhs, rhs); \}\par
1069     DOCTEST_APPROX_PREFIX operator!=({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} !operator==(rhs, lhs); \}\par
1070     DOCTEST_APPROX_PREFIX operator<=({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} double(lhs) < rhs.m_value || lhs == rhs; \}\par
1071     DOCTEST_APPROX_PREFIX operator<=({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} lhs.m_value < double(rhs) || lhs == rhs; \}\par
1072     DOCTEST_APPROX_PREFIX operator>=({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} double(lhs) > rhs.m_value || lhs == rhs; \}\par
1073     DOCTEST_APPROX_PREFIX operator>=({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} lhs.m_value > double(rhs) || lhs == rhs; \}\par
1074     DOCTEST_APPROX_PREFIX operator< ({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} double(lhs) < rhs.m_value && lhs != rhs; \}\par
1075     DOCTEST_APPROX_PREFIX operator< ({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} lhs.m_value < double(rhs) && lhs != rhs; \}\par
1076     DOCTEST_APPROX_PREFIX operator> ({\cf17 const} T& lhs, {\cf17 const} Approx& rhs) \{ {\cf19 return} double(lhs) > rhs.m_value && lhs != rhs; \}\par
1077     DOCTEST_APPROX_PREFIX operator> ({\cf17 const} Approx& lhs, {\cf17 const} T& rhs) \{ {\cf19 return} lhs.m_value > double(rhs) && lhs != rhs; \}\par
1078 {\cf21 #undef DOCTEST_APPROX_PREFIX}\par
1079 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1080 \par
1081     {\cf20 // clang-format on}\par
1082 \par
1083     Approx& epsilon({\cf18 double} newEpsilon) \{\par
1084         m_epsilon = newEpsilon;\par
1085         {\cf19 return} *{\cf17 this};\par
1086     \}\par
1087 \par
1088 {\cf21 #ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1089     {\cf17 template} <{\cf17 typename} T>\par
1090     {\cf17 typename} detail::enable_if<std::is_constructible<double, T>::value, Approx&>::type epsilon(\par
1091             {\cf17 const} T& newEpsilon) \{\par
1092         m_epsilon = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newEpsilon);\par
1093         {\cf19 return} *{\cf17 this};\par
1094     \}\par
1095 {\cf21 #endif }{\cf20 //  DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1096 \par
1097     Approx& scale({\cf18 double} newScale) \{\par
1098         m_scale = newScale;\par
1099         {\cf19 return} *{\cf17 this};\par
1100     \}\par
1101 \par
1102 {\cf21 #ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1103     {\cf17 template} <{\cf17 typename} T>\par
1104     {\cf17 typename} detail::enable_if<std::is_constructible<double, T>::value, Approx&>::type scale(\par
1105             {\cf17 const} T& newScale) \{\par
1106         m_scale = {\cf17 static_cast<}{\cf18 double}{\cf17 >}(newScale);\par
1107         {\cf19 return} *{\cf17 this};\par
1108     \}\par
1109 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS}\par
1110 \par
1111     String toString() {\cf17 const};\par
1112 \par
1113 {\cf17 private}:\par
1114     {\cf18 double} m_epsilon;\par
1115     {\cf18 double} m_scale;\par
1116     {\cf18 double} m_value;\par
1117 \};\par
1118 \par
1119 {\cf17 template} <>\par
1120 {\cf17 inline} String toString<Approx>({\cf17 const} DOCTEST_REF_WRAP(Approx) value) \{\par
1121     {\cf19 return} value.toString();\par
1122 \}\par
1123 \par
1124 {\cf21 #if !defined(DOCTEST_CONFIG_DISABLE)}\par
1125 \par
1126 {\cf17 namespace }detail\par
1127 \{\par
1128     {\cf20 // the function type this library works with}\par
1129     {\cf17 typedef} void (*funcType)();\par
1130 \par
1131     {\cf17 namespace }assertType\par
1132     \{\par
1133         {\cf17 enum} Enum\par
1134         \{\par
1135             {\cf20 // macro traits}\par
1136 \par
1137             is_warn    = 1,\par
1138             is_check   = 2,\par
1139             is_require = 4,\par
1140 \par
1141             is_throws    = 8,\par
1142             is_throws_as = 16,\par
1143             is_nothrow   = 32,\par
1144 \par
1145             is_fast  = 64, {\cf20 // not checked anywhere - used just to distinguish the types}\par
1146             is_false = 128,\par
1147             is_unary = 256,\par
1148 \par
1149             is_eq = 512,\par
1150             is_ne = 1024,\par
1151 \par
1152             is_lt = 2048,\par
1153             is_gt = 4096,\par
1154 \par
1155             is_ge = 8192,\par
1156             is_le = 16384,\par
1157 \par
1158             {\cf20 // macro types}\par
1159 \par
1160             DT_WARN    = is_warn,\par
1161             DT_CHECK   = is_check,\par
1162             DT_REQUIRE = is_require,\par
1163 \par
1164             DT_WARN_FALSE    = is_false | is_warn,\par
1165             DT_CHECK_FALSE   = is_false | is_check,\par
1166             DT_REQUIRE_FALSE = is_false | is_require,\par
1167 \par
1168             DT_WARN_THROWS    = is_throws | is_warn,\par
1169             DT_CHECK_THROWS   = is_throws | is_check,\par
1170             DT_REQUIRE_THROWS = is_throws | is_require,\par
1171 \par
1172             DT_WARN_THROWS_AS    = is_throws_as | is_warn,\par
1173             DT_CHECK_THROWS_AS   = is_throws_as | is_check,\par
1174             DT_REQUIRE_THROWS_AS = is_throws_as | is_require,\par
1175 \par
1176             DT_WARN_NOTHROW    = is_nothrow | is_warn,\par
1177             DT_CHECK_NOTHROW   = is_nothrow | is_check,\par
1178             DT_REQUIRE_NOTHROW = is_nothrow | is_require,\par
1179 \par
1180             DT_WARN_EQ    = is_eq | is_warn,\par
1181             DT_CHECK_EQ   = is_eq | is_check,\par
1182             DT_REQUIRE_EQ = is_eq | is_require,\par
1183 \par
1184             DT_WARN_NE    = is_ne | is_warn,\par
1185             DT_CHECK_NE   = is_ne | is_check,\par
1186             DT_REQUIRE_NE = is_ne | is_require,\par
1187 \par
1188             DT_WARN_GT    = is_gt | is_warn,\par
1189             DT_CHECK_GT   = is_gt | is_check,\par
1190             DT_REQUIRE_GT = is_gt | is_require,\par
1191 \par
1192             DT_WARN_LT    = is_lt | is_warn,\par
1193             DT_CHECK_LT   = is_lt | is_check,\par
1194             DT_REQUIRE_LT = is_lt | is_require,\par
1195 \par
1196             DT_WARN_GE    = is_ge | is_warn,\par
1197             DT_CHECK_GE   = is_ge | is_check,\par
1198             DT_REQUIRE_GE = is_ge | is_require,\par
1199 \par
1200             DT_WARN_LE    = is_le | is_warn,\par
1201             DT_CHECK_LE   = is_le | is_check,\par
1202             DT_REQUIRE_LE = is_le | is_require,\par
1203 \par
1204             DT_WARN_UNARY    = is_unary | is_warn,\par
1205             DT_CHECK_UNARY   = is_unary | is_check,\par
1206             DT_REQUIRE_UNARY = is_unary | is_require,\par
1207 \par
1208             DT_WARN_UNARY_FALSE    = is_false | is_unary | is_warn,\par
1209             DT_CHECK_UNARY_FALSE   = is_false | is_unary | is_check,\par
1210             DT_REQUIRE_UNARY_FALSE = is_false | is_unary | is_require,\par
1211 \par
1212             DT_FAST_WARN_EQ    = is_fast | is_eq | is_warn,\par
1213             DT_FAST_CHECK_EQ   = is_fast | is_eq | is_check,\par
1214             DT_FAST_REQUIRE_EQ = is_fast | is_eq | is_require,\par
1215 \par
1216             DT_FAST_WARN_NE    = is_fast | is_ne | is_warn,\par
1217             DT_FAST_CHECK_NE   = is_fast | is_ne | is_check,\par
1218             DT_FAST_REQUIRE_NE = is_fast | is_ne | is_require,\par
1219 \par
1220             DT_FAST_WARN_GT    = is_fast | is_gt | is_warn,\par
1221             DT_FAST_CHECK_GT   = is_fast | is_gt | is_check,\par
1222             DT_FAST_REQUIRE_GT = is_fast | is_gt | is_require,\par
1223 \par
1224             DT_FAST_WARN_LT    = is_fast | is_lt | is_warn,\par
1225             DT_FAST_CHECK_LT   = is_fast | is_lt | is_check,\par
1226             DT_FAST_REQUIRE_LT = is_fast | is_lt | is_require,\par
1227 \par
1228             DT_FAST_WARN_GE    = is_fast | is_ge | is_warn,\par
1229             DT_FAST_CHECK_GE   = is_fast | is_ge | is_check,\par
1230             DT_FAST_REQUIRE_GE = is_fast | is_ge | is_require,\par
1231 \par
1232             DT_FAST_WARN_LE    = is_fast | is_le | is_warn,\par
1233             DT_FAST_CHECK_LE   = is_fast | is_le | is_check,\par
1234             DT_FAST_REQUIRE_LE = is_fast | is_le | is_require,\par
1235 \par
1236             DT_FAST_WARN_UNARY    = is_fast | is_unary | is_warn,\par
1237             DT_FAST_CHECK_UNARY   = is_fast | is_unary | is_check,\par
1238             DT_FAST_REQUIRE_UNARY = is_fast | is_unary | is_require,\par
1239 \par
1240             DT_FAST_WARN_UNARY_FALSE    = is_fast | is_false | is_unary | is_warn,\par
1241             DT_FAST_CHECK_UNARY_FALSE   = is_fast | is_false | is_unary | is_check,\par
1242             DT_FAST_REQUIRE_UNARY_FALSE = is_fast | is_false | is_unary | is_require\par
1243         \};\par
1244     \} {\cf20 // namespace assertType}\par
1245 \par
1246     DOCTEST_INTERFACE {\cf17 const} {\cf18 char}* assertString(assertType::Enum val);\par
1247 \par
1248     {\cf20 // clang-format off}\par
1249     {\cf17 template}<{\cf17 class} T>               {\cf17 struct }decay_array       \{ {\cf17 typedef} T type; \};\par
1250     {\cf17 template}<{\cf17 class} T, {\cf18 unsigned} N>   {\cf17 struct }decay_array<T[N]> \{ {\cf17 typedef} T* type; \};\par
1251     {\cf17 template}<{\cf17 class} T>               {\cf17 struct }decay_array<T[]>  \{ {\cf17 typedef} T* type; \};\par
1252 \par
1253     {\cf17 template}<{\cf17 class} T>   {\cf17 struct }not_char_pointer              \{ {\cf17 enum} \{ value = 1 \}; \};\par
1254     {\cf17 template}<>          {\cf17 struct }not_char_pointer<char*>       \{ {\cf17 enum} \{ value = 0 \}; \};\par
1255     {\cf17 template}<>          {\cf17 struct }not_char_pointer<const char*> \{ {\cf17 enum} \{ value = 0 \}; \};\par
1256 \par
1257     {\cf17 template}<{\cf17 class} T> {\cf17 struct }can_use_op : not_char_pointer<typename decay_array<T>::type> \{\};\par
1258     {\cf20 // clang-format on}\par
1259 \par
1260     {\cf17 struct }TestFailureException\par
1261     \{\par
1262     \};\par
1263 \par
1264     DOCTEST_INTERFACE {\cf18 bool} checkIfShouldThrow(assertType::Enum at);\par
1265     DOCTEST_INTERFACE {\cf18 void} fastAssertThrowIfFlagSet({\cf18 int} flags);\par
1266 \par
1267     {\cf17 struct }TestAccessibleContextState\par
1268     \{\par
1269         {\cf18 bool} no_throw; {\cf20 // to skip exceptions-related assertion macros}\par
1270         {\cf18 bool} success;  {\cf20 // include successful assertions in output}\par
1271     \};\par
1272 \par
1273     {\cf17 struct }ContextState;\par
1274 \par
1275     DOCTEST_INTERFACE TestAccessibleContextState* getTestsContextState();\par
1276 \par
1277     {\cf17 struct }DOCTEST_INTERFACE SubcaseSignature\par
1278     \{\par
1279         {\cf17 const} {\cf18 char}* m_name;\par
1280         {\cf17 const} {\cf18 char}* m_file;\par
1281         {\cf18 int}         m_line;\par
1282 \par
1283         SubcaseSignature({\cf17 const} {\cf18 char}* name, {\cf17 const} {\cf18 char}* file, {\cf18 int} line)\par
1284                 : m_name(name)\par
1285                 , m_file(file)\par
1286                 , m_line(line) \{\}\par
1287 \par
1288         {\cf18 bool} operator<({\cf17 const} SubcaseSignature& other) {\cf17 const};\par
1289     \};\par
1290 \par
1291     {\cf20 // cppcheck-suppress copyCtorAndEqOperator}\par
1292     {\cf17 struct }DOCTEST_INTERFACE Subcase\par
1293     \{\par
1294         SubcaseSignature m_signature;\par
1295         {\cf18 bool}             m_entered;\par
1296 \par
1297         Subcase({\cf17 const} {\cf18 char}* name, {\cf17 const} {\cf18 char}* file, {\cf18 int} line);\par
1298         Subcase({\cf17 const} Subcase& other);\par
1299         ~Subcase();\par
1300 \par
1301         {\cf17 operator} bool(){\cf17  const }\{ {\cf19 return} m_entered; \}\par
1302     \};\par
1303 \par
1304     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R>\par
1305     String stringifyBinaryExpr({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} {\cf18 char}* op,\par
1306                                {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{\par
1307         {\cf19 return} toString(lhs) + op + toString(rhs);\par
1308     \}\par
1309 \par
1310     {\cf17 struct }DOCTEST_INTERFACE Result\par
1311     \{\par
1312         {\cf18 bool}   m_passed;\par
1313         String m_decomposition;\par
1314 \par
1315         ~Result();\par
1316 \par
1317         DOCTEST_NOINLINE Result({\cf18 bool} passed = {\cf17 false}, {\cf17 const} String& decomposition = String())\par
1318                 : m_passed(passed)\par
1319                 , m_decomposition(decomposition) \{\}\par
1320 \par
1321         DOCTEST_NOINLINE Result({\cf17 const} Result& other)\par
1322                 : m_passed(other.m_passed)\par
1323                 , m_decomposition(other.m_decomposition) \{\}\par
1324 \par
1325         Result& operator=({\cf17 const} Result& other);\par
1326 \par
1327         {\cf17 operator} bool() \{ {\cf19 return} !m_passed; \}\par
1328 \par
1329         {\cf20 // clang-format off}\par
1330         {\cf20 // forbidding some expressions based on this table: http://en.cppreference.com/w/cpp/language/operator_precedence}\par
1331         {\cf17 template} <{\cf17 typename} R> Result& operator&  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1332         {\cf17 template} <{\cf17 typename} R> Result& operator^  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1333         {\cf17 template} <{\cf17 typename} R> Result& operator|  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1334         {\cf17 template} <{\cf17 typename} R> Result& operator&& ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1335         {\cf17 template} <{\cf17 typename} R> Result& operator|| ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1336         {\cf17 template} <{\cf17 typename} R> Result& operator== ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1337         {\cf17 template} <{\cf17 typename} R> Result& operator!= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1338         {\cf17 template} <{\cf17 typename} R> Result& operator<  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1339         {\cf17 template} <{\cf17 typename} R> Result& operator>  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1340         {\cf17 template} <{\cf17 typename} R> Result& operator<= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1341         {\cf17 template} <{\cf17 typename} R> Result& operator>= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1342         {\cf17 template} <{\cf17 typename} R> Result& operator=  ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1343         {\cf17 template} <{\cf17 typename} R> Result& operator+= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1344         {\cf17 template} <{\cf17 typename} R> Result& operator-= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1345         {\cf17 template} <{\cf17 typename} R> Result& operator*= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1346         {\cf17 template} <{\cf17 typename} R> Result& operator/= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1347         {\cf17 template} <{\cf17 typename} R> Result& operator%= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1348         {\cf17 template} <{\cf17 typename} R> Result& operator<<=({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1349         {\cf17 template} <{\cf17 typename} R> Result& operator>>=({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1350         {\cf17 template} <{\cf17 typename} R> Result& operator&= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1351         {\cf17 template} <{\cf17 typename} R> Result& operator^= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1352         {\cf17 template} <{\cf17 typename} R> Result& operator|= ({\cf17 const} R&) \{ DOCTEST_STATIC_ASSERT(deferred_false<R>::value, Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison); {\cf19 return} *{\cf17 this}; \}\par
1353         {\cf20 // clang-format on}\par
1354     \};\par
1355 \par
1356 {\cf21 #ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION}\par
1357 \par
1358     DOCTEST_CLANG_SUPPRESS_WARNING_PUSH\par
1359     DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wsign-conversion"})\par
1360     DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-compare")\par
1361     {\cf20 //DOCTEST_CLANG_SUPPRESS_WARNING("-Wdouble-promotion")}\par
1362     {\cf20 //DOCTEST_CLANG_SUPPRESS_WARNING("-Wconversion")}\par
1363     {\cf20 //DOCTEST_CLANG_SUPPRESS_WARNING("-Wfloat-equal")}\par
1364 \par
1365     DOCTEST_GCC_SUPPRESS_WARNING_PUSH\par
1366     DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")\par
1367     DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-compare")\par
1368     {\cf20 //DOCTEST_GCC_SUPPRESS_WARNING("-Wdouble-promotion")}\par
1369     {\cf20 //DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")}\par
1370     {\cf20 //DOCTEST_GCC_SUPPRESS_WARNING("-Wfloat-equal")}\par
1371 \par
1372     DOCTEST_MSVC_SUPPRESS_WARNING_PUSH\par
1373     {\cf20 // http://stackoverflow.com/questions/39479163 what's the difference between C4018 and C4389}\par
1374     DOCTEST_MSVC_SUPPRESS_WARNING(4388) {\cf20 // signed/unsigned mismatch}\par
1375     DOCTEST_MSVC_SUPPRESS_WARNING(4389) {\cf20 // 'operator' : signed/unsigned mismatch}\par
1376     DOCTEST_MSVC_SUPPRESS_WARNING(4018) {\cf20 // 'expression' : signed/unsigned mismatch}\par
1377     {\cf20 //DOCTEST_MSVC_SUPPRESS_WARNING(4805) // 'operation' : unsafe mix of type 'type' and type 'type' in operation}\par
1378 \par
1379 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION}\par
1380 \par
1381 {\cf20 // clang-format off}\par
1382 {\cf21 #ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1383 {\cf21 #define DOCTEST_COMPARISON_RETURN_TYPE bool}\par
1384 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1385 {\cf21 #define DOCTEST_COMPARISON_RETURN_TYPE typename enable_if<can_use_op<L>::value || can_use_op<R>::value, bool>::type}\par
1386     {\cf17 inline} {\cf18 bool} eq({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) == String(rhs); \}\par
1387     {\cf17 inline} {\cf18 bool} ne({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) != String(rhs); \}\par
1388     {\cf17 inline} {\cf18 bool} lt({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) <  String(rhs); \}\par
1389     {\cf17 inline} {\cf18 bool} gt({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) >  String(rhs); \}\par
1390     {\cf17 inline} {\cf18 bool} le({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) <= String(rhs); \}\par
1391     {\cf17 inline} {\cf18 bool} ge({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 char}* rhs) \{ {\cf19 return} String(lhs) >= String(rhs); \}\par
1392 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1393 \par
1394     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE eq({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs == rhs; \}\par
1395     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE ne({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs != rhs; \}\par
1396     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE lt({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs <  rhs; \}\par
1397     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE gt({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs >  rhs; \}\par
1398     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE le({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs <= rhs; \}\par
1399     {\cf17 template} <{\cf17 typename} L, {\cf17 typename} R> DOCTEST_COMPARISON_RETURN_TYPE ge({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{ {\cf19 return} lhs >= rhs; \}\par
1400     {\cf20 // clang-format on}\par
1401 \par
1402 {\cf21 #ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1403 {\cf21 #define DOCTEST_CMP_EQ(l, r) l == r}\par
1404 {\cf21 #define DOCTEST_CMP_NE(l, r) l != r}\par
1405 {\cf21 #define DOCTEST_CMP_GT(l, r) l > r}\par
1406 {\cf21 #define DOCTEST_CMP_LT(l, r) l < r}\par
1407 {\cf21 #define DOCTEST_CMP_GE(l, r) l >= r}\par
1408 {\cf21 #define DOCTEST_CMP_LE(l, r) l <= r}\par
1409 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1410 {\cf21 #define DOCTEST_CMP_EQ(l, r) eq(l, r)}\par
1411 {\cf21 #define DOCTEST_CMP_NE(l, r) ne(l, r)}\par
1412 {\cf21 #define DOCTEST_CMP_GT(l, r) gt(l, r)}\par
1413 {\cf21 #define DOCTEST_CMP_LT(l, r) lt(l, r)}\par
1414 {\cf21 #define DOCTEST_CMP_GE(l, r) ge(l, r)}\par
1415 {\cf21 #define DOCTEST_CMP_LE(l, r) le(l, r)}\par
1416 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1417 \par
1418 {\cf21 #define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(op, op_str, op_macro)                              \\}\par
1419 {\cf21     template <typename R>                                                                          \\}\par
1420 {\cf21     DOCTEST_NOINLINE Result operator op(const DOCTEST_REF_WRAP(R) rhs) \{                           \\}\par
1421 {\cf21         bool res = op_macro(lhs, rhs);                                                             \\}\par
1422 {\cf21         if(m_assert_type & assertType::is_false)                                                   \\}\par
1423 {\cf21             res = !res;                                                                            \\}\par
1424 {\cf21         if(!res || doctest::detail::getTestsContextState()->success)                               \\}\par
1425 {\cf21             return Result(res, stringifyBinaryExpr(lhs, op_str, rhs));                             \\}\par
1426 {\cf21         return Result(res);                                                                        \\}\par
1427 {\cf21     \}}\par
1428 \par
1429 {\cf21 #define DOCTEST_FORBIT_EXPRESSION(op)                                                              \\}\par
1430 {\cf21     template <typename R>                                                                          \\}\par
1431 {\cf21     Expression_lhs& operator op(const R&) \{                                                        \\}\par
1432 {\cf21         DOCTEST_STATIC_ASSERT(deferred_false<R>::value,                                            \\}\par
1433 {\cf21                               Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison);         \\}\par
1434 {\cf21         return *this;                                                                              \\}\par
1435 {\cf21     \}}\par
1436 \par
1437     {\cf17 template} <{\cf17 typename} L>\par
1438     {\cf20 // cppcheck-suppress copyCtorAndEqOperator}\par
1439     {\cf17 struct }Expression_lhs\par
1440     \{\par
1441         L                lhs;\par
1442         assertType::Enum m_assert_type;\par
1443 \par
1444         {\cf17 explicit} Expression_lhs(L in, assertType::Enum at)\par
1445                 : lhs(in)\par
1446                 , m_assert_type(at) \{\}\par
1447 \par
1448         DOCTEST_NOINLINE {\cf17 operator} Result() \{\par
1449             {\cf18 bool} res = !!lhs;\par
1450             {\cf19 if}(m_assert_type & assertType::is_false) \par
1451                 res = !res;\par
1452 \par
1453             {\cf19 if}(!res || getTestsContextState()->success)\par
1454                 {\cf19 return} Result(res, toString(lhs));\par
1455             {\cf19 return} Result(res);\par
1456         \}\par
1457 \par
1458         {\cf20 // clang-format off}\par
1459         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(==, {\cf22 " == "}, DOCTEST_CMP_EQ) \par
1460         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(!=, {\cf22 " != "}, DOCTEST_CMP_NE) \par
1461         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>,  {\cf22 " >  "}, DOCTEST_CMP_GT) \par
1462         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<,  {\cf22 " <  "}, DOCTEST_CMP_LT) \par
1463         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>=, {\cf22 " >= "}, DOCTEST_CMP_GE) \par
1464         DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<=, {\cf22 " <= "}, DOCTEST_CMP_LE) \par
1465         {\cf20 // clang-format on}\par
1466 \par
1467         {\cf20 // forbidding some expressions based on this table: http://en.cppreference.com/w/cpp/language/operator_precedence}\par
1468         DOCTEST_FORBIT_EXPRESSION(&)\par
1469         DOCTEST_FORBIT_EXPRESSION(^)\par
1470         DOCTEST_FORBIT_EXPRESSION(|)\par
1471         DOCTEST_FORBIT_EXPRESSION(&&)\par
1472         DOCTEST_FORBIT_EXPRESSION(||)\par
1473         DOCTEST_FORBIT_EXPRESSION(=)\par
1474         DOCTEST_FORBIT_EXPRESSION(+=)\par
1475         DOCTEST_FORBIT_EXPRESSION(-=)\par
1476         DOCTEST_FORBIT_EXPRESSION(*=)\par
1477         DOCTEST_FORBIT_EXPRESSION(/=)\par
1478         DOCTEST_FORBIT_EXPRESSION(%=)\par
1479         DOCTEST_FORBIT_EXPRESSION(<<=)\par
1480         DOCTEST_FORBIT_EXPRESSION(>>=)\par
1481         DOCTEST_FORBIT_EXPRESSION(&=)\par
1482         DOCTEST_FORBIT_EXPRESSION(^=)\par
1483         DOCTEST_FORBIT_EXPRESSION(|=)\par
1484         {\cf20 // these 2 are unfortunate because they should be allowed - they have higher precedence over the comparisons, but the}\par
1485         {\cf20 // ExpressionDecomposer class uses the left shift operator to capture the left operand of the binary expression...}\par
1486         DOCTEST_FORBIT_EXPRESSION(<<)\par
1487         DOCTEST_FORBIT_EXPRESSION(>>)\par
1488     \};\par
1489 \par
1490 {\cf21 #ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION}\par
1491 \par
1492     DOCTEST_CLANG_SUPPRESS_WARNING_POP\par
1493     DOCTEST_MSVC_SUPPRESS_WARNING_POP\par
1494     DOCTEST_GCC_SUPPRESS_WARNING_POP\par
1495 \par
1496 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION}\par
1497 \par
1498     {\cf17 struct }ExpressionDecomposer\par
1499     \{\par
1500         assertType::Enum m_assert_type;\par
1501 \par
1502         ExpressionDecomposer(assertType::Enum at)\par
1503                 : m_assert_type(at) \{\}\par
1504 \par
1505         {\cf20 // The right operator for capturing expressions is "<=" instead of "<<" (based on the operator precedence table)}\par
1506         {\cf20 // but then there will be warnings from GCC about "-Wparentheses" and since "_Pragma()" is problematic this will stay for now...}\par
1507         {\cf20 // https://github.com/philsquared/Catch/issues/870}\par
1508         {\cf20 // https://github.com/philsquared/Catch/issues/565}\par
1509         {\cf17 template} <{\cf17 typename} L>\par
1510         Expression_lhs<{\cf17 const} DOCTEST_REF_WRAP(L)> operator<<({\cf17 const} DOCTEST_REF_WRAP(L) operand) \{\par
1511             {\cf19 return} Expression_lhs<const DOCTEST_REF_WRAP(L)>(operand, m_assert_type);\par
1512         \}\par
1513     \};\par
1514 \par
1515     {\cf17 struct }DOCTEST_INTERFACE TestCase\par
1516     \{\par
1517         {\cf20 // not used for determining uniqueness}\par
1518         funcType m_test;    {\cf20 // a function pointer to the test case}\par
1519         String m_full_name; {\cf20 // contains the name (only for templated test cases!) + the template type}\par
1520         {\cf17 const} {\cf18 char}* m_name;       {\cf20 // name of the test case}\par
1521         {\cf17 const} {\cf18 char}* m_type;       {\cf20 // for templated test cases - gets appended to the real name}\par
1522         {\cf17 const} {\cf18 char}* m_test_suite; {\cf20 // the test suite in which the test was added}\par
1523         {\cf17 const} {\cf18 char}* m_description;\par
1524         {\cf18 bool}        m_skip;\par
1525         {\cf18 bool}        m_may_fail;\par
1526         {\cf18 bool}        m_should_fail;\par
1527         {\cf18 int}         m_expected_failures;\par
1528         {\cf18 double}      m_timeout;\par
1529 \par
1530         {\cf20 // fields by which uniqueness of test cases shall be determined}\par
1531         {\cf17 const} {\cf18 char}* m_file; {\cf20 // the file in which the test was registered}\par
1532         {\cf18 unsigned}    m_line; {\cf20 // the line where the test was registered}\par
1533         {\cf18 int} m_template_id; {\cf20 // an ID used to distinguish between the different versions of a templated test case}\par
1534 \par
1535         TestCase(funcType test, {\cf17 const} {\cf18 char}* file, {\cf18 unsigned} line, {\cf17 const} TestSuite& test_suite,\par
1536                  {\cf17 const} {\cf18 char}* type = {\cf22 ""}, {\cf18 int} template_id = -1);\par
1537 \par
1538         {\cf20 // for gcc 4.7}\par
1539         DOCTEST_NOINLINE ~TestCase() \{\}\par
1540 \par
1541         TestCase& operator*({\cf17 const} {\cf18 char}* in);\par
1542 \par
1543         {\cf17 template} <{\cf17 typename} T>\par
1544         TestCase& operator*({\cf17 const} T& in) \{\par
1545             in.fill(*{\cf17 this});\par
1546             {\cf19 return} *{\cf17 this};\par
1547         \}\par
1548 \par
1549         TestCase({\cf17 const} TestCase& other) \{ *{\cf17 this} = other; \}\par
1550 \par
1551         TestCase& operator=({\cf17 const} TestCase& other);\par
1552 \par
1553         {\cf18 bool} operator<({\cf17 const} TestCase& other) {\cf17 const};\par
1554     \};\par
1555 \par
1556     {\cf20 // forward declarations of functions used by the macros}\par
1557     DOCTEST_INTERFACE {\cf18 int} regTest({\cf17 const} TestCase& tc);\par
1558     DOCTEST_INTERFACE {\cf18 int} setTestSuite({\cf17 const} TestSuite& ts);\par
1559 \par
1560     {\cf17 namespace }binaryAssertComparison\par
1561     \{\par
1562         {\cf17 enum} Enum\par
1563         \{\par
1564             eq = 0,\par
1565             ne,\par
1566             gt,\par
1567             lt,\par
1568             ge,\par
1569             le\par
1570         \};\par
1571     \} {\cf20 // namespace binaryAssertComparison}\par
1572 \par
1573     {\cf20 // clang-format off}\par
1574     {\cf17 template} <{\cf18 int}, {\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator     \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L),     {\cf17 const} DOCTEST_REF_WRAP(R)    ){\cf17  const }\{ {\cf19 return} {\cf17 false};        \} \};\par
1575     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<0, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} eq(lhs, rhs); \} \};\par
1576     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<1, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} ne(lhs, rhs); \} \};\par
1577     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<2, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} gt(lhs, rhs); \} \};\par
1578     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<3, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} lt(lhs, rhs); \} \};\par
1579     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<4, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} ge(lhs, rhs); \} \};\par
1580     {\cf17 template} <{\cf17 class} L, {\cf17 class} R> {\cf17 struct }RelationalComparator<5, L, R> \{ {\cf18 bool} operator()({\cf17 const} DOCTEST_REF_WRAP(L) lhs, {\cf17 const} DOCTEST_REF_WRAP(R) rhs){\cf17  const }\{ {\cf19 return} le(lhs, rhs); \} \};\par
1581     {\cf20 // clang-format on}\par
1582 \par
1583     {\cf17 struct }DOCTEST_INTERFACE ResultBuilder\par
1584     \{\par
1585         assertType::Enum m_assert_type;\par
1586         {\cf17 const} {\cf18 char}*      m_file;\par
1587         {\cf18 int}              m_line;\par
1588         {\cf17 const} {\cf18 char}*      m_expr;\par
1589         {\cf17 const} {\cf18 char}*      m_exception_type;\par
1590 \par
1591         Result m_result;\par
1592         {\cf18 bool}   m_threw;\par
1593         {\cf18 bool}   m_threw_as;\par
1594         {\cf18 bool}   m_failed;\par
1595         String m_exception;\par
1596 \par
1597         ResultBuilder(assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* expr,\par
1598                       {\cf17 const} {\cf18 char}* exception_type = {\cf22 ""});\par
1599 \par
1600         ~ResultBuilder();\par
1601 \par
1602         {\cf18 void} setResult({\cf17 const} Result& res) \{ m_result = res; \}\par
1603 \par
1604         {\cf17 template} <{\cf18 int} comparison, {\cf17 typename} L, {\cf17 typename} R>\par
1605         DOCTEST_NOINLINE {\cf18 void} binary_assert({\cf17 const} DOCTEST_REF_WRAP(L) lhs,\par
1606                                             {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{\par
1607             m_result.m_passed = RelationalComparator<comparison, L, R>()(lhs, rhs);\par
1608             {\cf19 if}(!m_result.m_passed || getTestsContextState()->success)\par
1609                 m_result.m_decomposition = stringifyBinaryExpr(lhs, {\cf22 ", "}, rhs);\par
1610         \}\par
1611 \par
1612         {\cf17 template} <{\cf17 typename} L>\par
1613         DOCTEST_NOINLINE {\cf18 void} unary_assert({\cf17 const} DOCTEST_REF_WRAP(L) val) \{\par
1614             m_result.m_passed = !!val;\par
1615 \par
1616             {\cf19 if}(m_assert_type & assertType::is_false) \par
1617                 m_result.m_passed = !m_result.m_passed;\par
1618 \par
1619             {\cf19 if}(!m_result.m_passed || getTestsContextState()->success)\par
1620                 m_result.m_decomposition = toString(val);\par
1621         \}\par
1622 \par
1623         {\cf18 void} unexpectedExceptionOccurred();\par
1624 \par
1625         {\cf18 bool} log();\par
1626         {\cf18 void} react() {\cf17 const};\par
1627     \};\par
1628 \par
1629     {\cf17 namespace }assertAction\par
1630     \{\par
1631         {\cf17 enum} Enum\par
1632         \{\par
1633             nothing     = 0,\par
1634             dbgbreak    = 1,\par
1635             shouldthrow = 2\par
1636         \};\par
1637     \} {\cf20 // namespace assertAction}\par
1638 \par
1639     {\cf17 template} <{\cf18 int} comparison, {\cf17 typename} L, {\cf17 typename} R>\par
1640     DOCTEST_NOINLINE {\cf18 int} fast_binary_assert(assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line,\par
1641                                             {\cf17 const} {\cf18 char}* expr, {\cf17 const} DOCTEST_REF_WRAP(L) lhs,\par
1642                                             {\cf17 const} DOCTEST_REF_WRAP(R) rhs) \{\par
1643         ResultBuilder rb(at, file, line, expr);\par
1644 \par
1645         rb.m_result.m_passed = RelationalComparator<comparison, L, R>()(lhs, rhs);\par
1646 \par
1647         {\cf19 if}(!rb.m_result.m_passed || getTestsContextState()->success)\par
1648             rb.m_result.m_decomposition = stringifyBinaryExpr(lhs, {\cf22 ", "}, rhs);\par
1649 \par
1650         {\cf18 int} res = 0;\par
1651 \par
1652         {\cf19 if}(rb.log())\par
1653             res |= assertAction::dbgbreak;\par
1654 \par
1655         {\cf19 if}(rb.m_failed && checkIfShouldThrow(at))\par
1656             res |= assertAction::shouldthrow;\par
1657 \par
1658 {\cf21 #ifdef DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
1659         {\cf20 // #########################################################################################}\par
1660         {\cf20 // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK TO SEE THE FAILING ASSERTION}\par
1661         {\cf20 // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED}\par
1662         {\cf20 // #########################################################################################}\par
1663         {\cf19 if}(res & assertAction::dbgbreak)\par
1664             DOCTEST_BREAK_INTO_DEBUGGER();\par
1665         fastAssertThrowIfFlagSet(res);\par
1666 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
1667 \par
1668         {\cf19 return} res;\par
1669     \}\par
1670 \par
1671     {\cf17 template} <{\cf17 typename} L>\par
1672     DOCTEST_NOINLINE {\cf18 int} fast_unary_assert(assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line,\par
1673                                            {\cf17 const} {\cf18 char}* val_str, {\cf17 const} DOCTEST_REF_WRAP(L) val) \{\par
1674         ResultBuilder rb(at, file, line, val_str);\par
1675 \par
1676         rb.m_result.m_passed = !!val;\par
1677 \par
1678         {\cf19 if}(at & assertType::is_false) \par
1679             rb.m_result.m_passed = !rb.m_result.m_passed;\par
1680 \par
1681         {\cf19 if}(!rb.m_result.m_passed || getTestsContextState()->success)\par
1682             rb.m_result.m_decomposition = toString(val);\par
1683 \par
1684         {\cf18 int} res = 0;\par
1685 \par
1686         {\cf19 if}(rb.log())\par
1687             res |= assertAction::dbgbreak;\par
1688 \par
1689         {\cf19 if}(rb.m_failed && checkIfShouldThrow(at))\par
1690             res |= assertAction::shouldthrow;\par
1691 \par
1692 {\cf21 #ifdef DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
1693         {\cf20 // #########################################################################################}\par
1694         {\cf20 // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK TO SEE THE FAILING ASSERTION}\par
1695         {\cf20 // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED}\par
1696         {\cf20 // #########################################################################################}\par
1697         {\cf19 if}(res & assertAction::dbgbreak)\par
1698             DOCTEST_BREAK_INTO_DEBUGGER();\par
1699         fastAssertThrowIfFlagSet(res);\par
1700 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
1701 \par
1702         {\cf19 return} res;\par
1703     \}\par
1704 \par
1705     {\cf17 struct }DOCTEST_INTERFACE IExceptionTranslator\par
1706     \{\par
1707         {\cf17 virtual} ~IExceptionTranslator() \{\}\par
1708         {\cf17 virtual} {\cf18 bool} translate(String&) {\cf17 const} = 0;\par
1709     \};\par
1710 \par
1711     {\cf17 template} <{\cf17 typename} T>\par
1712     {\cf17 class }ExceptionTranslator : {\cf17 public} IExceptionTranslator \par
1713     \{\par
1714     {\cf17 public}:\par
1715         {\cf17 explicit} ExceptionTranslator(String (*translateFunction)(T))\par
1716                 : m_translateFunction(translateFunction) \{\}\par
1717 \par
1718         {\cf18 bool} translate(String& res){\cf17  const }\{\par
1719 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
1720             {\cf19 try} \{\par
1721                 {\cf19 throw};\par
1722                 {\cf20 // cppcheck-suppress catchExceptionByValue}\par
1723             \} {\cf19 catch}(T ex) \{                    {\cf20 // NOLINT}\par
1724                 res = m_translateFunction(ex); \par
1725                 {\cf19 return} {\cf17 true};\par
1726             \} {\cf19 catch}(...) \{\} \par
1727 {\cf21 #endif                      }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
1728             ((void)res);    {\cf20 // to silence -Wunused-parameter}\par
1729             {\cf19 return} {\cf17 false};\par
1730         \}\par
1731 \par
1732     {\cf17 protected}:\par
1733         String (*m_translateFunction)(T);\par
1734     \};\par
1735 \par
1736     DOCTEST_INTERFACE {\cf18 void} registerExceptionTranslatorImpl(\par
1737             {\cf17 const} IExceptionTranslator* translateFunction);\par
1738 \par
1739     {\cf20 // FIX FOR VISUAL STUDIO VERSIONS PRIOR TO 2015 - they failed to compile the call to operator<< with}\par
1740     {\cf20 // std::ostream passed as a reference noting that there is a use of an undefined type (which there isn't)}\par
1741     DOCTEST_INTERFACE {\cf18 void} writeStringToStream(std::ostream* s, {\cf17 const} String& str);\par
1742 \par
1743     {\cf17 template} <{\cf18 bool} C>\par
1744     {\cf17 struct }StringStreamBase\par
1745     \{\par
1746         {\cf17 template} <{\cf17 typename} T>\par
1747         {\cf17 static} {\cf18 void} convert(std::ostream* s, {\cf17 const} T& in) \{\par
1748             writeStringToStream(s, toString(in));\par
1749         \}\par
1750 \par
1751         {\cf20 // always treat char* as a string in this context - no matter}\par
1752         {\cf20 // if DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING is defined}\par
1753         {\cf17 static} {\cf18 void} convert(std::ostream* s, {\cf17 const} {\cf18 char}* in) \{ writeStringToStream(s, String(in)); \}\par
1754     \};\par
1755 \par
1756     {\cf17 template} <>\par
1757     {\cf17 struct }StringStreamBase<true>\par
1758     \{\par
1759         {\cf17 template} <{\cf17 typename} T>\par
1760         {\cf17 static} {\cf18 void} convert(std::ostream* s, {\cf17 const} T& in) \{\par
1761             *s << in;\par
1762         \}\par
1763     \};\par
1764 \par
1765     {\cf17 template} <{\cf17 typename} T>\par
1766     {\cf17 struct }StringStream : StringStreamBase<has_insertion_operator<T>::value>\par
1767     \{\};\par
1768 \par
1769     {\cf17 template} <{\cf17 typename} T>\par
1770     {\cf18 void} toStream(std::ostream* s, {\cf17 const} T& value) \{\par
1771         StringStream<T>::convert(s, value);\par
1772     \}\par
1773 \par
1774 {\cf21 #ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1775     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 char}* in);\par
1776     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf17 const} {\cf18 char}* in);\par
1777 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
1778     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 bool} in);\par
1779     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 float} in);\par
1780     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 double} in);\par
1781     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 double} {\cf18 long} in);\par
1782 \par
1783     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 char} in);\par
1784     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 char} {\cf18 signed} in);\par
1785     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 char} {\cf18 unsigned} in);\par
1786     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 short} in);\par
1787     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 short} {\cf18 unsigned} in);\par
1788     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} in);\par
1789     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 unsigned} in);\par
1790     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} in);\par
1791     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 unsigned} in);\par
1792 \par
1793 {\cf21 #ifdef DOCTEST_CONFIG_WITH_LONG_LONG}\par
1794     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 long} in);\par
1795     DOCTEST_INTERFACE {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 long} {\cf18 unsigned} in);\par
1796 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
1797 \par
1798     {\cf17 struct }IContextScope\par
1799     \{\par
1800         {\cf17 virtual} ~IContextScope() \{\}\par
1801         {\cf17 virtual} {\cf18 void} build(std::ostream*) = 0;\par
1802     \};\par
1803 \par
1804     DOCTEST_INTERFACE {\cf18 void} addToContexts(IContextScope* ptr);\par
1805     DOCTEST_INTERFACE {\cf18 void} popFromContexts();\par
1806     DOCTEST_INTERFACE {\cf18 void} useContextIfExceptionOccurred(IContextScope* ptr);\par
1807 \par
1808     {\cf20 // cppcheck-suppress copyCtorAndEqOperator}\par
1809     {\cf17 class }ContextBuilder\par
1810     \{\par
1811         {\cf17 friend} {\cf17 class }ContextScope;\par
1812 \par
1813         {\cf17 struct }ICapture\par
1814         \{\par
1815             {\cf17 virtual} ~ICapture() \{\}\par
1816             {\cf17 virtual} {\cf18 void} toStream(std::ostream*) {\cf17 const} = 0;\par
1817         \};\par
1818 \par
1819         {\cf17 template} <{\cf17 typename} T>\par
1820         {\cf17 struct }Capture : ICapture \par
1821         \{\par
1822             {\cf17 const} T* capture;\par
1823 \par
1824             {\cf17 explicit} Capture({\cf17 const} T* in)\par
1825                     : capture(in) \{\}\par
1826             {\cf17 virtual} {\cf18 void} toStream(std::ostream* s){\cf17  const }\{ {\cf20 // override}\par
1827                 detail::toStream(s, *capture);\par
1828             \}\par
1829         \};\par
1830 \par
1831         {\cf17 struct }Chunk\par
1832         \{\par
1833             {\cf18 char} buf[{\cf17 sizeof}(Capture<char>)] DOCTEST_ALIGNMENT(\par
1834                     2 * {\cf17 sizeof}({\cf18 void}*)); {\cf20 // place to construct a Capture<T>}\par
1835         \};\par
1836 \par
1837         {\cf17 struct }Node\par
1838         \{\par
1839             Chunk chunk;\par
1840             Node* next;\par
1841         \};\par
1842 \par
1843         Chunk stackChunks[DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK];\par
1844         {\cf18 int}   numCaptures;\par
1845         Node* head;\par
1846         Node* tail;\par
1847 \par
1848         DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH({\cf22 "-Wcast-align"})\par
1849         void build(std::ostream* s){\cf17  const }\{\par
1850             {\cf18 int} curr = 0;\par
1851             {\cf20 // iterate over small buffer}\par
1852             {\cf19 while}(curr < numCaptures && curr < DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK)\par
1853                 {\cf17 reinterpret_cast<}{\cf17 const }ICapture*{\cf17 >}(stackChunks[curr++].buf)->toStream(s);\par
1854             {\cf20 // iterate over list}\par
1855             Node* curr_elem = head;\par
1856             {\cf19 while}(curr < numCaptures) \{\par
1857                 {\cf17 reinterpret_cast<}{\cf17 const }ICapture*{\cf17 >}(curr_elem->chunk.buf)->toStream(s);\par
1858                 curr_elem = curr_elem->next;\par
1859                 ++curr;\par
1860             \}\par
1861         \}\par
1862         DOCTEST_GCC_SUPPRESS_WARNING_POP\par
1863 \par
1864         {\cf20 // steal the contents of the other - acting as a move constructor...}\par
1865         DOCTEST_NOINLINE ContextBuilder(ContextBuilder& other)\par
1866                 : numCaptures(other.numCaptures)\par
1867                 , head(other.head)\par
1868                 , tail(other.tail) \{\par
1869             other.numCaptures = 0;\par
1870             other.head        = 0;\par
1871             other.tail        = 0;\par
1872             my_memcpy(stackChunks, other.stackChunks,\par
1873                       {\cf18 unsigned}({\cf18 int}({\cf17 sizeof}(Chunk)) * DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK));\par
1874         \}\par
1875 \par
1876         ContextBuilder& operator=({\cf17 const} ContextBuilder&); {\cf20 // NOLINT}\par
1877 \par
1878     {\cf17 public}:\par
1879         {\cf20 // cppcheck-suppress uninitMemberVar}\par
1880         DOCTEST_NOINLINE ContextBuilder() {\cf20 // NOLINT}\par
1881                 : numCaptures(0)\par
1882                 , head(0)\par
1883                 , tail(0) \{\}\par
1884 \par
1885         {\cf17 template} <{\cf17 typename} T>\par
1886         DOCTEST_NOINLINE ContextBuilder& operator<<(T& in) \{\par
1887             Capture<T> temp(&in);\par
1888 \par
1889             {\cf20 // construct either on stack or on heap}\par
1890             {\cf20 // copy the bytes for the whole object - including the vtable because we cant construct}\par
1891             {\cf20 // the object directly in the buffer using placement new - need the <new> header...}\par
1892             {\cf19 if}(numCaptures < DOCTEST_CONFIG_NUM_CAPTURES_ON_STACK) \{\par
1893                 my_memcpy(stackChunks[numCaptures].buf, &temp, {\cf17 sizeof}(Chunk));\par
1894             \} {\cf19 else} \{\par
1895                 Node* curr = {\cf17 new} Node;\par
1896                 curr->next = 0;\par
1897                 {\cf19 if}(tail) \{\par
1898                     tail->next = curr;\par
1899                     tail       = curr;\par
1900                 \} {\cf19 else} \{\par
1901                     head = tail = curr;\par
1902                 \}\par
1903 \par
1904                 my_memcpy(tail->chunk.buf, &temp, {\cf17 sizeof}(Chunk));\par
1905             \}\par
1906             ++numCaptures;\par
1907             {\cf19 return} *{\cf17 this};\par
1908         \}\par
1909 \par
1910         DOCTEST_NOINLINE ~ContextBuilder() \{\par
1911             {\cf20 // free the linked list - the ones on the stack are left as-is}\par
1912             {\cf20 // no destructors are called at all - there is no need}\par
1913             {\cf19 while}(head) \{\par
1914                 Node* next = head->next;\par
1915                 {\cf17 delete} head;\par
1916                 head = next;\par
1917             \}\par
1918         \}\par
1919 \par
1920 {\cf21 #ifdef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
1921         {\cf17 template} <{\cf17 typename} T>\par
1922         ContextBuilder& operator<<({\cf17 const} T&&) \{\par
1923             DOCTEST_STATIC_ASSERT(\par
1924                     deferred_false<T>::value,\par
1925                     Cannot_pass_temporaries_or_rvalues_to_the_streaming_operator_because_it_caches_pointers_to_the_passed_objects_for_lazy_evaluation);\par
1926             {\cf19 return} *{\cf17 this};\par
1927         \}\par
1928 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
1929     \};\par
1930 \par
1931     {\cf17 class }ContextScope : {\cf17 public} IContextScope\par
1932     \{\par
1933         ContextBuilder contextBuilder;\par
1934 \par
1935     {\cf17 public}:\par
1936         DOCTEST_NOINLINE {\cf17 explicit} ContextScope(ContextBuilder& temp)\par
1937                 : contextBuilder(temp) \{\par
1938             addToContexts({\cf17 this});\par
1939         \}\par
1940 \par
1941         DOCTEST_NOINLINE ~ContextScope() \{\par
1942             useContextIfExceptionOccurred({\cf17 this});\par
1943             popFromContexts();\par
1944         \}\par
1945 \par
1946         {\cf18 void} build(std::ostream* s) \{ contextBuilder.build(s); \}\par
1947     \};\par
1948 \par
1949     {\cf17 class }DOCTEST_INTERFACE MessageBuilder\par
1950     \{\par
1951         std::ostream*    m_stream;\par
1952         {\cf17 const} {\cf18 char}*      m_file;\par
1953         {\cf18 int}              m_line;\par
1954         assertType::Enum m_severity;\par
1955 \par
1956     {\cf17 public}:\par
1957         MessageBuilder({\cf17 const} {\cf18 char}* file, {\cf18 int} line, assertType::Enum severity);\par
1958         ~MessageBuilder();\par
1959 \par
1960         {\cf17 template} <{\cf17 typename} T>\par
1961         MessageBuilder& operator<<({\cf17 const} T& in) \{\par
1962             toStream(m_stream, in);\par
1963             {\cf19 return} *{\cf17 this};\par
1964         \}\par
1965 \par
1966         {\cf18 void} log(std::ostream&);\par
1967         {\cf18 bool} log();\par
1968         {\cf18 void} react();\par
1969     \};\par
1970 \} {\cf20 // namespace detail}\par
1971 \par
1972 {\cf17 struct }test_suite\par
1973 \{\par
1974     {\cf17 const} {\cf18 char}* data;\par
1975     test_suite({\cf17 const} {\cf18 char}* in)\par
1976             : data(in) \{\}\par
1977     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_test_suite = data; \}\par
1978     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_test_suite = data; \}\par
1979 \};\par
1980 \par
1981 {\cf17 struct }description\par
1982 \{\par
1983     {\cf17 const} {\cf18 char}* data;\par
1984     description({\cf17 const} {\cf18 char}* in)\par
1985             : data(in) \{\}\par
1986     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_description = data; \}\par
1987     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_description = data; \}\par
1988 \};\par
1989 \par
1990 {\cf17 struct }skip\par
1991 \{\par
1992     {\cf18 bool} data;\par
1993     skip({\cf18 bool} in = {\cf17 true})\par
1994             : data(in) \{\}\par
1995     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_skip = data; \}\par
1996     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_skip = data; \}\par
1997 \};\par
1998 \par
1999 {\cf17 struct }timeout\par
2000 \{\par
2001     {\cf18 double} data;\par
2002     timeout({\cf18 double} in)\par
2003             : data(in) \{\}\par
2004     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_timeout = data; \}\par
2005     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_timeout = data; \}\par
2006 \};\par
2007 \par
2008 {\cf17 struct }may_fail\par
2009 \{\par
2010     {\cf18 bool} data;\par
2011     may_fail({\cf18 bool} in = {\cf17 true})\par
2012             : data(in) \{\}\par
2013     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_may_fail = data; \}\par
2014     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_may_fail = data; \}\par
2015 \};\par
2016 \par
2017 {\cf17 struct }should_fail\par
2018 \{\par
2019     {\cf18 bool} data;\par
2020     should_fail({\cf18 bool} in = {\cf17 true})\par
2021             : data(in) \{\}\par
2022     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_should_fail = data; \}\par
2023     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_should_fail = data; \}\par
2024 \};\par
2025 \par
2026 {\cf17 struct }expected_failures\par
2027 \{\par
2028     {\cf18 int} data;\par
2029     expected_failures({\cf18 int} in)\par
2030             : data(in) \{\}\par
2031     {\cf18 void} fill(detail::TestCase& state){\cf17  const }\{ state.m_expected_failures = data; \}\par
2032     {\cf18 void} fill(detail::TestSuite& state){\cf17  const }\{ state.m_expected_failures = data; \}\par
2033 \};\par
2034 \par
2035 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2036 \par
2037 {\cf21 #ifndef DOCTEST_CONFIG_DISABLE}\par
2038 {\cf17 template} <{\cf17 typename} T>\par
2039 {\cf18 int} registerExceptionTranslator(String (*translateFunction)(T)) \{\par
2040     DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH({\cf22 "-Wexit-time-destructors"})\par
2041     {\cf17 static} detail::ExceptionTranslator<T> exceptionTranslator(translateFunction);\par
2042     DOCTEST_CLANG_SUPPRESS_WARNING_POP\par
2043     detail::registerExceptionTranslatorImpl(&exceptionTranslator);\par
2044     {\cf19 return} 0;\par
2045 \}\par
2046 \par
2047 {\cf21 #else  }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2048 {\cf17 template} <{\cf17 typename} T>\par
2049 {\cf18 int} registerExceptionTranslator(String (*)(T)) \{\par
2050     {\cf19 return} 0;\par
2051 \}\par
2052 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2053 \par
2054 DOCTEST_INTERFACE {\cf18 bool} isRunningInTest();\par
2055 \par
2056 {\cf20 // cppcheck-suppress noCopyConstructor}\par
2057 {\cf17 class }DOCTEST_INTERFACE Context\par
2058 \{\par
2059 {\cf21 #if !defined(DOCTEST_CONFIG_DISABLE)}\par
2060     detail::ContextState* p;\par
2061 \par
2062     {\cf18 void} parseArgs({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf18 bool} withDefaults = {\cf17 false});\par
2063 \par
2064 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2065 \par
2066 {\cf17 public}:\par
2067     {\cf17 explicit} Context({\cf18 int} argc = 0, {\cf17 const} {\cf18 char}* {\cf17 const}* argv = 0);\par
2068 \par
2069     ~Context();\par
2070 \par
2071     {\cf18 void} applyCommandLine({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv);\par
2072 \par
2073     {\cf18 void} addFilter({\cf17 const} {\cf18 char}* filter, {\cf17 const} {\cf18 char}* value);\par
2074     {\cf18 void} clearFilters();\par
2075     {\cf18 void} setOption({\cf17 const} {\cf18 char}* option, {\cf18 int} value);\par
2076     {\cf18 void} setOption({\cf17 const} {\cf18 char}* option, {\cf17 const} {\cf18 char}* value);\par
2077 \par
2078     {\cf18 bool} shouldExit();\par
2079 \par
2080     {\cf18 int} run();\par
2081 \};\par
2082 \par
2083 \} {\cf20 // namespace doctest}\par
2084 \par
2085 {\cf20 // if registering is not disabled}\par
2086 {\cf21 #if !defined(DOCTEST_CONFIG_DISABLE)}\par
2087 \par
2088 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2089 {\cf21 #define DOCTEST_EXPAND_VA_ARGS(...) __VA_ARGS__}\par
2090 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2091 {\cf21 #define DOCTEST_EXPAND_VA_ARGS}\par
2092 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2093 \par
2094 {\cf21 #define DOCTEST_STRIP_PARENS(x) x}\par
2095 {\cf21 #define DOCTEST_HANDLE_BRACED_VA_ARGS(expr) DOCTEST_STRIP_PARENS(DOCTEST_EXPAND_VA_ARGS expr)}\par
2096 \par
2097 {\cf20 // registers the test by initializing a dummy var with a function}\par
2098 {\cf21 #define DOCTEST_REGISTER_FUNCTION(f, decorators)                                                   \\}\par
2099 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) = doctest::detail::regTest(  \\}\par
2100 {\cf21             doctest::detail::TestCase(f, __FILE__, __LINE__,                                       \\}\par
2101 {\cf21                                       doctest_detail_test_suite_ns::getCurrentTestSuite()) *       \\}\par
2102 {\cf21             decorators);                                                                           \\}\par
2103 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS_END()}\par
2104 \par
2105 {\cf21 #define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, decorators)                                     \\}\par
2106 {\cf21     namespace                                                                                      \\}\par
2107 {\cf21     \{                                                                                              \\}\par
2108 {\cf21         struct der : base                                                                          \\}\par
2109 {\cf21         \{                                                                                          \\}\par
2110 {\cf21             void f();                                                                              \\}\par
2111 {\cf21         \};                                                                                         \\}\par
2112 {\cf21         static void func() \{                                                                       \\}\par
2113 {\cf21             der v;                                                                                 \\}\par
2114 {\cf21             v.f();                                                                                 \\}\par
2115 {\cf21         \}                                                                                          \\}\par
2116 {\cf21         DOCTEST_REGISTER_FUNCTION(func, decorators)                                                \\}\par
2117 {\cf21     \}                                                                                              \\}\par
2118 {\cf21     inline DOCTEST_NOINLINE void der::f()}\par
2119 \par
2120 {\cf21 #define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, decorators)                                        \\}\par
2121 {\cf21     static void f();                                                                               \\}\par
2122 {\cf21     DOCTEST_REGISTER_FUNCTION(f, decorators)                                                       \\}\par
2123 {\cf21     static void f()}\par
2124 \par
2125 {\cf20 // for registering tests}\par
2126 {\cf21 #define DOCTEST_TEST_CASE(decorators)                                                              \\}\par
2127 {\cf21     DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), decorators)}\par
2128 \par
2129 {\cf20 // for registering tests with a fixture}\par
2130 {\cf21 #define DOCTEST_TEST_CASE_FIXTURE(c, decorators)                                                   \\}\par
2131 {\cf21     DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(_DOCTEST_ANON_CLASS_), c,                          \\}\par
2132 {\cf21                               DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), decorators)}\par
2133 \par
2134 {\cf20 // for converting types to strings without the <typeinfo> header and demangling}\par
2135 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2136 {\cf21 #define DOCTEST_TYPE_TO_STRING_IMPL(...)                                                           \\}\par
2137 {\cf21     template <>                                                                                    \\}\par
2138 {\cf21     inline const char* type_to_string<__VA_ARGS__>() \{                                             \\}\par
2139 {\cf21         return "<"} #__VA_ARGS__ ">";                                                               \\\par
2140     \}\par
2141 {\cf21 #define DOCTEST_TYPE_TO_STRING(...)                                                                \\}\par
2142 {\cf21     namespace doctest                                                                              \\}\par
2143 {\cf21     \{                                                                                              \\}\par
2144 {\cf21         namespace detail                                                                           \\}\par
2145 {\cf21         \{                                                                                          \\}\par
2146 {\cf21             DOCTEST_TYPE_TO_STRING_IMPL(__VA_ARGS__)                                               \\}\par
2147 {\cf21         \}                                                                                          \\}\par
2148 {\cf21     \}                                                                                              \\}\par
2149 {\cf21     typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2150 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2151 {\cf21 #define DOCTEST_TYPE_TO_STRING_IMPL(x)                                                             \\}\par
2152 {\cf21     template <>                                                                                    \\}\par
2153 {\cf21     inline const char* type_to_string<x>() \{                                                       \\}\par
2154 {\cf21         return "<"} #x ">";                                                                         \\\par
2155     \}\par
2156 {\cf21 #define DOCTEST_TYPE_TO_STRING(x)                                                                  \\}\par
2157 {\cf21     namespace doctest                                                                              \\}\par
2158 {\cf21     \{                                                                                              \\}\par
2159 {\cf21         namespace detail                                                                           \\}\par
2160 {\cf21         \{                                                                                          \\}\par
2161 {\cf21             DOCTEST_TYPE_TO_STRING_IMPL(x)                                                         \\}\par
2162 {\cf21         \}                                                                                          \\}\par
2163 {\cf21     \}                                                                                              \\}\par
2164 {\cf21     typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2165 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2166 \par
2167 {\cf20 // for typed tests}\par
2168 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_IMPL(decorators, T, types, anon)                                \\}\par
2169 {\cf21     template <typename T>                                                                          \\}\par
2170 {\cf21     inline void anon();                                                                            \\}\par
2171 {\cf21     struct DOCTEST_CAT(anon, FUNCTOR)                                                              \\}\par
2172 {\cf21     \{                                                                                              \\}\par
2173 {\cf21         template <int Index, typename Type>                                                        \\}\par
2174 {\cf21         void operator()() \{                                                                        \\}\par
2175 {\cf21             doctest::detail::regTest(                                                              \\}\par
2176 {\cf21                     doctest::detail::TestCase(anon<Type>, __FILE__, __LINE__,                      \\}\par
2177 {\cf21                                               doctest_detail_test_suite_ns::getCurrentTestSuite(), \\}\par
2178 {\cf21                                               doctest::detail::type_to_string<Type>(), Index) *    \\}\par
2179 {\cf21                     decorators);                                                                   \\}\par
2180 {\cf21         \}                                                                                          \\}\par
2181 {\cf21     \};                                                                                             \\}\par
2182 {\cf21     inline int DOCTEST_CAT(anon, REG_FUNC)() \{                                                     \\}\par
2183 {\cf21         DOCTEST_CAT(anon, FUNCTOR) registrar;                                                      \\}\par
2184 {\cf21         doctest::detail::ForEachType<DOCTEST_HANDLE_BRACED_VA_ARGS(types)::Result,                 \\}\par
2185 {\cf21                                      DOCTEST_CAT(anon, FUNCTOR)>                                   \\}\par
2186 {\cf21                 doIt(registrar);                                                                   \\}\par
2187 {\cf21         return 0;                                                                                  \\}\par
2188 {\cf21     \}                                                                                              \\}\par
2189 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY)) = DOCTEST_CAT(anon, REG_FUNC)();          \\}\par
2190 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\}\par
2191 {\cf21     template <typename T>                                                                          \\}\par
2192 {\cf21     inline void anon()}\par
2193 \par
2194 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2195 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE(decorators, T, ...)                                             \\}\par
2196 {\cf21     DOCTEST_TEST_CASE_TEMPLATE_IMPL(decorators, T, (__VA_ARGS__),                                  \\}\par
2197 {\cf21                                     DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))}\par
2198 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2199 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE(decorators, T, types)                                           \\}\par
2200 {\cf21     DOCTEST_TEST_CASE_TEMPLATE_IMPL(decorators, T, types, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))}\par
2201 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2202 \par
2203 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(decorators, T, id, anon)                            \\}\par
2204 {\cf21     template <typename T>                                                                          \\}\par
2205 {\cf21     inline void anon();                                                                            \\}\par
2206 {\cf21     struct DOCTEST_CAT(id, _FUNCTOR)                                                               \\}\par
2207 {\cf21     \{                                                                                              \\}\par
2208 {\cf21         int m_line;                                                                                \\}\par
2209 {\cf21         DOCTEST_CAT(id, _FUNCTOR)                                                                  \\}\par
2210 {\cf21         (int line)                                                                                 \\}\par
2211 {\cf21                 : m_line(line) \{\}                                                                  \\}\par
2212 {\cf21         template <int Index, typename Type>                                                        \\}\par
2213 {\cf21         void operator()() \{                                                                        \\}\par
2214 {\cf21             doctest::detail::regTest(                                                              \\}\par
2215 {\cf21                     doctest::detail::TestCase(anon<Type>, __FILE__, __LINE__,                      \\}\par
2216 {\cf21                                               doctest_detail_test_suite_ns::getCurrentTestSuite(), \\}\par
2217 {\cf21                                               doctest::detail::type_to_string<Type>(),             \\}\par
2218 {\cf21                                               m_line * 1000 + Index) *                             \\}\par
2219 {\cf21                     decorators);                                                                   \\}\par
2220 {\cf21         \}                                                                                          \\}\par
2221 {\cf21     \};                                                                                             \\}\par
2222 {\cf21     template <typename T>                                                                          \\}\par
2223 {\cf21     inline void anon()}\par
2224 \par
2225 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(decorators, T, id)                                       \\}\par
2226 {\cf21     DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(decorators, T, id, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))}\par
2227 \par
2228 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, types, anon)                               \\}\par
2229 {\cf21     static int DOCTEST_CAT(anon, REG_FUNC)() \{                                                     \\}\par
2230 {\cf21         DOCTEST_CAT(id, _FUNCTOR) registrar(__LINE__);                                             \\}\par
2231 {\cf21         doctest::detail::ForEachType<DOCTEST_HANDLE_BRACED_VA_ARGS(types)::Result,                 \\}\par
2232 {\cf21                                      DOCTEST_CAT(id, _FUNCTOR)>                                    \\}\par
2233 {\cf21                 doIt(registrar);                                                                   \\}\par
2234 {\cf21         return 0;                                                                                  \\}\par
2235 {\cf21     \}                                                                                              \\}\par
2236 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY)) = DOCTEST_CAT(anon, REG_FUNC)();          \\}\par
2237 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS_END() typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2238 \par
2239 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2240 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, ...)                                            \\}\par
2241 {\cf21     DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, (__VA_ARGS__),                                 \\}\par
2242 {\cf21                                                 DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))}\par
2243 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2244 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, types)                                          \\}\par
2245 {\cf21     DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, types, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))}\par
2246 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2247 \par
2248 {\cf20 // for subcases}\par
2249 {\cf21 #define DOCTEST_SUBCASE(name)                                                                      \\}\par
2250 {\cf21     if(const doctest::detail::Subcase & DOCTEST_ANONYMOUS(_DOCTEST_ANON_SUBCASE_) DOCTEST_UNUSED = \\}\par
2251 {\cf21                doctest::detail::Subcase(name, __FILE__, __LINE__))}\par
2252 \par
2253 {\cf20 // for grouping tests in test suites by using code blocks}\par
2254 {\cf21 #define DOCTEST_TEST_SUITE_IMPL(decorators, ns_name)                                               \\}\par
2255 {\cf21     namespace ns_name                                                                              \\}\par
2256 {\cf21     \{                                                                                              \\}\par
2257 {\cf21         namespace doctest_detail_test_suite_ns                                                     \\}\par
2258 {\cf21         \{                                                                                          \\}\par
2259 {\cf21             static DOCTEST_NOINLINE doctest::detail::TestSuite& getCurrentTestSuite() \{            \\}\par
2260 {\cf21                 static doctest::detail::TestSuite data;                                            \\}\par
2261 {\cf21                 static bool                       inited = false;                                  \\}\par
2262 {\cf21                 if(!inited) \{                                                                      \\}\par
2263 {\cf21                     data* decorators;                                                              \\}\par
2264 {\cf21                     inited = true;                                                                 \\}\par
2265 {\cf21                 \}                                                                                  \\}\par
2266 {\cf21                 return data;                                                                       \\}\par
2267 {\cf21             \}                                                                                      \\}\par
2268 {\cf21         \}                                                                                          \\}\par
2269 {\cf21     \}                                                                                              \\}\par
2270 {\cf21     namespace ns_name}\par
2271 \par
2272 {\cf21 #define DOCTEST_TEST_SUITE(decorators)                                                             \\}\par
2273 {\cf21     DOCTEST_TEST_SUITE_IMPL(decorators, DOCTEST_ANONYMOUS(_DOCTEST_ANON_SUITE_))}\par
2274 \par
2275 {\cf20 // for starting a testsuite block}\par
2276 {\cf21 #define DOCTEST_TEST_SUITE_BEGIN(decorators)                                                       \\}\par
2277 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) =                            \\}\par
2278 {\cf21             doctest::detail::setTestSuite(doctest::detail::TestSuite() * decorators);              \\}\par
2279 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\}\par
2280 {\cf21     typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2281 \par
2282 {\cf20 // for ending a testsuite block}\par
2283 {\cf21 #define DOCTEST_TEST_SUITE_END                                                                     \\}\par
2284 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) =                            \\}\par
2285 {\cf21             doctest::detail::setTestSuite(doctest::detail::TestSuite() * ""});                      \\\par
2286     DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\\par
2287     typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\par
2288 \par
2289 {\cf20 // for registering exception translators}\par
2290 {\cf21 #define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(translatorName, signature)                      \\}\par
2291 {\cf21     inline doctest::String translatorName(signature);                                              \\}\par
2292 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_)) =                     \\}\par
2293 {\cf21             doctest::registerExceptionTranslator(translatorName);                                  \\}\par
2294 {\cf21     DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\}\par
2295 {\cf21     doctest::String translatorName(signature)}\par
2296 \par
2297 {\cf21 #define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \\}\par
2298 {\cf21     DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_),       \\}\par
2299 {\cf21                                                signature)}\par
2300 \par
2301 {\cf20 // for logging}\par
2302 {\cf21 #define DOCTEST_INFO(x)                                                                            \\}\par
2303 {\cf21     doctest::detail::ContextScope DOCTEST_ANONYMOUS(_DOCTEST_CAPTURE_)(                            \\}\par
2304 {\cf21             doctest::detail::ContextBuilder() << x)}\par
2305 {\cf21 #define DOCTEST_CAPTURE(x) DOCTEST_INFO(#x " := "} << x)\par
2306 \par
2307 {\cf21 #define DOCTEST_ADD_AT_IMPL(type, file, line, mb, x)                                               \\}\par
2308 {\cf21     do \{                                                                                           \\}\par
2309 {\cf21         doctest::detail::MessageBuilder mb(file, line, doctest::detail::assertType::type);         \\}\par
2310 {\cf21         mb << x;                                                                                   \\}\par
2311 {\cf21         if(mb.log())                                                                               \\}\par
2312 {\cf21             DOCTEST_BREAK_INTO_DEBUGGER();                                                         \\}\par
2313 {\cf21         mb.react();                                                                                \\}\par
2314 {\cf21     \} while((void)0, 0)}\par
2315 \par
2316 {\cf20 // clang-format off}\par
2317 {\cf21 #define DOCTEST_ADD_MESSAGE_AT(file, line, x) DOCTEST_ADD_AT_IMPL(is_warn, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), x)}\par
2318 {\cf21 #define DOCTEST_ADD_FAIL_CHECK_AT(file, line, x) DOCTEST_ADD_AT_IMPL(is_check, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), x)}\par
2319 {\cf21 #define DOCTEST_ADD_FAIL_AT(file, line, x) DOCTEST_ADD_AT_IMPL(is_require, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), x)}\par
2320 {\cf20 // clang-format on}\par
2321 \par
2322 {\cf21 #define DOCTEST_MESSAGE(x) DOCTEST_ADD_MESSAGE_AT(__FILE__, __LINE__, x)}\par
2323 {\cf21 #define DOCTEST_FAIL_CHECK(x) DOCTEST_ADD_FAIL_CHECK_AT(__FILE__, __LINE__, x)}\par
2324 {\cf21 #define DOCTEST_FAIL(x) DOCTEST_ADD_FAIL_AT(__FILE__, __LINE__, x)}\par
2325 \par
2326 {\cf21 #if __cplusplus >= 201402L || (DOCTEST_MSVC >= DOCTEST_COMPILER(19, 10, 0))}\par
2327 {\cf17 template} <{\cf17 class} T, T x>\par
2328 {\cf17 constexpr} T to_lvalue = x;\par
2329 {\cf21 #define DOCTEST_TO_LVALUE(...) to_lvalue<decltype(__VA_ARGS__), __VA_ARGS__>}\par
2330 {\cf21 #else}\par
2331 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2332 {\cf21 #define DOCTEST_TO_LVALUE(...) TO_LVALUE_CAN_BE_USED_ONLY_IN_CPP14_MODE_OR_WITH_VS_2017_OR_NEWER}\par
2333 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2334 {\cf21 #define DOCTEST_TO_LVALUE(x) TO_LVALUE_CAN_BE_USED_ONLY_IN_CPP14_MODE_OR_WITH_VS_2017_OR_NEWER}\par
2335 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2336 {\cf21 #endif }{\cf20 // TO_LVALUE hack for logging macros like INFO()}\par
2337 \par
2338 {\cf20 // common code in asserts - for convenience}\par
2339 {\cf21 #define DOCTEST_ASSERT_LOG_AND_REACT(rb)                                                           \\}\par
2340 {\cf21     if(rb.log())                                                                                   \\}\par
2341 {\cf21         DOCTEST_BREAK_INTO_DEBUGGER();                                                             \\}\par
2342 {\cf21     rb.react()}\par
2343 \par
2344 {\cf21 #ifdef DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS}\par
2345 {\cf21 #define DOCTEST_WRAP_IN_TRY(x) x;}\par
2346 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS}\par
2347 {\cf21 #define DOCTEST_WRAP_IN_TRY(x)                                                                     \\}\par
2348 {\cf21     try \{                                                                                          \\}\par
2349 {\cf21         x;                                                                                         \\}\par
2350 {\cf21     \} catch(...) \{ _DOCTEST_RB.unexpectedExceptionOccurred(); \}}\par
2351 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS}\par
2352 \par
2353 {\cf21 #define DOCTEST_ASSERT_IMPLEMENT_2(expr, assert_type)                                              \\}\par
2354 {\cf21     DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH("-Woverloaded-shift-op-parentheses"})                  \\\par
2355     doctest::detail::ResultBuilder _DOCTEST_RB(                                                    \\\par
2356             doctest::detail::assertType::assert_type, __FILE__, __LINE__,                          \\\par
2357             DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)));                                   \\\par
2358     DOCTEST_WRAP_IN_TRY(_DOCTEST_RB.setResult(                                                     \\\par
2359             doctest::detail::ExpressionDecomposer(doctest::detail::assertType::assert_type)        \\\par
2360             << DOCTEST_HANDLE_BRACED_VA_ARGS(expr)))                                               \\\par
2361     DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB)                                                      \\\par
2362     DOCTEST_CLANG_SUPPRESS_WARNING_POP\par
2363 \par
2364 {\cf21 #define DOCTEST_ASSERT_IMPLEMENT_1(expr, assert_type)                                              \\}\par
2365 {\cf21     do \{                                                                                           \\}\par
2366 {\cf21         DOCTEST_ASSERT_IMPLEMENT_2(expr, assert_type);                                             \\}\par
2367 {\cf21     \} while((void)0, 0)}\par
2368 \par
2369 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2370 {\cf21 #define DOCTEST_WARN(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_WARN)}\par
2371 {\cf21 #define DOCTEST_CHECK(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_CHECK)}\par
2372 {\cf21 #define DOCTEST_REQUIRE(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_REQUIRE)}\par
2373 {\cf21 #define DOCTEST_WARN_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_WARN_FALSE)}\par
2374 {\cf21 #define DOCTEST_CHECK_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_CHECK_FALSE)}\par
2375 {\cf21 #define DOCTEST_REQUIRE_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1((__VA_ARGS__), DT_REQUIRE_FALSE)}\par
2376 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2377 {\cf21 #define DOCTEST_WARN(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_WARN)}\par
2378 {\cf21 #define DOCTEST_CHECK(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_CHECK)}\par
2379 {\cf21 #define DOCTEST_REQUIRE(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_REQUIRE)}\par
2380 {\cf21 #define DOCTEST_WARN_FALSE(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_WARN_FALSE)}\par
2381 {\cf21 #define DOCTEST_CHECK_FALSE(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_CHECK_FALSE)}\par
2382 {\cf21 #define DOCTEST_REQUIRE_FALSE(expr) DOCTEST_ASSERT_IMPLEMENT_1(expr, DT_REQUIRE_FALSE)}\par
2383 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2384 \par
2385 {\cf20 // clang-format off}\par
2386 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2387 {\cf21 #define DOCTEST_WARN_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_WARN); \} while((void)0, 0)}\par
2388 {\cf21 #define DOCTEST_CHECK_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_CHECK); \} while((void)0, 0)}\par
2389 {\cf21 #define DOCTEST_REQUIRE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_REQUIRE); \} while((void)0, 0)}\par
2390 {\cf21 #define DOCTEST_WARN_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_WARN_FALSE); \} while((void)0, 0)}\par
2391 {\cf21 #define DOCTEST_CHECK_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_CHECK_FALSE); \} while((void)0, 0)}\par
2392 {\cf21 #define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2((cond), DT_REQUIRE_FALSE); \} while((void)0, 0)}\par
2393 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2394 {\cf21 #define DOCTEST_WARN_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_WARN); \} while((void)0, 0)}\par
2395 {\cf21 #define DOCTEST_CHECK_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_CHECK); \} while((void)0, 0)}\par
2396 {\cf21 #define DOCTEST_REQUIRE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_REQUIRE); \} while((void)0, 0)}\par
2397 {\cf21 #define DOCTEST_WARN_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_WARN_FALSE); \} while((void)0, 0)}\par
2398 {\cf21 #define DOCTEST_CHECK_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_CHECK_FALSE); \} while((void)0, 0)}\par
2399 {\cf21 #define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, msg) do \{ DOCTEST_INFO(msg); DOCTEST_ASSERT_IMPLEMENT_2(cond, DT_REQUIRE_FALSE); \} while((void)0, 0)}\par
2400 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2401 {\cf20 // clang-format on}\par
2402 \par
2403 {\cf21 #define DOCTEST_ASSERT_THROWS(expr, assert_type)                                                   \\}\par
2404 {\cf21     do \{                                                                                           \\}\par
2405 {\cf21         if(!doctest::detail::getTestsContextState()->no_throw) \{                                   \\}\par
2406 {\cf21             doctest::detail::ResultBuilder _DOCTEST_RB(doctest::detail::assertType::assert_type,   \\}\par
2407 {\cf21                                                        __FILE__, __LINE__, #expr);                 \\}\par
2408 {\cf21             try \{                                                                                  \\}\par
2409 {\cf21                 expr;                                                                              \\}\par
2410 {\cf21             \} catch(...) \{ _DOCTEST_RB.m_threw = true; \}                                           \\}\par
2411 {\cf21             DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                             \\}\par
2412 {\cf21         \}                                                                                          \\}\par
2413 {\cf21     \} while((void)0, 0)}\par
2414 \par
2415 {\cf21 #define DOCTEST_ASSERT_THROWS_AS(expr, as, assert_type)                                            \\}\par
2416 {\cf21     do \{                                                                                           \\}\par
2417 {\cf21         if(!doctest::detail::getTestsContextState()->no_throw) \{                                   \\}\par
2418 {\cf21             doctest::detail::ResultBuilder _DOCTEST_RB(                                            \\}\par
2419 {\cf21                     doctest::detail::assertType::assert_type, __FILE__, __LINE__, #expr,           \\}\par
2420 {\cf21                     DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(as)));                             \\}\par
2421 {\cf21             try \{                                                                                  \\}\par
2422 {\cf21                 expr;                                                                              \\}\par
2423 {\cf21             \} catch(const DOCTEST_HANDLE_BRACED_VA_ARGS(as)&) \{                                    \\}\par
2424 {\cf21                 _DOCTEST_RB.m_threw    = true;                                                     \\}\par
2425 {\cf21                 _DOCTEST_RB.m_threw_as = true;                                                     \\}\par
2426 {\cf21             \} catch(...) \{ _DOCTEST_RB.unexpectedExceptionOccurred(); \}                            \\}\par
2427 {\cf21             DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                             \\}\par
2428 {\cf21         \}                                                                                          \\}\par
2429 {\cf21     \} while((void)0, 0)}\par
2430 \par
2431 {\cf21 #define DOCTEST_ASSERT_NOTHROW(expr, assert_type)                                                  \\}\par
2432 {\cf21     do \{                                                                                           \\}\par
2433 {\cf21         if(!doctest::detail::getTestsContextState()->no_throw) \{                                   \\}\par
2434 {\cf21             doctest::detail::ResultBuilder _DOCTEST_RB(doctest::detail::assertType::assert_type,   \\}\par
2435 {\cf21                                                        __FILE__, __LINE__, #expr);                 \\}\par
2436 {\cf21             try \{                                                                                  \\}\par
2437 {\cf21                 expr;                                                                              \\}\par
2438 {\cf21             \} catch(...) \{ _DOCTEST_RB.unexpectedExceptionOccurred(); \}                            \\}\par
2439 {\cf21             DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                             \\}\par
2440 {\cf21         \}                                                                                          \\}\par
2441 {\cf21     \} while((void)0, 0)}\par
2442 \par
2443 {\cf21 #define DOCTEST_WARN_THROWS(expr) DOCTEST_ASSERT_THROWS(expr, DT_WARN_THROWS)}\par
2444 {\cf21 #define DOCTEST_CHECK_THROWS(expr) DOCTEST_ASSERT_THROWS(expr, DT_CHECK_THROWS)}\par
2445 {\cf21 #define DOCTEST_REQUIRE_THROWS(expr) DOCTEST_ASSERT_THROWS(expr, DT_REQUIRE_THROWS)}\par
2446 \par
2447 {\cf20 // clang-format off}\par
2448 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2449 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, (__VA_ARGS__), DT_WARN_THROWS_AS)}\par
2450 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, (__VA_ARGS__), DT_CHECK_THROWS_AS)}\par
2451 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, (__VA_ARGS__), DT_REQUIRE_THROWS_AS)}\par
2452 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2453 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ex) DOCTEST_ASSERT_THROWS_AS(expr, ex, DT_WARN_THROWS_AS)}\par
2454 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ex) DOCTEST_ASSERT_THROWS_AS(expr, ex, DT_CHECK_THROWS_AS)}\par
2455 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ex) DOCTEST_ASSERT_THROWS_AS(expr, ex, DT_REQUIRE_THROWS_AS)}\par
2456 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2457 {\cf20 // clang-format on}\par
2458 \par
2459 {\cf21 #define DOCTEST_WARN_NOTHROW(expr) DOCTEST_ASSERT_NOTHROW(expr, DT_WARN_NOTHROW)}\par
2460 {\cf21 #define DOCTEST_CHECK_NOTHROW(expr) DOCTEST_ASSERT_NOTHROW(expr, DT_CHECK_NOTHROW)}\par
2461 {\cf21 #define DOCTEST_REQUIRE_NOTHROW(expr) DOCTEST_ASSERT_NOTHROW(expr, DT_REQUIRE_NOTHROW)}\par
2462 \par
2463 {\cf20 // clang-format off}\par
2464 {\cf21 #define DOCTEST_WARN_THROWS_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_WARN_THROWS(expr); \} while((void)0, 0)}\par
2465 {\cf21 #define DOCTEST_CHECK_THROWS_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_CHECK_THROWS(expr); \} while((void)0, 0)}\par
2466 {\cf21 #define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_REQUIRE_THROWS(expr); \} while((void)0, 0)}\par
2467 {\cf21 #define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, msg) do \{ DOCTEST_INFO(msg); DOCTEST_WARN_THROWS_AS(expr, ex); \} while((void)0, 0)}\par
2468 {\cf21 #define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, msg) do \{ DOCTEST_INFO(msg); DOCTEST_CHECK_THROWS_AS(expr, ex); \} while((void)0, 0)}\par
2469 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, msg) do \{ DOCTEST_INFO(msg); DOCTEST_REQUIRE_THROWS_AS(expr, ex); \} while((void)0, 0)}\par
2470 {\cf21 #define DOCTEST_WARN_NOTHROW_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_WARN_NOTHROW(expr); \} while((void)0, 0)}\par
2471 {\cf21 #define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_CHECK_NOTHROW(expr); \} while((void)0, 0)}\par
2472 {\cf21 #define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, msg) do \{ DOCTEST_INFO(msg); DOCTEST_REQUIRE_NOTHROW(expr); \} while((void)0, 0)}\par
2473 {\cf20 // clang-format on}\par
2474 \par
2475 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2476 {\cf21 #define DOCTEST_BINARY_ASSERT(assert_type, expr, comp)                                             \\}\par
2477 {\cf21     do \{                                                                                           \\}\par
2478 {\cf21         doctest::detail::ResultBuilder _DOCTEST_RB(                                                \\}\par
2479 {\cf21                 doctest::detail::assertType::assert_type, __FILE__, __LINE__,                      \\}\par
2480 {\cf21                 DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)));                               \\}\par
2481 {\cf21         DOCTEST_WRAP_IN_TRY(                                                                       \\}\par
2482 {\cf21                 _DOCTEST_RB.binary_assert<doctest::detail::binaryAssertComparison::comp>(          \\}\par
2483 {\cf21                         DOCTEST_HANDLE_BRACED_VA_ARGS(expr)))                                      \\}\par
2484 {\cf21         DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\}\par
2485 {\cf21     \} while((void)0, 0)}\par
2486 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2487 {\cf21 #define DOCTEST_BINARY_ASSERT(assert_type, lhs, rhs, comp)                                         \\}\par
2488 {\cf21     do \{                                                                                           \\}\par
2489 {\cf21         doctest::detail::ResultBuilder _DOCTEST_RB(doctest::detail::assertType::assert_type,       \\}\par
2490 {\cf21                                                    __FILE__, __LINE__, #lhs ", "} #rhs);            \\\par
2491         DOCTEST_WRAP_IN_TRY(                                                                       \\\par
2492                 _DOCTEST_RB.binary_assert<doctest::detail::binaryAssertComparison::comp>(lhs,      \\\par
2493                                                                                          rhs))     \\\par
2494         DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\\par
2495     \} while((void)0, 0)\par
2496 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2497 \par
2498 {\cf21 #define DOCTEST_UNARY_ASSERT(assert_type, expr)                                                    \\}\par
2499 {\cf21     do \{                                                                                           \\}\par
2500 {\cf21         doctest::detail::ResultBuilder _DOCTEST_RB(                                                \\}\par
2501 {\cf21                 doctest::detail::assertType::assert_type, __FILE__, __LINE__,                      \\}\par
2502 {\cf21                 DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)));                               \\}\par
2503 {\cf21         DOCTEST_WRAP_IN_TRY(_DOCTEST_RB.unary_assert(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)))         \\}\par
2504 {\cf21         DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\}\par
2505 {\cf21     \} while((void)0, 0)}\par
2506 \par
2507 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2508 {\cf21 #define DOCTEST_WARN_EQ(...) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, (__VA_ARGS__), eq)}\par
2509 {\cf21 #define DOCTEST_CHECK_EQ(...) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, (__VA_ARGS__), eq)}\par
2510 {\cf21 #define DOCTEST_REQUIRE_EQ(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, (__VA_ARGS__), eq)}\par
2511 {\cf21 #define DOCTEST_WARN_NE(...) DOCTEST_BINARY_ASSERT(DT_WARN_NE, (__VA_ARGS__), ne)}\par
2512 {\cf21 #define DOCTEST_CHECK_NE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, (__VA_ARGS__), ne)}\par
2513 {\cf21 #define DOCTEST_REQUIRE_NE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, (__VA_ARGS__), ne)}\par
2514 {\cf21 #define DOCTEST_WARN_GT(...) DOCTEST_BINARY_ASSERT(DT_WARN_GT, (__VA_ARGS__), gt)}\par
2515 {\cf21 #define DOCTEST_CHECK_GT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, (__VA_ARGS__), gt)}\par
2516 {\cf21 #define DOCTEST_REQUIRE_GT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, (__VA_ARGS__), gt)}\par
2517 {\cf21 #define DOCTEST_WARN_LT(...) DOCTEST_BINARY_ASSERT(DT_WARN_LT, (__VA_ARGS__), lt)}\par
2518 {\cf21 #define DOCTEST_CHECK_LT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, (__VA_ARGS__), lt)}\par
2519 {\cf21 #define DOCTEST_REQUIRE_LT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, (__VA_ARGS__), lt)}\par
2520 {\cf21 #define DOCTEST_WARN_GE(...) DOCTEST_BINARY_ASSERT(DT_WARN_GE, (__VA_ARGS__), ge)}\par
2521 {\cf21 #define DOCTEST_CHECK_GE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, (__VA_ARGS__), ge)}\par
2522 {\cf21 #define DOCTEST_REQUIRE_GE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, (__VA_ARGS__), ge)}\par
2523 {\cf21 #define DOCTEST_WARN_LE(...) DOCTEST_BINARY_ASSERT(DT_WARN_LE, (__VA_ARGS__), le)}\par
2524 {\cf21 #define DOCTEST_CHECK_LE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, (__VA_ARGS__), le)}\par
2525 {\cf21 #define DOCTEST_REQUIRE_LE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, (__VA_ARGS__), le)}\par
2526 \par
2527 {\cf21 #define DOCTEST_WARN_UNARY(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, (__VA_ARGS__))}\par
2528 {\cf21 #define DOCTEST_CHECK_UNARY(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, (__VA_ARGS__))}\par
2529 {\cf21 #define DOCTEST_REQUIRE_UNARY(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, (__VA_ARGS__))}\par
2530 {\cf21 #define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, (__VA_ARGS__))}\par
2531 {\cf21 #define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, (__VA_ARGS__))}\par
2532 {\cf21 #define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, (__VA_ARGS__))}\par
2533 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2534 {\cf21 #define DOCTEST_WARN_EQ(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, lhs, rhs, eq)}\par
2535 {\cf21 #define DOCTEST_CHECK_EQ(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, lhs, rhs, eq)}\par
2536 {\cf21 #define DOCTEST_REQUIRE_EQ(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, lhs, rhs, eq)}\par
2537 {\cf21 #define DOCTEST_WARN_NE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_NE, lhs, rhs, ne)}\par
2538 {\cf21 #define DOCTEST_CHECK_NE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, lhs, rhs, ne)}\par
2539 {\cf21 #define DOCTEST_REQUIRE_NE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, lhs, rhs, ne)}\par
2540 {\cf21 #define DOCTEST_WARN_GT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_GT, lhs, rhs, gt)}\par
2541 {\cf21 #define DOCTEST_CHECK_GT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, lhs, rhs, gt)}\par
2542 {\cf21 #define DOCTEST_REQUIRE_GT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, lhs, rhs, gt)}\par
2543 {\cf21 #define DOCTEST_WARN_LT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_LT, lhs, rhs, lt)}\par
2544 {\cf21 #define DOCTEST_CHECK_LT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, lhs, rhs, lt)}\par
2545 {\cf21 #define DOCTEST_REQUIRE_LT(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, lhs, rhs, lt)}\par
2546 {\cf21 #define DOCTEST_WARN_GE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_GE, lhs, rhs, ge)}\par
2547 {\cf21 #define DOCTEST_CHECK_GE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, lhs, rhs, ge)}\par
2548 {\cf21 #define DOCTEST_REQUIRE_GE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, lhs, rhs, ge)}\par
2549 {\cf21 #define DOCTEST_WARN_LE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_WARN_LE, lhs, rhs, le)}\par
2550 {\cf21 #define DOCTEST_CHECK_LE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, lhs, rhs, le)}\par
2551 {\cf21 #define DOCTEST_REQUIRE_LE(lhs, rhs) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, lhs, rhs, le)}\par
2552 \par
2553 {\cf21 #define DOCTEST_WARN_UNARY(v) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, v)}\par
2554 {\cf21 #define DOCTEST_CHECK_UNARY(v) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, v)}\par
2555 {\cf21 #define DOCTEST_REQUIRE_UNARY(v) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, v)}\par
2556 {\cf21 #define DOCTEST_WARN_UNARY_FALSE(v) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, v)}\par
2557 {\cf21 #define DOCTEST_CHECK_UNARY_FALSE(v) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, v)}\par
2558 {\cf21 #define DOCTEST_REQUIRE_UNARY_FALSE(v) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, v)}\par
2559 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2560 \par
2561 {\cf21 #ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
2562 \par
2563 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2564 {\cf21 #define DOCTEST_FAST_BINARY_ASSERT(assert_type, expr, comparison)                                  \\}\par
2565 {\cf21     do \{                                                                                           \\}\par
2566 {\cf21         int _DOCTEST_FAST_RES = doctest::detail::fast_binary_assert<                               \\}\par
2567 {\cf21                 doctest::detail::binaryAssertComparison::comparison>(                              \\}\par
2568 {\cf21                 doctest::detail::assertType::assert_type, __FILE__, __LINE__,                      \\}\par
2569 {\cf21                 DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)),                                \\}\par
2570 {\cf21                 DOCTEST_HANDLE_BRACED_VA_ARGS(expr));                                              \\}\par
2571 {\cf21         if(_DOCTEST_FAST_RES & doctest::detail::assertAction::dbgbreak)                            \\}\par
2572 {\cf21             DOCTEST_BREAK_INTO_DEBUGGER();                                                         \\}\par
2573 {\cf21         doctest::detail::fastAssertThrowIfFlagSet(_DOCTEST_FAST_RES);                              \\}\par
2574 {\cf21     \} while((void)0, 0)}\par
2575 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2576 {\cf21 #define DOCTEST_FAST_BINARY_ASSERT(assert_type, lhs, rhs, comparison)                              \\}\par
2577 {\cf21     do \{                                                                                           \\}\par
2578 {\cf21         int _DOCTEST_FAST_RES = doctest::detail::fast_binary_assert<                               \\}\par
2579 {\cf21                 doctest::detail::binaryAssertComparison::comparison>(                              \\}\par
2580 {\cf21                 doctest::detail::assertType::assert_type, __FILE__, __LINE__, #lhs ", "} #rhs, lhs, \\\par
2581                 rhs);                                                                              \\\par
2582         if(_DOCTEST_FAST_RES & doctest::detail::assertAction::dbgbreak)                            \\\par
2583             DOCTEST_BREAK_INTO_DEBUGGER();                                                         \\\par
2584         doctest::detail::fastAssertThrowIfFlagSet(_DOCTEST_FAST_RES);                              \\\par
2585     \} while((void)0, 0)\par
2586 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2587 \par
2588 {\cf21 #define DOCTEST_FAST_UNARY_ASSERT(assert_type, expr)                                               \\}\par
2589 {\cf21     do \{                                                                                           \\}\par
2590 {\cf21         int _DOCTEST_FAST_RES = doctest::detail::fast_unary_assert(                                \\}\par
2591 {\cf21                 doctest::detail::assertType::assert_type, __FILE__, __LINE__,                      \\}\par
2592 {\cf21                 DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)),                                \\}\par
2593 {\cf21                 DOCTEST_HANDLE_BRACED_VA_ARGS(expr));                                              \\}\par
2594 {\cf21         if(_DOCTEST_FAST_RES & doctest::detail::assertAction::dbgbreak)                            \\}\par
2595 {\cf21             DOCTEST_BREAK_INTO_DEBUGGER();                                                         \\}\par
2596 {\cf21         doctest::detail::fastAssertThrowIfFlagSet(_DOCTEST_FAST_RES);                              \\}\par
2597 {\cf21     \} while((void)0, 0)}\par
2598 \par
2599 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
2600 \par
2601 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2602 {\cf21 #define DOCTEST_FAST_BINARY_ASSERT(assert_type, expr, comparison)                                  \\}\par
2603 {\cf21     doctest::detail::fast_binary_assert<doctest::detail::binaryAssertComparison::comparison>(      \\}\par
2604 {\cf21             doctest::detail::assertType::assert_type, __FILE__, __LINE__,                          \\}\par
2605 {\cf21             DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)),                                    \\}\par
2606 {\cf21             DOCTEST_HANDLE_BRACED_VA_ARGS(expr))}\par
2607 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2608 {\cf21 #define DOCTEST_FAST_BINARY_ASSERT(assert_type, lhs, rhs, comparison)                              \\}\par
2609 {\cf21     doctest::detail::fast_binary_assert<doctest::detail::binaryAssertComparison::comparison>(      \\}\par
2610 {\cf21             doctest::detail::assertType::assert_type, __FILE__, __LINE__, #lhs ", "} #rhs, lhs,     \\\par
2611             rhs)\par
2612 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2613 \par
2614 {\cf21 #define DOCTEST_FAST_UNARY_ASSERT(assert_type, expr)                                               \\}\par
2615 {\cf21     doctest::detail::fast_unary_assert(doctest::detail::assertType::assert_type, __FILE__,         \\}\par
2616 {\cf21                                        __LINE__,                                                   \\}\par
2617 {\cf21                                        DOCTEST_TOSTR(DOCTEST_HANDLE_BRACED_VA_ARGS(expr)),         \\}\par
2618 {\cf21                                        DOCTEST_HANDLE_BRACED_VA_ARGS(expr))}\par
2619 \par
2620 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_SUPER_FAST_ASSERTS}\par
2621 \par
2622 {\cf20 // clang-format off}\par
2623 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2624 {\cf21 #define DOCTEST_FAST_WARN_EQ(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_EQ, (__VA_ARGS__), eq)}\par
2625 {\cf21 #define DOCTEST_FAST_CHECK_EQ(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_EQ, (__VA_ARGS__), eq)}\par
2626 {\cf21 #define DOCTEST_FAST_REQUIRE_EQ(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_EQ, (__VA_ARGS__), eq)}\par
2627 {\cf21 #define DOCTEST_FAST_WARN_NE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_NE, (__VA_ARGS__), ne)}\par
2628 {\cf21 #define DOCTEST_FAST_CHECK_NE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_NE, (__VA_ARGS__), ne)}\par
2629 {\cf21 #define DOCTEST_FAST_REQUIRE_NE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_NE, (__VA_ARGS__), ne)}\par
2630 {\cf21 #define DOCTEST_FAST_WARN_GT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_GT, (__VA_ARGS__), gt)}\par
2631 {\cf21 #define DOCTEST_FAST_CHECK_GT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_GT, (__VA_ARGS__), gt)}\par
2632 {\cf21 #define DOCTEST_FAST_REQUIRE_GT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_GT, (__VA_ARGS__), gt)}\par
2633 {\cf21 #define DOCTEST_FAST_WARN_LT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_LT, (__VA_ARGS__), lt)}\par
2634 {\cf21 #define DOCTEST_FAST_CHECK_LT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_LT, (__VA_ARGS__), lt)}\par
2635 {\cf21 #define DOCTEST_FAST_REQUIRE_LT(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_LT, (__VA_ARGS__), lt)}\par
2636 {\cf21 #define DOCTEST_FAST_WARN_GE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_GE, (__VA_ARGS__), ge)}\par
2637 {\cf21 #define DOCTEST_FAST_CHECK_GE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_GE, (__VA_ARGS__), ge)}\par
2638 {\cf21 #define DOCTEST_FAST_REQUIRE_GE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_GE, (__VA_ARGS__), ge)}\par
2639 {\cf21 #define DOCTEST_FAST_WARN_LE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_LE, (__VA_ARGS__), le)}\par
2640 {\cf21 #define DOCTEST_FAST_CHECK_LE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_LE, (__VA_ARGS__), le)}\par
2641 {\cf21 #define DOCTEST_FAST_REQUIRE_LE(...) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_LE, (__VA_ARGS__), le)}\par
2642 \par
2643 {\cf21 #define DOCTEST_FAST_WARN_UNARY(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_WARN_UNARY, (__VA_ARGS__))}\par
2644 {\cf21 #define DOCTEST_FAST_CHECK_UNARY(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_CHECK_UNARY, (__VA_ARGS__))}\par
2645 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_REQUIRE_UNARY, (__VA_ARGS__))}\par
2646 {\cf21 #define DOCTEST_FAST_WARN_UNARY_FALSE(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_WARN_UNARY_FALSE, (__VA_ARGS__))}\par
2647 {\cf21 #define DOCTEST_FAST_CHECK_UNARY_FALSE(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_CHECK_UNARY_FALSE, (__VA_ARGS__))}\par
2648 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY_FALSE(...) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_REQUIRE_UNARY_FALSE, (__VA_ARGS__))}\par
2649 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2650 {\cf21 #define DOCTEST_FAST_WARN_EQ(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_EQ, l, r, eq)}\par
2651 {\cf21 #define DOCTEST_FAST_CHECK_EQ(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_EQ, l, r, eq)}\par
2652 {\cf21 #define DOCTEST_FAST_REQUIRE_EQ(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_EQ, l, r, eq)}\par
2653 {\cf21 #define DOCTEST_FAST_WARN_NE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_NE, l, r, ne)}\par
2654 {\cf21 #define DOCTEST_FAST_CHECK_NE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_NE, l, r, ne)}\par
2655 {\cf21 #define DOCTEST_FAST_REQUIRE_NE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_NE, l, r, ne)}\par
2656 {\cf21 #define DOCTEST_FAST_WARN_GT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_GT, l, r, gt)}\par
2657 {\cf21 #define DOCTEST_FAST_CHECK_GT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_GT, l, r, gt)}\par
2658 {\cf21 #define DOCTEST_FAST_REQUIRE_GT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_GT, l, r, gt)}\par
2659 {\cf21 #define DOCTEST_FAST_WARN_LT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_LT, l, r, lt)}\par
2660 {\cf21 #define DOCTEST_FAST_CHECK_LT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_LT, l, r, lt)}\par
2661 {\cf21 #define DOCTEST_FAST_REQUIRE_LT(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_LT, l, r, lt)}\par
2662 {\cf21 #define DOCTEST_FAST_WARN_GE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_GE, l, r, ge)}\par
2663 {\cf21 #define DOCTEST_FAST_CHECK_GE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_GE, l, r, ge)}\par
2664 {\cf21 #define DOCTEST_FAST_REQUIRE_GE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_GE, l, r, ge)}\par
2665 {\cf21 #define DOCTEST_FAST_WARN_LE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_WARN_LE, l, r, le)}\par
2666 {\cf21 #define DOCTEST_FAST_CHECK_LE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_CHECK_LE, l, r, le)}\par
2667 {\cf21 #define DOCTEST_FAST_REQUIRE_LE(l, r) DOCTEST_FAST_BINARY_ASSERT(DT_FAST_REQUIRE_LE, l, r, le)}\par
2668 \par
2669 {\cf21 #define DOCTEST_FAST_WARN_UNARY(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_WARN_UNARY, v)}\par
2670 {\cf21 #define DOCTEST_FAST_CHECK_UNARY(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_CHECK_UNARY, v)}\par
2671 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_REQUIRE_UNARY, v)}\par
2672 {\cf21 #define DOCTEST_FAST_WARN_UNARY_FALSE(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_WARN_UNARY_FALSE, v)}\par
2673 {\cf21 #define DOCTEST_FAST_CHECK_UNARY_FALSE(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_CHECK_UNARY_FALSE, v)}\par
2674 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY_FALSE(v) DOCTEST_FAST_UNARY_ASSERT(DT_FAST_REQUIRE_UNARY_FALSE, v)}\par
2675 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2676 {\cf20 // clang-format on}\par
2677 \par
2678 {\cf21 #ifdef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
2679 \par
2680 {\cf21 #undef DOCTEST_WARN_THROWS}\par
2681 {\cf21 #undef DOCTEST_CHECK_THROWS}\par
2682 {\cf21 #undef DOCTEST_REQUIRE_THROWS}\par
2683 {\cf21 #undef DOCTEST_WARN_THROWS_AS}\par
2684 {\cf21 #undef DOCTEST_CHECK_THROWS_AS}\par
2685 {\cf21 #undef DOCTEST_REQUIRE_THROWS_AS}\par
2686 {\cf21 #undef DOCTEST_WARN_NOTHROW}\par
2687 {\cf21 #undef DOCTEST_CHECK_NOTHROW}\par
2688 {\cf21 #undef DOCTEST_REQUIRE_NOTHROW}\par
2689 \par
2690 {\cf21 #undef DOCTEST_WARN_THROWS_MESSAGE}\par
2691 {\cf21 #undef DOCTEST_CHECK_THROWS_MESSAGE}\par
2692 {\cf21 #undef DOCTEST_REQUIRE_THROWS_MESSAGE}\par
2693 {\cf21 #undef DOCTEST_WARN_THROWS_AS_MESSAGE}\par
2694 {\cf21 #undef DOCTEST_CHECK_THROWS_AS_MESSAGE}\par
2695 {\cf21 #undef DOCTEST_REQUIRE_THROWS_AS_MESSAGE}\par
2696 {\cf21 #undef DOCTEST_WARN_NOTHROW_MESSAGE}\par
2697 {\cf21 #undef DOCTEST_CHECK_NOTHROW_MESSAGE}\par
2698 {\cf21 #undef DOCTEST_REQUIRE_NOTHROW_MESSAGE}\par
2699 \par
2700 {\cf21 #ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS}\par
2701 \par
2702 {\cf21 #define DOCTEST_WARN_THROWS(expr) ((void)0)}\par
2703 {\cf21 #define DOCTEST_CHECK_THROWS(expr) ((void)0)}\par
2704 {\cf21 #define DOCTEST_REQUIRE_THROWS(expr) ((void)0)}\par
2705 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2706 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ...) ((void)0)}\par
2707 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ...) ((void)0)}\par
2708 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ...) ((void)0)}\par
2709 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2710 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ex) ((void)0)}\par
2711 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ex) ((void)0)}\par
2712 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ex) ((void)0)}\par
2713 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2714 {\cf21 #define DOCTEST_WARN_NOTHROW(expr) ((void)0)}\par
2715 {\cf21 #define DOCTEST_CHECK_NOTHROW(expr) ((void)0)}\par
2716 {\cf21 #define DOCTEST_REQUIRE_NOTHROW(expr) ((void)0)}\par
2717 \par
2718 {\cf21 #define DOCTEST_WARN_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2719 {\cf21 #define DOCTEST_CHECK_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2720 {\cf21 #define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2721 {\cf21 #define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2722 {\cf21 #define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2723 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2724 {\cf21 #define DOCTEST_WARN_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2725 {\cf21 #define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2726 {\cf21 #define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2727 \par
2728 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS}\par
2729 \par
2730 {\cf21 #undef DOCTEST_REQUIRE}\par
2731 {\cf21 #undef DOCTEST_REQUIRE_FALSE}\par
2732 {\cf21 #undef DOCTEST_REQUIRE_MESSAGE}\par
2733 {\cf21 #undef DOCTEST_REQUIRE_FALSE_MESSAGE}\par
2734 {\cf21 #undef DOCTEST_REQUIRE_EQ}\par
2735 {\cf21 #undef DOCTEST_REQUIRE_NE}\par
2736 {\cf21 #undef DOCTEST_REQUIRE_GT}\par
2737 {\cf21 #undef DOCTEST_REQUIRE_LT}\par
2738 {\cf21 #undef DOCTEST_REQUIRE_GE}\par
2739 {\cf21 #undef DOCTEST_REQUIRE_LE}\par
2740 {\cf21 #undef DOCTEST_REQUIRE_UNARY}\par
2741 {\cf21 #undef DOCTEST_REQUIRE_UNARY_FALSE}\par
2742 {\cf21 #undef DOCTEST_FAST_REQUIRE_EQ}\par
2743 {\cf21 #undef DOCTEST_FAST_REQUIRE_NE}\par
2744 {\cf21 #undef DOCTEST_FAST_REQUIRE_GT}\par
2745 {\cf21 #undef DOCTEST_FAST_REQUIRE_LT}\par
2746 {\cf21 #undef DOCTEST_FAST_REQUIRE_GE}\par
2747 {\cf21 #undef DOCTEST_FAST_REQUIRE_LE}\par
2748 {\cf21 #undef DOCTEST_FAST_REQUIRE_UNARY}\par
2749 {\cf21 #undef DOCTEST_FAST_REQUIRE_UNARY_FALSE}\par
2750 \par
2751 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS}\par
2752 \par
2753 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
2754 \par
2755 {\cf20 // =================================================================================================}\par
2756 {\cf20 // == WHAT FOLLOWS IS VERSIONS OF THE MACROS THAT DO NOT DO ANY REGISTERING!                      ==}\par
2757 {\cf20 // == THIS CAN BE ENABLED BY DEFINING DOCTEST_CONFIG_DISABLE GLOBALLY!                            ==}\par
2758 {\cf20 // =================================================================================================}\par
2759 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2760 \par
2761 {\cf21 #define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, name)                                           \\}\par
2762 {\cf21     namespace                                                                                      \\}\par
2763 {\cf21     \{                                                                                              \\}\par
2764 {\cf21         template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                           \\}\par
2765 {\cf21         struct der : base                                                                          \\}\par
2766 {\cf21         \{ void f(); \};                                                                             \\}\par
2767 {\cf21     \}                                                                                              \\}\par
2768 {\cf21     template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\}\par
2769 {\cf21     inline void der<DOCTEST_UNUSED_TEMPLATE_TYPE>::f()}\par
2770 \par
2771 {\cf21 #define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, name)                                              \\}\par
2772 {\cf21     template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\}\par
2773 {\cf21     static inline void f()}\par
2774 \par
2775 {\cf20 // for registering tests}\par
2776 {\cf21 #define DOCTEST_TEST_CASE(name)                                                                    \\}\par
2777 {\cf21     DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), name)}\par
2778 \par
2779 {\cf20 // for registering tests with a fixture}\par
2780 {\cf21 #define DOCTEST_TEST_CASE_FIXTURE(x, name)                                                         \\}\par
2781 {\cf21     DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(_DOCTEST_ANON_CLASS_), x,                          \\}\par
2782 {\cf21                               DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), name)}\par
2783 \par
2784 {\cf20 // for converting types to strings without the <typeinfo> header and demangling}\par
2785 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2786 {\cf21 #define DOCTEST_TYPE_TO_STRING(...) typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2787 {\cf21 #define DOCTEST_TYPE_TO_STRING_IMPL(...)}\par
2788 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2789 {\cf21 #define DOCTEST_TYPE_TO_STRING(x) typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2790 {\cf21 #define DOCTEST_TYPE_TO_STRING_IMPL(x)}\par
2791 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2792 \par
2793 {\cf20 // for typed tests}\par
2794 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE(name, type, types)                                              \\}\par
2795 {\cf21     template <typename type>                                                                       \\}\par
2796 {\cf21     inline void DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_)()}\par
2797 \par
2798 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, type, id)                                          \\}\par
2799 {\cf21     template <typename type>                                                                       \\}\par
2800 {\cf21     inline void DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_)()}\par
2801 \par
2802 {\cf21 #define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, types)                                          \\}\par
2803 {\cf21     typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2804 \par
2805 {\cf20 // for subcases}\par
2806 {\cf21 #define DOCTEST_SUBCASE(name)}\par
2807 \par
2808 {\cf20 // for a testsuite block}\par
2809 {\cf21 #define DOCTEST_TEST_SUITE(name) namespace}\par
2810 \par
2811 {\cf20 // for starting a testsuite block}\par
2812 {\cf21 #define DOCTEST_TEST_SUITE_BEGIN(name) typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2813 \par
2814 {\cf20 // for ending a testsuite block}\par
2815 {\cf21 #define DOCTEST_TEST_SUITE_END typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)}\par
2816 \par
2817 {\cf21 #define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \\}\par
2818 {\cf21     template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\}\par
2819 {\cf21     static inline doctest::String DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_)(signature)}\par
2820 \par
2821 {\cf21 #define DOCTEST_INFO(x) ((void)0)}\par
2822 {\cf21 #define DOCTEST_CAPTURE(x) ((void)0)}\par
2823 {\cf21 #define DOCTEST_ADD_MESSAGE_AT(file, line, x) ((void)0)}\par
2824 {\cf21 #define DOCTEST_ADD_FAIL_CHECK_AT(file, line, x) ((void)0)}\par
2825 {\cf21 #define DOCTEST_ADD_FAIL_AT(file, line, x) ((void)0)}\par
2826 {\cf21 #define DOCTEST_MESSAGE(x) ((void)0)}\par
2827 {\cf21 #define DOCTEST_FAIL_CHECK(x) ((void)0)}\par
2828 {\cf21 #define DOCTEST_FAIL(x) ((void)0)}\par
2829 \par
2830 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2831 {\cf21 #define DOCTEST_WARN(...) ((void)0)}\par
2832 {\cf21 #define DOCTEST_CHECK(...) ((void)0)}\par
2833 {\cf21 #define DOCTEST_REQUIRE(...) ((void)0)}\par
2834 {\cf21 #define DOCTEST_WARN_FALSE(...) ((void)0)}\par
2835 {\cf21 #define DOCTEST_CHECK_FALSE(...) ((void)0)}\par
2836 {\cf21 #define DOCTEST_REQUIRE_FALSE(...) ((void)0)}\par
2837 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2838 {\cf21 #define DOCTEST_WARN(expr) ((void)0)}\par
2839 {\cf21 #define DOCTEST_CHECK(expr) ((void)0)}\par
2840 {\cf21 #define DOCTEST_REQUIRE(expr) ((void)0)}\par
2841 {\cf21 #define DOCTEST_WARN_FALSE(expr) ((void)0)}\par
2842 {\cf21 #define DOCTEST_CHECK_FALSE(expr) ((void)0)}\par
2843 {\cf21 #define DOCTEST_REQUIRE_FALSE(expr) ((void)0)}\par
2844 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2845 \par
2846 {\cf21 #define DOCTEST_WARN_MESSAGE(cond, msg) ((void)0)}\par
2847 {\cf21 #define DOCTEST_CHECK_MESSAGE(cond, msg) ((void)0)}\par
2848 {\cf21 #define DOCTEST_REQUIRE_MESSAGE(cond, msg) ((void)0)}\par
2849 {\cf21 #define DOCTEST_WARN_FALSE_MESSAGE(cond, msg) ((void)0)}\par
2850 {\cf21 #define DOCTEST_CHECK_FALSE_MESSAGE(cond, msg) ((void)0)}\par
2851 {\cf21 #define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, msg) ((void)0)}\par
2852 \par
2853 {\cf21 #define DOCTEST_WARN_THROWS(expr) ((void)0)}\par
2854 {\cf21 #define DOCTEST_CHECK_THROWS(expr) ((void)0)}\par
2855 {\cf21 #define DOCTEST_REQUIRE_THROWS(expr) ((void)0)}\par
2856 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2857 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ...) ((void)0)}\par
2858 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ...) ((void)0)}\par
2859 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ...) ((void)0)}\par
2860 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2861 {\cf21 #define DOCTEST_WARN_THROWS_AS(expr, ex) ((void)0)}\par
2862 {\cf21 #define DOCTEST_CHECK_THROWS_AS(expr, ex) ((void)0)}\par
2863 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS(expr, ex) ((void)0)}\par
2864 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2865 {\cf21 #define DOCTEST_WARN_NOTHROW(expr) ((void)0)}\par
2866 {\cf21 #define DOCTEST_CHECK_NOTHROW(expr) ((void)0)}\par
2867 {\cf21 #define DOCTEST_REQUIRE_NOTHROW(expr) ((void)0)}\par
2868 \par
2869 {\cf21 #define DOCTEST_WARN_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2870 {\cf21 #define DOCTEST_CHECK_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2871 {\cf21 #define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, msg) ((void)0)}\par
2872 {\cf21 #define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2873 {\cf21 #define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2874 {\cf21 #define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, msg) ((void)0)}\par
2875 {\cf21 #define DOCTEST_WARN_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2876 {\cf21 #define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2877 {\cf21 #define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, msg) ((void)0)}\par
2878 \par
2879 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2880 \par
2881 {\cf21 #define DOCTEST_WARN_EQ(...) ((void)0)}\par
2882 {\cf21 #define DOCTEST_CHECK_EQ(...) ((void)0)}\par
2883 {\cf21 #define DOCTEST_REQUIRE_EQ(...) ((void)0)}\par
2884 {\cf21 #define DOCTEST_WARN_NE(...) ((void)0)}\par
2885 {\cf21 #define DOCTEST_CHECK_NE(...) ((void)0)}\par
2886 {\cf21 #define DOCTEST_REQUIRE_NE(...) ((void)0)}\par
2887 {\cf21 #define DOCTEST_WARN_GT(...) ((void)0)}\par
2888 {\cf21 #define DOCTEST_CHECK_GT(...) ((void)0)}\par
2889 {\cf21 #define DOCTEST_REQUIRE_GT(...) ((void)0)}\par
2890 {\cf21 #define DOCTEST_WARN_LT(...) ((void)0)}\par
2891 {\cf21 #define DOCTEST_CHECK_LT(...) ((void)0)}\par
2892 {\cf21 #define DOCTEST_REQUIRE_LT(...) ((void)0)}\par
2893 {\cf21 #define DOCTEST_WARN_GE(...) ((void)0)}\par
2894 {\cf21 #define DOCTEST_CHECK_GE(...) ((void)0)}\par
2895 {\cf21 #define DOCTEST_REQUIRE_GE(...) ((void)0)}\par
2896 {\cf21 #define DOCTEST_WARN_LE(...) ((void)0)}\par
2897 {\cf21 #define DOCTEST_CHECK_LE(...) ((void)0)}\par
2898 {\cf21 #define DOCTEST_REQUIRE_LE(...) ((void)0)}\par
2899 \par
2900 {\cf21 #define DOCTEST_WARN_UNARY(...) ((void)0)}\par
2901 {\cf21 #define DOCTEST_CHECK_UNARY(...) ((void)0)}\par
2902 {\cf21 #define DOCTEST_REQUIRE_UNARY(...) ((void)0)}\par
2903 {\cf21 #define DOCTEST_WARN_UNARY_FALSE(...) ((void)0)}\par
2904 {\cf21 #define DOCTEST_CHECK_UNARY_FALSE(...) ((void)0)}\par
2905 {\cf21 #define DOCTEST_REQUIRE_UNARY_FALSE(...) ((void)0)}\par
2906 \par
2907 {\cf21 #define DOCTEST_FAST_WARN_EQ(...) ((void)0)}\par
2908 {\cf21 #define DOCTEST_FAST_CHECK_EQ(...) ((void)0)}\par
2909 {\cf21 #define DOCTEST_FAST_REQUIRE_EQ(...) ((void)0)}\par
2910 {\cf21 #define DOCTEST_FAST_WARN_NE(...) ((void)0)}\par
2911 {\cf21 #define DOCTEST_FAST_CHECK_NE(...) ((void)0)}\par
2912 {\cf21 #define DOCTEST_FAST_REQUIRE_NE(...) ((void)0)}\par
2913 {\cf21 #define DOCTEST_FAST_WARN_GT(...) ((void)0)}\par
2914 {\cf21 #define DOCTEST_FAST_CHECK_GT(...) ((void)0)}\par
2915 {\cf21 #define DOCTEST_FAST_REQUIRE_GT(...) ((void)0)}\par
2916 {\cf21 #define DOCTEST_FAST_WARN_LT(...) ((void)0)}\par
2917 {\cf21 #define DOCTEST_FAST_CHECK_LT(...) ((void)0)}\par
2918 {\cf21 #define DOCTEST_FAST_REQUIRE_LT(...) ((void)0)}\par
2919 {\cf21 #define DOCTEST_FAST_WARN_GE(...) ((void)0)}\par
2920 {\cf21 #define DOCTEST_FAST_CHECK_GE(...) ((void)0)}\par
2921 {\cf21 #define DOCTEST_FAST_REQUIRE_GE(...) ((void)0)}\par
2922 {\cf21 #define DOCTEST_FAST_WARN_LE(...) ((void)0)}\par
2923 {\cf21 #define DOCTEST_FAST_CHECK_LE(...) ((void)0)}\par
2924 {\cf21 #define DOCTEST_FAST_REQUIRE_LE(...) ((void)0)}\par
2925 \par
2926 {\cf21 #define DOCTEST_FAST_WARN_UNARY(...) ((void)0)}\par
2927 {\cf21 #define DOCTEST_FAST_CHECK_UNARY(...) ((void)0)}\par
2928 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY(...) ((void)0)}\par
2929 {\cf21 #define DOCTEST_FAST_WARN_UNARY_FALSE(...) ((void)0)}\par
2930 {\cf21 #define DOCTEST_FAST_CHECK_UNARY_FALSE(...) ((void)0)}\par
2931 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY_FALSE(...) ((void)0)}\par
2932 \par
2933 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2934 \par
2935 {\cf21 #define DOCTEST_WARN_EQ(lhs, rhs) ((void)0)}\par
2936 {\cf21 #define DOCTEST_CHECK_EQ(lhs, rhs) ((void)0)}\par
2937 {\cf21 #define DOCTEST_REQUIRE_EQ(lhs, rhs) ((void)0)}\par
2938 {\cf21 #define DOCTEST_WARN_NE(lhs, rhs) ((void)0)}\par
2939 {\cf21 #define DOCTEST_CHECK_NE(lhs, rhs) ((void)0)}\par
2940 {\cf21 #define DOCTEST_REQUIRE_NE(lhs, rhs) ((void)0)}\par
2941 {\cf21 #define DOCTEST_WARN_GT(lhs, rhs) ((void)0)}\par
2942 {\cf21 #define DOCTEST_CHECK_GT(lhs, rhs) ((void)0)}\par
2943 {\cf21 #define DOCTEST_REQUIRE_GT(lhs, rhs) ((void)0)}\par
2944 {\cf21 #define DOCTEST_WARN_LT(lhs, rhs) ((void)0)}\par
2945 {\cf21 #define DOCTEST_CHECK_LT(lhs, rhs) ((void)0)}\par
2946 {\cf21 #define DOCTEST_REQUIRE_LT(lhs, rhs) ((void)0)}\par
2947 {\cf21 #define DOCTEST_WARN_GE(lhs, rhs) ((void)0)}\par
2948 {\cf21 #define DOCTEST_CHECK_GE(lhs, rhs) ((void)0)}\par
2949 {\cf21 #define DOCTEST_REQUIRE_GE(lhs, rhs) ((void)0)}\par
2950 {\cf21 #define DOCTEST_WARN_LE(lhs, rhs) ((void)0)}\par
2951 {\cf21 #define DOCTEST_CHECK_LE(lhs, rhs) ((void)0)}\par
2952 {\cf21 #define DOCTEST_REQUIRE_LE(lhs, rhs) ((void)0)}\par
2953 \par
2954 {\cf21 #define DOCTEST_WARN_UNARY(val) ((void)0)}\par
2955 {\cf21 #define DOCTEST_CHECK_UNARY(val) ((void)0)}\par
2956 {\cf21 #define DOCTEST_REQUIRE_UNARY(val) ((void)0)}\par
2957 {\cf21 #define DOCTEST_WARN_UNARY_FALSE(val) ((void)0)}\par
2958 {\cf21 #define DOCTEST_CHECK_UNARY_FALSE(val) ((void)0)}\par
2959 {\cf21 #define DOCTEST_REQUIRE_UNARY_FALSE(val) ((void)0)}\par
2960 \par
2961 {\cf21 #define DOCTEST_FAST_WARN_EQ(lhs, rhs) ((void)0)}\par
2962 {\cf21 #define DOCTEST_FAST_CHECK_EQ(lhs, rhs) ((void)0)}\par
2963 {\cf21 #define DOCTEST_FAST_REQUIRE_EQ(lhs, rhs) ((void)0)}\par
2964 {\cf21 #define DOCTEST_FAST_WARN_NE(lhs, rhs) ((void)0)}\par
2965 {\cf21 #define DOCTEST_FAST_CHECK_NE(lhs, rhs) ((void)0)}\par
2966 {\cf21 #define DOCTEST_FAST_REQUIRE_NE(lhs, rhs) ((void)0)}\par
2967 {\cf21 #define DOCTEST_FAST_WARN_GT(lhs, rhs) ((void)0)}\par
2968 {\cf21 #define DOCTEST_FAST_CHECK_GT(lhs, rhs) ((void)0)}\par
2969 {\cf21 #define DOCTEST_FAST_REQUIRE_GT(lhs, rhs) ((void)0)}\par
2970 {\cf21 #define DOCTEST_FAST_WARN_LT(lhs, rhs) ((void)0)}\par
2971 {\cf21 #define DOCTEST_FAST_CHECK_LT(lhs, rhs) ((void)0)}\par
2972 {\cf21 #define DOCTEST_FAST_REQUIRE_LT(lhs, rhs) ((void)0)}\par
2973 {\cf21 #define DOCTEST_FAST_WARN_GE(lhs, rhs) ((void)0)}\par
2974 {\cf21 #define DOCTEST_FAST_CHECK_GE(lhs, rhs) ((void)0)}\par
2975 {\cf21 #define DOCTEST_FAST_REQUIRE_GE(lhs, rhs) ((void)0)}\par
2976 {\cf21 #define DOCTEST_FAST_WARN_LE(lhs, rhs) ((void)0)}\par
2977 {\cf21 #define DOCTEST_FAST_CHECK_LE(lhs, rhs) ((void)0)}\par
2978 {\cf21 #define DOCTEST_FAST_REQUIRE_LE(lhs, rhs) ((void)0)}\par
2979 \par
2980 {\cf21 #define DOCTEST_FAST_WARN_UNARY(val) ((void)0)}\par
2981 {\cf21 #define DOCTEST_FAST_CHECK_UNARY(val) ((void)0)}\par
2982 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY(val) ((void)0)}\par
2983 {\cf21 #define DOCTEST_FAST_WARN_UNARY_FALSE(val) ((void)0)}\par
2984 {\cf21 #define DOCTEST_FAST_CHECK_UNARY_FALSE(val) ((void)0)}\par
2985 {\cf21 #define DOCTEST_FAST_REQUIRE_UNARY_FALSE(val) ((void)0)}\par
2986 \par
2987 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2988 \par
2989 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
2990 \par
2991 {\cf20 // BDD style macros}\par
2992 {\cf20 // clang-format off}\par
2993 {\cf21 #define DOCTEST_SCENARIO(name)  TEST_CASE("  Scenario: "} name)\par
2994 {\cf21 #ifdef DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2995 {\cf21 #define DOCTEST_SCENARIO_TEMPLATE(name, T, ...)  TEST_CASE_TEMPLATE("  Scenario: "} name, T, __VA_ARGS__)\par
2996 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2997 {\cf21 #define DOCTEST_SCENARIO_TEMPLATE(name, T, types) TEST_CASE_TEMPLATE("  Scenario: "} name, T, types)\par
2998 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_VARIADIC_MACROS}\par
2999 {\cf21 #define DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE("  Scenario: "} name, T, id)\par
3000 \par
3001 {\cf21 #define DOCTEST_GIVEN(name)     SUBCASE("   Given: "} name)\par
3002 {\cf21 #define DOCTEST_WHEN(name)      SUBCASE("    When: "} name)\par
3003 {\cf21 #define DOCTEST_AND_WHEN(name)  SUBCASE("And when: "} name)\par
3004 {\cf21 #define DOCTEST_THEN(name)      SUBCASE("    Then: "} name)\par
3005 {\cf21 #define DOCTEST_AND_THEN(name)  SUBCASE("     And: "} name)\par
3006 {\cf20 // clang-format on}\par
3007 \par
3008 {\cf20 // == SHORT VERSIONS OF THE MACROS}\par
3009 {\cf21 #if !defined(DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES)}\par
3010 \par
3011 {\cf21 #define TEST_CASE DOCTEST_TEST_CASE}\par
3012 {\cf21 #define TEST_CASE_FIXTURE DOCTEST_TEST_CASE_FIXTURE}\par
3013 {\cf21 #define TYPE_TO_STRING DOCTEST_TYPE_TO_STRING}\par
3014 {\cf21 #define TEST_CASE_TEMPLATE DOCTEST_TEST_CASE_TEMPLATE}\par
3015 {\cf21 #define TEST_CASE_TEMPLATE_DEFINE DOCTEST_TEST_CASE_TEMPLATE_DEFINE}\par
3016 {\cf21 #define TEST_CASE_TEMPLATE_INSTANTIATE DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE}\par
3017 {\cf21 #define SUBCASE DOCTEST_SUBCASE}\par
3018 {\cf21 #define TEST_SUITE DOCTEST_TEST_SUITE}\par
3019 {\cf21 #define TEST_SUITE_BEGIN DOCTEST_TEST_SUITE_BEGIN}\par
3020 {\cf21 #define TEST_SUITE_END DOCTEST_TEST_SUITE_END}\par
3021 {\cf21 #define REGISTER_EXCEPTION_TRANSLATOR DOCTEST_REGISTER_EXCEPTION_TRANSLATOR}\par
3022 {\cf21 #define INFO DOCTEST_INFO}\par
3023 {\cf21 #define CAPTURE DOCTEST_CAPTURE}\par
3024 {\cf21 #define ADD_MESSAGE_AT DOCTEST_ADD_MESSAGE_AT}\par
3025 {\cf21 #define ADD_FAIL_CHECK_AT DOCTEST_ADD_FAIL_CHECK_AT}\par
3026 {\cf21 #define ADD_FAIL_AT DOCTEST_ADD_FAIL_AT}\par
3027 {\cf21 #define MESSAGE DOCTEST_MESSAGE}\par
3028 {\cf21 #define FAIL_CHECK DOCTEST_FAIL_CHECK}\par
3029 {\cf21 #define FAIL DOCTEST_FAIL}\par
3030 {\cf21 #define TO_LVALUE DOCTEST_TO_LVALUE}\par
3031 \par
3032 {\cf21 #define WARN DOCTEST_WARN}\par
3033 {\cf21 #define WARN_FALSE DOCTEST_WARN_FALSE}\par
3034 {\cf21 #define WARN_THROWS DOCTEST_WARN_THROWS}\par
3035 {\cf21 #define WARN_THROWS_AS DOCTEST_WARN_THROWS_AS}\par
3036 {\cf21 #define WARN_NOTHROW DOCTEST_WARN_NOTHROW}\par
3037 {\cf21 #define CHECK DOCTEST_CHECK}\par
3038 {\cf21 #define CHECK_FALSE DOCTEST_CHECK_FALSE}\par
3039 {\cf21 #define CHECK_THROWS DOCTEST_CHECK_THROWS}\par
3040 {\cf21 #define CHECK_THROWS_AS DOCTEST_CHECK_THROWS_AS}\par
3041 {\cf21 #define CHECK_NOTHROW DOCTEST_CHECK_NOTHROW}\par
3042 {\cf21 #define REQUIRE DOCTEST_REQUIRE}\par
3043 {\cf21 #define REQUIRE_FALSE DOCTEST_REQUIRE_FALSE}\par
3044 {\cf21 #define REQUIRE_THROWS DOCTEST_REQUIRE_THROWS}\par
3045 {\cf21 #define REQUIRE_THROWS_AS DOCTEST_REQUIRE_THROWS_AS}\par
3046 {\cf21 #define REQUIRE_NOTHROW DOCTEST_REQUIRE_NOTHROW}\par
3047 \par
3048 {\cf21 #define WARN_MESSAGE DOCTEST_WARN_MESSAGE}\par
3049 {\cf21 #define WARN_FALSE_MESSAGE DOCTEST_WARN_FALSE_MESSAGE}\par
3050 {\cf21 #define WARN_THROWS_MESSAGE DOCTEST_WARN_THROWS_MESSAGE}\par
3051 {\cf21 #define WARN_THROWS_AS_MESSAGE DOCTEST_WARN_THROWS_AS_MESSAGE}\par
3052 {\cf21 #define WARN_NOTHROW_MESSAGE DOCTEST_WARN_NOTHROW_MESSAGE}\par
3053 {\cf21 #define CHECK_MESSAGE DOCTEST_CHECK_MESSAGE}\par
3054 {\cf21 #define CHECK_FALSE_MESSAGE DOCTEST_CHECK_FALSE_MESSAGE}\par
3055 {\cf21 #define CHECK_THROWS_MESSAGE DOCTEST_CHECK_THROWS_MESSAGE}\par
3056 {\cf21 #define CHECK_THROWS_AS_MESSAGE DOCTEST_CHECK_THROWS_AS_MESSAGE}\par
3057 {\cf21 #define CHECK_NOTHROW_MESSAGE DOCTEST_CHECK_NOTHROW_MESSAGE}\par
3058 {\cf21 #define REQUIRE_MESSAGE DOCTEST_REQUIRE_MESSAGE}\par
3059 {\cf21 #define REQUIRE_FALSE_MESSAGE DOCTEST_REQUIRE_FALSE_MESSAGE}\par
3060 {\cf21 #define REQUIRE_THROWS_MESSAGE DOCTEST_REQUIRE_THROWS_MESSAGE}\par
3061 {\cf21 #define REQUIRE_THROWS_AS_MESSAGE DOCTEST_REQUIRE_THROWS_AS_MESSAGE}\par
3062 {\cf21 #define REQUIRE_NOTHROW_MESSAGE DOCTEST_REQUIRE_NOTHROW_MESSAGE}\par
3063 \par
3064 {\cf21 #define SCENARIO DOCTEST_SCENARIO}\par
3065 {\cf21 #define SCENARIO_TEMPLATE DOCTEST_SCENARIO_TEMPLATE}\par
3066 {\cf21 #define SCENARIO_TEMPLATE_DEFINE DOCTEST_SCENARIO_TEMPLATE_DEFINE}\par
3067 {\cf21 #define GIVEN DOCTEST_GIVEN}\par
3068 {\cf21 #define WHEN DOCTEST_WHEN}\par
3069 {\cf21 #define AND_WHEN DOCTEST_AND_WHEN}\par
3070 {\cf21 #define THEN DOCTEST_THEN}\par
3071 {\cf21 #define AND_THEN DOCTEST_AND_THEN}\par
3072 \par
3073 {\cf21 #define WARN_EQ DOCTEST_WARN_EQ}\par
3074 {\cf21 #define CHECK_EQ DOCTEST_CHECK_EQ}\par
3075 {\cf21 #define REQUIRE_EQ DOCTEST_REQUIRE_EQ}\par
3076 {\cf21 #define WARN_NE DOCTEST_WARN_NE}\par
3077 {\cf21 #define CHECK_NE DOCTEST_CHECK_NE}\par
3078 {\cf21 #define REQUIRE_NE DOCTEST_REQUIRE_NE}\par
3079 {\cf21 #define WARN_GT DOCTEST_WARN_GT}\par
3080 {\cf21 #define CHECK_GT DOCTEST_CHECK_GT}\par
3081 {\cf21 #define REQUIRE_GT DOCTEST_REQUIRE_GT}\par
3082 {\cf21 #define WARN_LT DOCTEST_WARN_LT}\par
3083 {\cf21 #define CHECK_LT DOCTEST_CHECK_LT}\par
3084 {\cf21 #define REQUIRE_LT DOCTEST_REQUIRE_LT}\par
3085 {\cf21 #define WARN_GE DOCTEST_WARN_GE}\par
3086 {\cf21 #define CHECK_GE DOCTEST_CHECK_GE}\par
3087 {\cf21 #define REQUIRE_GE DOCTEST_REQUIRE_GE}\par
3088 {\cf21 #define WARN_LE DOCTEST_WARN_LE}\par
3089 {\cf21 #define CHECK_LE DOCTEST_CHECK_LE}\par
3090 {\cf21 #define REQUIRE_LE DOCTEST_REQUIRE_LE}\par
3091 {\cf21 #define WARN_UNARY DOCTEST_WARN_UNARY}\par
3092 {\cf21 #define CHECK_UNARY DOCTEST_CHECK_UNARY}\par
3093 {\cf21 #define REQUIRE_UNARY DOCTEST_REQUIRE_UNARY}\par
3094 {\cf21 #define WARN_UNARY_FALSE DOCTEST_WARN_UNARY_FALSE}\par
3095 {\cf21 #define CHECK_UNARY_FALSE DOCTEST_CHECK_UNARY_FALSE}\par
3096 {\cf21 #define REQUIRE_UNARY_FALSE DOCTEST_REQUIRE_UNARY_FALSE}\par
3097 \par
3098 {\cf21 #define FAST_WARN_EQ DOCTEST_FAST_WARN_EQ}\par
3099 {\cf21 #define FAST_CHECK_EQ DOCTEST_FAST_CHECK_EQ}\par
3100 {\cf21 #define FAST_REQUIRE_EQ DOCTEST_FAST_REQUIRE_EQ}\par
3101 {\cf21 #define FAST_WARN_NE DOCTEST_FAST_WARN_NE}\par
3102 {\cf21 #define FAST_CHECK_NE DOCTEST_FAST_CHECK_NE}\par
3103 {\cf21 #define FAST_REQUIRE_NE DOCTEST_FAST_REQUIRE_NE}\par
3104 {\cf21 #define FAST_WARN_GT DOCTEST_FAST_WARN_GT}\par
3105 {\cf21 #define FAST_CHECK_GT DOCTEST_FAST_CHECK_GT}\par
3106 {\cf21 #define FAST_REQUIRE_GT DOCTEST_FAST_REQUIRE_GT}\par
3107 {\cf21 #define FAST_WARN_LT DOCTEST_FAST_WARN_LT}\par
3108 {\cf21 #define FAST_CHECK_LT DOCTEST_FAST_CHECK_LT}\par
3109 {\cf21 #define FAST_REQUIRE_LT DOCTEST_FAST_REQUIRE_LT}\par
3110 {\cf21 #define FAST_WARN_GE DOCTEST_FAST_WARN_GE}\par
3111 {\cf21 #define FAST_CHECK_GE DOCTEST_FAST_CHECK_GE}\par
3112 {\cf21 #define FAST_REQUIRE_GE DOCTEST_FAST_REQUIRE_GE}\par
3113 {\cf21 #define FAST_WARN_LE DOCTEST_FAST_WARN_LE}\par
3114 {\cf21 #define FAST_CHECK_LE DOCTEST_FAST_CHECK_LE}\par
3115 {\cf21 #define FAST_REQUIRE_LE DOCTEST_FAST_REQUIRE_LE}\par
3116 {\cf21 #define FAST_WARN_UNARY DOCTEST_FAST_WARN_UNARY}\par
3117 {\cf21 #define FAST_CHECK_UNARY DOCTEST_FAST_CHECK_UNARY}\par
3118 {\cf21 #define FAST_REQUIRE_UNARY DOCTEST_FAST_REQUIRE_UNARY}\par
3119 {\cf21 #define FAST_WARN_UNARY_FALSE DOCTEST_FAST_WARN_UNARY_FALSE}\par
3120 {\cf21 #define FAST_CHECK_UNARY_FALSE DOCTEST_FAST_CHECK_UNARY_FALSE}\par
3121 {\cf21 #define FAST_REQUIRE_UNARY_FALSE DOCTEST_FAST_REQUIRE_UNARY_FALSE}\par
3122 \par
3123 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES}\par
3124 \par
3125 {\cf20 // this is here to clear the 'current test suite' for the current translation unit - at the top}\par
3126 DOCTEST_TEST_SUITE_END();\par
3127 \par
3128 {\cf20 // add stringification for primitive/fundamental types}\par
3129 {\cf17 namespace }doctest\par
3130 \{\par
3131 {\cf17 namespace }detail\par
3132 \{\par
3133     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 bool})\par
3134     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 float})\par
3135     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 double})\par
3136     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 long} {\cf18 double})\par
3137     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 char})\par
3138     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 signed} {\cf18 char})\par
3139     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 unsigned} {\cf18 char})\par
3140     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 wchar_t})\par
3141     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 short} {\cf18 int})\par
3142     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 unsigned} {\cf18 short} {\cf18 int})\par
3143     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 int})\par
3144     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 unsigned} {\cf18 int})\par
3145     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 long} {\cf18 int})\par
3146     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 unsigned} {\cf18 long} {\cf18 int})\par
3147 {\cf21 #ifdef DOCTEST_CONFIG_WITH_LONG_LONG}\par
3148     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 long} {\cf18 long} {\cf18 int})\par
3149     DOCTEST_TYPE_TO_STRING_IMPL({\cf18 unsigned} {\cf18 long} {\cf18 long} {\cf18 int})\par
3150 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
3151 \} {\cf20 // namespace detail}\par
3152 \} {\cf20 // namespace doctest}\par
3153 \par
3154 DOCTEST_CLANG_SUPPRESS_WARNING_POP\par
3155 DOCTEST_MSVC_SUPPRESS_WARNING_POP\par
3156 DOCTEST_GCC_SUPPRESS_WARNING_POP\par
3157 \par
3158 {\cf21 #endif }{\cf20 // DOCTEST_LIBRARY_INCLUDED}\par
3159 \par
3160 {\cf21 #ifndef DOCTEST_SINGLE_HEADER}\par
3161 {\cf21 #define DOCTEST_SINGLE_HEADER}\par
3162 {\cf21 #endif }{\cf20 // DOCTEST_SINGLE_HEADER}\par
3163 \par
3164 {\cf21 #if defined(DOCTEST_CONFIG_IMPLEMENT) || !defined(DOCTEST_SINGLE_HEADER)}\par
3165 {\cf21 #ifndef DOCTEST_LIBRARY_IMPLEMENTATION}\par
3166 {\cf21 #define DOCTEST_LIBRARY_IMPLEMENTATION}\par
3167 \par
3168 {\cf21 #ifndef DOCTEST_SINGLE_HEADER}\par
3169 {\cf21 #include "doctest_fwd.h"}\par
3170 {\cf21 #endif }{\cf20 // DOCTEST_SINGLE_HEADER}\par
3171 \par
3172 DOCTEST_CLANG_SUPPRESS_WARNING_PUSH\par
3173 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wunknown-pragmas"})\par
3174 DOCTEST_CLANG_SUPPRESS_WARNING("-Wpadded")\par
3175 DOCTEST_CLANG_SUPPRESS_WARNING("-Wglobal-constructors")\par
3176 DOCTEST_CLANG_SUPPRESS_WARNING("-Wexit-time-destructors")\par
3177 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-prototypes")\par
3178 DOCTEST_CLANG_SUPPRESS_WARNING("-Wsign-conversion")\par
3179 DOCTEST_CLANG_SUPPRESS_WARNING("-Wshorten-64-to-32")\par
3180 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-variable-declarations")\par
3181 DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch")\par
3182 DOCTEST_CLANG_SUPPRESS_WARNING("-Wswitch-enum")\par
3183 DOCTEST_CLANG_SUPPRESS_WARNING("-Wcovered-switch-default")\par
3184 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-noreturn")\par
3185 DOCTEST_CLANG_SUPPRESS_WARNING("-Wunused-local-typedef")\par
3186 DOCTEST_CLANG_SUPPRESS_WARNING("-Wdisabled-macro-expansion")\par
3187 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-braces")\par
3188 DOCTEST_CLANG_SUPPRESS_WARNING("-Wmissing-field-initializers")\par
3189 DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++11-{\cf18 long}-{\cf18 long}")\par
3190 {\cf21 #if DOCTEST_CLANG && DOCTEST_CLANG_HAS_WARNING("-Wzero-as-null-pointer-constant"})\par
3191 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wzero-as-null-pointer-constant"})\par
3192 {\cf21 #endif }{\cf20 // clang - 0 as null}\par
3193 \par
3194 DOCTEST_GCC_SUPPRESS_WARNING_PUSH\par
3195 DOCTEST_GCC_SUPPRESS_WARNING({\cf22 "-Wunknown-pragmas"})\par
3196 DOCTEST_GCC_SUPPRESS_WARNING("-Wpragmas")\par
3197 DOCTEST_GCC_SUPPRESS_WARNING("-Wconversion")\par
3198 DOCTEST_GCC_SUPPRESS_WARNING("-Weffc++")\par
3199 DOCTEST_GCC_SUPPRESS_WARNING("-Wsign-conversion")\par
3200 DOCTEST_GCC_SUPPRESS_WARNING("-Wstrict-overflow")\par
3201 DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-field-initializers")\par
3202 DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-braces")\par
3203 DOCTEST_GCC_SUPPRESS_WARNING("-Wmissing-declarations")\par
3204 DOCTEST_GCC_SUPPRESS_WARNING("-Winline")\par
3205 DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch")\par
3206 DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-enum")\par
3207 DOCTEST_GCC_SUPPRESS_WARNING("-Wswitch-default")\par
3208 DOCTEST_GCC_SUPPRESS_WARNING("-Wunsafe-loop-optimizations")\par
3209 DOCTEST_GCC_SUPPRESS_WARNING("-Wlong-{\cf18 long}")\par
3210 DOCTEST_GCC_SUPPRESS_WARNING("-Wold-style-cast")\par
3211 DOCTEST_GCC_SUPPRESS_WARNING("-Wzero-as-null-pointer-constant")\par
3212 DOCTEST_GCC_SUPPRESS_WARNING("-Wunused-local-typedefs")\par
3213 DOCTEST_GCC_SUPPRESS_WARNING("-Wuseless-cast")\par
3214 \par
3215 DOCTEST_MSVC_SUPPRESS_WARNING_PUSH\par
3216 DOCTEST_MSVC_SUPPRESS_WARNING(4616) {\cf20 // invalid compiler warning}\par
3217 DOCTEST_MSVC_SUPPRESS_WARNING(4619) {\cf20 // invalid compiler warning}\par
3218 DOCTEST_MSVC_SUPPRESS_WARNING(4996) {\cf20 // The compiler encountered a deprecated declaration}\par
3219 DOCTEST_MSVC_SUPPRESS_WARNING(4267) {\cf20 // 'var' : conversion from 'x' to 'y', possible loss of data}\par
3220 DOCTEST_MSVC_SUPPRESS_WARNING(4706) {\cf20 // assignment within conditional expression}\par
3221 DOCTEST_MSVC_SUPPRESS_WARNING(4512) {\cf20 // 'class' : assignment operator could not be generated}\par
3222 DOCTEST_MSVC_SUPPRESS_WARNING(4127) {\cf20 // conditional expression is constant}\par
3223 DOCTEST_MSVC_SUPPRESS_WARNING(4530) {\cf20 // C++ exception handler used, but unwind semantics not enabled}\par
3224 DOCTEST_MSVC_SUPPRESS_WARNING(4577) {\cf20 // 'noexcept' used with no exception handling mode specified}\par
3225 DOCTEST_MSVC_SUPPRESS_WARNING(4774) {\cf20 // format string expected in argument is not a string literal}\par
3226 DOCTEST_MSVC_SUPPRESS_WARNING(4365) {\cf20 // conversion from 'int' to 'unsigned', signed/unsigned mismatch}\par
3227 DOCTEST_MSVC_SUPPRESS_WARNING(4820) {\cf20 // padding in structs}\par
3228 DOCTEST_MSVC_SUPPRESS_WARNING(4640) {\cf20 // construction of local static object is not thread-safe}\par
3229 DOCTEST_MSVC_SUPPRESS_WARNING(5039) {\cf20 // pointer to potentially throwing function passed to extern C}\par
3230 DOCTEST_MSVC_SUPPRESS_WARNING(5045) {\cf20 // Spectre mitigation stuff}\par
3231 \par
3232 {\cf21 #if defined(DOCTEST_NO_CPP11_COMPAT)}\par
3233 DOCTEST_CLANG_SUPPRESS_WARNING({\cf22 "-Wc++98-compat"})\par
3234 DOCTEST_CLANG_SUPPRESS_WARNING("-Wc++98-compat-pedantic")\par
3235 {\cf21 #endif }{\cf20 // DOCTEST_NO_CPP11_COMPAT}\par
3236 \par
3237 {\cf21 #define DOCTEST_LOG_START(s)                                                                       \\}\par
3238 {\cf21     do \{                                                                                           \\}\par
3239 {\cf21         if(!contextState->hasLoggedCurrentTestStart) \{                                             \\}\par
3240 {\cf21             logTestStart(s, *contextState->currentTest);                                           \\}\par
3241 {\cf21             DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;                                           \\}\par
3242 {\cf21             logTestStart(oss, *contextState->currentTest);                                         \\}\par
3243 {\cf21             DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;                                             \\}\par
3244 {\cf21             contextState->hasLoggedCurrentTestStart = true;                                        \\}\par
3245 {\cf21         \}                                                                                          \\}\par
3246 {\cf21     \} while(false)}\par
3247 \par
3248 {\cf21 #define DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN                                                \\}\par
3249 {\cf21     if(isDebuggerActive()) \{                                                                       \\}\par
3250 {\cf21         ContextState* p_cs     = contextState;                                                     \\}\par
3251 {\cf21         bool          with_col = p_cs->no_colors;                                                  \\}\par
3252 {\cf21         p_cs->no_colors        = false;                                                            \\}\par
3253 {\cf21     std::ostringstream oss}\par
3254 \par
3255 {\cf21 #define DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END                                                  \\}\par
3256 {\cf21     printToDebugConsole(oss.str().c_str());                                                        \\}\par
3257 {\cf21     p_cs->no_colors = with_col;                                                                    \\}\par
3258 {\cf21     \}                                                                                              \\}\par
3259 {\cf21     ((void)0)}\par
3260 \par
3261 DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN\par
3262 \par
3263 {\cf20 // required includes - will go only in one translation unit!}\par
3264 {\cf21 #include <ctime>}\par
3265 {\cf21 #include <cmath>}\par
3266 {\cf20 // borland (Embarcadero) compiler requires math.h and not cmath - https://github.com/onqtam/doctest/pull/37}\par
3267 {\cf21 #ifdef __BORLANDC__}\par
3268 {\cf21 #include <math.h>}\par
3269 {\cf21 #endif }{\cf20 // __BORLANDC__}\par
3270 {\cf21 #include <new>}\par
3271 {\cf21 #include <cstdio>}\par
3272 {\cf21 #include <cstdlib>}\par
3273 {\cf21 #include <cstring>}\par
3274 {\cf21 #include <limits>}\par
3275 {\cf21 #include <utility>}\par
3276 {\cf21 #include <sstream>}\par
3277 {\cf21 #include <iostream>}\par
3278 {\cf21 #include <algorithm>}\par
3279 {\cf21 #include <iomanip>}\par
3280 {\cf21 #include <vector>}\par
3281 {\cf21 #include <set>}\par
3282 {\cf21 #include <exception>}\par
3283 {\cf21 #include <stdexcept>}\par
3284 {\cf21 #include <csignal>}\par
3285 {\cf21 #include <cfloat>}\par
3286 {\cf21 #include <cctype>}\par
3287 {\cf21 #if !DOCTEST_MSVC}\par
3288 {\cf21 #include <stdint.h>}\par
3289 {\cf21 #endif }{\cf20 // !MSVC}\par
3290 \par
3291 DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END\par
3292 \par
3293 {\cf17 namespace }doctest\par
3294 \{\par
3295 {\cf17 namespace }detail\par
3296 \{\par
3297     {\cf20 // case insensitive strcmp}\par
3298     {\cf18 int} stricmp({\cf18 char} {\cf17 const}* a, {\cf18 char} {\cf17 const}* b) \{\par
3299         {\cf19 for}(;; a++, b++) \{\par
3300             {\cf17 const} {\cf18 int} d = tolower(*a) - tolower(*b);\par
3301             {\cf19 if}(d != 0 || !*a)\par
3302                 {\cf19 return} d;\par
3303         \}\par
3304     \}\par
3305 \par
3306     {\cf18 void} my_memcpy({\cf18 void}* dest, {\cf17 const} {\cf18 void}* src, {\cf18 unsigned} num) \{ memcpy(dest, src, num); \}\par
3307 \par
3308     {\cf17 template} <{\cf17 typename} T>\par
3309     String fpToString(T value, {\cf18 int} precision) \{\par
3310         std::ostringstream oss;\par
3311         oss << std::setprecision(precision) << std::fixed << value;\par
3312         std::string d = oss.str();\par
3313         {\cf18 size_t}      i = d.find_last_not_of({\cf23 '0'});\par
3314         {\cf19 if}(i != std::string::npos && i != d.size() - 1) \{\par
3315             {\cf19 if}(d[i] == {\cf23 '.'})\par
3316                 i++;\par
3317             d = d.substr(0, i + 1);\par
3318         \}\par
3319         {\cf19 return} d.c_str();\par
3320     \}\par
3321 \par
3322     {\cf17 struct }Endianness\par
3323     \{\par
3324         {\cf17 enum} Arch\par
3325         \{\par
3326             Big,\par
3327             Little\par
3328         \};\par
3329 \par
3330         {\cf17 static} Arch which() \{\par
3331             {\cf17 union }_\par
3332             \{\par
3333                 {\cf18 int}  asInt;\par
3334                 {\cf18 char} asChar[{\cf17 sizeof}(int)];\par
3335             \} u;\par
3336 \par
3337             u.asInt = 1;                                            {\cf20 // NOLINT}\par
3338             {\cf19 return} (u.asChar[{\cf17 sizeof}({\cf18 int}) - 1] == 1) ? Big : Little; {\cf20 // NOLINT}\par
3339         \}\par
3340     \};\par
3341 \par
3342     String rawMemoryToString({\cf17 const} {\cf18 void}* {\cf18 object}, {\cf18 unsigned} size) \{\par
3343         {\cf20 // Reverse order for little endian architectures}\par
3344         {\cf18 int} i = 0, end = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(size), inc = 1;\par
3345         {\cf19 if}(Endianness::which() == Endianness::Little) \{\par
3346             i   = end - 1;\par
3347             end = inc = -1;\par
3348         \}\par
3349 \par
3350         {\cf18 unsigned} {\cf18 char} {\cf17 const}* bytes = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char} const*{\cf17 >}(object);\par
3351         std::ostringstream   oss;\par
3352         oss << {\cf22 "0x"} << std::setfill({\cf23 '0'}) << std::hex;\par
3353         {\cf19 for}(; i != end; i += inc)\par
3354             oss << std::setw(2) << {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(bytes[i]);\par
3355         {\cf19 return} oss.str().c_str();\par
3356     \}\par
3357 \par
3358     std::ostream* createStream() \{ {\cf19 return} {\cf17 new} std::ostringstream(); \}\par
3359     String        getStreamResult(std::ostream* s) \{\par
3360         {\cf19 return} {\cf17 static_cast<}std::ostringstream*{\cf17 >}(s)->str().c_str(); {\cf20 // NOLINT}\par
3361     \}\par
3362     {\cf18 void} freeStream(std::ostream* s) \{ {\cf17 delete} s; \}\par
3363 \par
3364 {\cf21 #ifndef DOCTEST_CONFIG_DISABLE}\par
3365 \par
3366     {\cf20 // this holds both parameters for the command line and runtime data for tests}\par
3367     {\cf17 struct }ContextState : TestAccessibleContextState \par
3368     \{\par
3369         {\cf20 // == parameters from the command line}\par
3370 \par
3371         std::vector<std::vector<String> > filters;\par
3372 \par
3373         String   order_by;  {\cf20 // how tests should be ordered}\par
3374         {\cf18 unsigned} rand_seed; {\cf20 // the seed for rand ordering}\par
3375 \par
3376         {\cf18 unsigned} first; {\cf20 // the first (matching) test to be executed}\par
3377         {\cf18 unsigned} last;  {\cf20 // the last (matching) test to be executed}\par
3378 \par
3379         {\cf18 int}  abort_after;           {\cf20 // stop tests after this many failed assertions}\par
3380         {\cf18 int}  subcase_filter_levels; {\cf20 // apply the subcase filters for the first N levels}\par
3381         {\cf18 bool} case_sensitive;        {\cf20 // if filtering should be case sensitive}\par
3382         {\cf18 bool} exit;          {\cf20 // if the program should be exited after the tests are ran/whatever}\par
3383         {\cf18 bool} duration;      {\cf20 // print the time duration of each test case}\par
3384         {\cf18 bool} no_exitcode;   {\cf20 // if the framework should return 0 as the exitcode}\par
3385         {\cf18 bool} no_run;        {\cf20 // to not run the tests at all (can be done with an "*" exclude)}\par
3386         {\cf18 bool} no_version;    {\cf20 // to not print the version of the framework}\par
3387         {\cf18 bool} no_colors;     {\cf20 // if output to the console should be colorized}\par
3388         {\cf18 bool} force_colors;  {\cf20 // forces the use of colors even when a tty cannot be detected}\par
3389         {\cf18 bool} no_breaks;     {\cf20 // to not break into the debugger}\par
3390         {\cf18 bool} no_skip;       {\cf20 // don't skip test cases which are marked to be skipped}\par
3391         {\cf18 bool} gnu_file_line; {\cf20 // if line numbers should be surrounded with :x: and not (x):}\par
3392         {\cf18 bool} no_path_in_filenames; {\cf20 // if the path to files should be removed from the output}\par
3393         {\cf18 bool} no_line_numbers;      {\cf20 // if source code line numbers should be omitted from the output}\par
3394         {\cf18 bool} no_skipped_summary;   {\cf20 // don't print "skipped" in the summary !!! UNDOCUMENTED !!!}\par
3395 \par
3396         {\cf18 bool} help;             {\cf20 // to print the help}\par
3397         {\cf18 bool} version;          {\cf20 // to print the version}\par
3398         {\cf18 bool} count;            {\cf20 // if only the count of matching tests is to be retreived}\par
3399         {\cf18 bool} list_test_cases;  {\cf20 // to list all tests matching the filters}\par
3400         {\cf18 bool} list_test_suites; {\cf20 // to list all suites matching the filters}\par
3401 \par
3402         {\cf20 // == data for the tests being ran}\par
3403 \par
3404         {\cf18 unsigned}        numTestsPassingFilters;\par
3405         {\cf18 unsigned}        numTestSuitesPassingFilters;\par
3406         {\cf18 unsigned}        numFailed;\par
3407         {\cf17 const} TestCase* currentTest;\par
3408         {\cf18 bool}            hasLoggedCurrentTestStart;\par
3409         {\cf18 int}             numAssertionsForCurrentTestcase;\par
3410         {\cf18 int}             numAssertions;\par
3411         {\cf18 int}             numFailedAssertionsForCurrentTestcase;\par
3412         {\cf18 int}             numFailedAssertions;\par
3413         {\cf18 bool}            hasCurrentTestFailed;\par
3414 \par
3415         std::vector<IContextScope*> contexts;            {\cf20 // for logging with INFO() and friends}\par
3416         std::vector<std::string>    exceptionalContexts; {\cf20 // logging from INFO() due to an exception}\par
3417 \par
3418         {\cf20 // stuff for subcases}\par
3419         std::set<SubcaseSignature> subcasesPassed;\par
3420         std::set<int>              subcasesEnteredLevels;\par
3421         std::vector<Subcase>       subcasesStack;\par
3422         {\cf18 int}                        subcasesCurrentLevel;\par
3423         {\cf18 bool}                       subcasesHasSkipped;\par
3424 \par
3425         {\cf18 void} resetRunData() \{\par
3426             numTestsPassingFilters                = 0;\par
3427             numTestSuitesPassingFilters           = 0;\par
3428             numFailed                             = 0;\par
3429             numAssertions                         = 0;\par
3430             numFailedAssertions                   = 0;\par
3431             numFailedAssertionsForCurrentTestcase = 0;\par
3432         \}\par
3433 \par
3434         {\cf20 // cppcheck-suppress uninitMemberVar}\par
3435         ContextState()\par
3436                 : filters(8) {\cf20 // 8 different filters total}\par
3437         \{\par
3438             resetRunData();\par
3439         \}\par
3440     \};\par
3441 \par
3442     ContextState* contextState = 0;\par
3443 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
3444 \} {\cf20 // namespace detail}\par
3445 \par
3446 {\cf18 void} String::copy({\cf17 const} String& other) \{\par
3447     {\cf19 if}(other.isOnStack()) \{\par
3448         memcpy(buf, other.buf, len);\par
3449     \} {\cf19 else} \{\par
3450         setOnHeap();\par
3451         data.size     = other.data.size;\par
3452         data.capacity = data.size + 1;\par
3453         data.ptr      = {\cf17 new} {\cf18 char}[data.capacity];\par
3454         memcpy(data.ptr, other.data.ptr, data.size + 1);\par
3455     \}\par
3456 \}\par
3457 \par
3458 String::String({\cf17 const} {\cf18 char}* in) \{\par
3459     {\cf18 unsigned} in_len = strlen(in);\par
3460     {\cf19 if}(in_len <= last) \{\par
3461         memcpy(buf, in, in_len + 1);\par
3462         setLast(last - in_len);\par
3463     \} {\cf19 else} \{\par
3464         setOnHeap();\par
3465         data.size     = in_len;\par
3466         data.capacity = data.size + 1;\par
3467         data.ptr      = {\cf17 new} {\cf18 char}[data.capacity];\par
3468         memcpy(data.ptr, in, in_len + 1);\par
3469     \}\par
3470 \}\par
3471 \par
3472 String& String::operator+=({\cf17 const} String& other) \{\par
3473     {\cf17 const} {\cf18 unsigned} my_old_size = size();\par
3474     {\cf17 const} {\cf18 unsigned} other_size  = other.size();\par
3475     {\cf17 const} {\cf18 unsigned} total_size  = my_old_size + other_size;\par
3476     {\cf19 if}(isOnStack()) \{\par
3477         {\cf19 if}(total_size < len) \{\par
3478             {\cf20 // append to the current stack space}\par
3479             memcpy(buf + my_old_size, other.c_str(), other_size + 1);\par
3480             setLast(last - total_size);\par
3481         \} {\cf19 else} \{\par
3482             {\cf20 // alloc new chunk}\par
3483             {\cf18 char}* temp = {\cf17 new} {\cf18 char}[total_size + 1];\par
3484             {\cf20 // copy current data to new location before writing in the union}\par
3485             memcpy(temp, buf, my_old_size); {\cf20 // skip the +1 ('\\0') for speed}\par
3486             {\cf20 // update data in union}\par
3487             setOnHeap();\par
3488             data.size     = total_size;\par
3489             data.capacity = data.size + 1;\par
3490             data.ptr      = temp;\par
3491             {\cf20 // transfer the rest of the data}\par
3492             memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\par
3493         \}\par
3494     \} {\cf19 else} \{\par
3495         {\cf19 if}(data.capacity > total_size) \{\par
3496             {\cf20 // append to the current heap block}\par
3497             data.size = total_size;\par
3498             memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\par
3499         \} {\cf19 else} \{\par
3500             {\cf20 // resize}\par
3501             data.capacity *= 2;\par
3502             {\cf19 if}(data.capacity <= total_size)\par
3503                 data.capacity = total_size + 1;\par
3504             {\cf20 // alloc new chunk}\par
3505             {\cf18 char}* temp = {\cf17 new} {\cf18 char}[data.capacity];\par
3506             {\cf20 // copy current data to new location before releasing it}\par
3507             memcpy(temp, data.ptr, my_old_size); {\cf20 // skip the +1 ('\\0') for speed}\par
3508             {\cf20 // release old chunk}\par
3509             {\cf17 delete}[] data.ptr;\par
3510             {\cf20 // update the rest of the union members}\par
3511             data.size = total_size;\par
3512             data.ptr  = temp;\par
3513             {\cf20 // transfer the rest of the data}\par
3514             memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\par
3515         \}\par
3516     \}\par
3517 \par
3518     {\cf19 return} *{\cf17 this};\par
3519 \}\par
3520 \par
3521 {\cf21 #ifdef DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
3522 String::String(String&& other) \{\par
3523     memcpy(buf, other.buf, len);\par
3524     other.buf[0] = {\cf23 '\\0'};\par
3525     other.setLast();\par
3526 \}\par
3527 \par
3528 String& String::operator=(String&& other) \{\par
3529     {\cf19 if}({\cf17 this} != &other) \{\par
3530         {\cf19 if}(!isOnStack())\par
3531             {\cf17 delete}[] data.ptr;\par
3532         memcpy(buf, other.buf, len);\par
3533         other.buf[0] = {\cf23 '\\0'};\par
3534         other.setLast();\par
3535     \}\par
3536     {\cf19 return} *{\cf17 this};\par
3537 \}\par
3538 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_RVALUE_REFERENCES}\par
3539 \par
3540 {\cf18 int} String::compare({\cf17 const} {\cf18 char}* other, {\cf18 bool} no_case){\cf17  const }\{\par
3541     {\cf19 if}(no_case)\par
3542         {\cf19 return} detail::stricmp(c_str(), other);\par
3543     {\cf19 return} std::strcmp(c_str(), other);\par
3544 \}\par
3545 \par
3546 {\cf18 int} String::compare({\cf17 const} String& other, {\cf18 bool} no_case){\cf17  const }\{\par
3547     {\cf19 return} compare(other.c_str(), no_case);\par
3548 \}\par
3549 \par
3550 std::ostream& operator<<(std::ostream& s, {\cf17 const} String& in) \{ {\cf19 return} s << in.c_str(); \}\par
3551 \par
3552 Approx::Approx({\cf18 double} value)\par
3553         : m_epsilon({\cf17 static_cast<}{\cf18 double}{\cf17 >}(std::numeric_limits<float>::epsilon()) * 100)\par
3554         , m_scale(1.0)\par
3555         , m_value(value) \{\}\par
3556 \par
3557 {\cf18 bool} operator==({\cf18 double} lhs, Approx {\cf17 const}& rhs) \{\par
3558     {\cf20 // Thanks to Richard Harris for his help refining this formula}\par
3559     {\cf19 return} std::fabs(lhs - rhs.m_value) <\par
3560            rhs.m_epsilon * (rhs.m_scale + std::max(std::fabs(lhs), std::fabs(rhs.m_value)));\par
3561 \}\par
3562 \par
3563 String Approx::toString(){\cf17  const }\{ {\cf19 return} String({\cf22 "Approx( "}) + doctest::toString(m_value) + {\cf22 " )"}; \}\par
3564 \par
3565 {\cf21 #ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
3566 String toString({\cf18 char}* in) \{ {\cf19 return} toString({\cf17 static_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(in)); \}\par
3567 String toString({\cf17 const} {\cf18 char}* in) \{ {\cf19 return} String({\cf22 "\\""}) + (in ? in : {\cf22 "\{null string\}"}) + {\cf22 "\\""}; \}\par
3568 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
3569 String toString({\cf18 bool} in) \{ {\cf19 return} in ? {\cf22 "true"} : {\cf22 "false"}; \}\par
3570 String toString({\cf18 float} in) \{ {\cf19 return} detail::fpToString(in, 5) + {\cf22 "f"}; \}\par
3571 String toString({\cf18 double} in) \{ {\cf19 return} detail::fpToString(in, 10); \}\par
3572 String toString({\cf18 double} {\cf18 long} in) \{ {\cf19 return} detail::fpToString(in, 15); \}\par
3573 \par
3574 String toString({\cf18 char} in) \{\par
3575     {\cf18 char} buf[64];\par
3576     std::sprintf(buf, {\cf22 "%d"}, in);\par
3577     {\cf19 return} buf;\par
3578 \}\par
3579 \par
3580 String toString({\cf18 char} {\cf18 signed} in) \{\par
3581     {\cf18 char} buf[64];\par
3582     std::sprintf(buf, {\cf22 "%d"}, in);\par
3583     {\cf19 return} buf;\par
3584 \}\par
3585 \par
3586 String toString({\cf18 char} {\cf18 unsigned} in) \{\par
3587     {\cf18 char} buf[64];\par
3588     std::sprintf(buf, {\cf22 "%ud"}, in);\par
3589     {\cf19 return} buf;\par
3590 \}\par
3591 \par
3592 String toString({\cf18 int} {\cf18 short} in) \{\par
3593     {\cf18 char} buf[64];\par
3594     std::sprintf(buf, {\cf22 "%d"}, in);\par
3595     {\cf19 return} buf;\par
3596 \}\par
3597 \par
3598 String toString({\cf18 int} {\cf18 short} {\cf18 unsigned} in) \{\par
3599     {\cf18 char} buf[64];\par
3600     std::sprintf(buf, {\cf22 "%u"}, in);\par
3601     {\cf19 return} buf;\par
3602 \}\par
3603 \par
3604 String toString({\cf18 int} in) \{\par
3605     {\cf18 char} buf[64];\par
3606     std::sprintf(buf, {\cf22 "%d"}, in);\par
3607     {\cf19 return} buf;\par
3608 \}\par
3609 \par
3610 String toString({\cf18 int} {\cf18 unsigned} in) \{\par
3611     {\cf18 char} buf[64];\par
3612     std::sprintf(buf, {\cf22 "%u"}, in);\par
3613     {\cf19 return} buf;\par
3614 \}\par
3615 \par
3616 String toString({\cf18 int} {\cf18 long} in) \{\par
3617     {\cf18 char} buf[64];\par
3618     std::sprintf(buf, {\cf22 "%ld"}, in);\par
3619     {\cf19 return} buf;\par
3620 \}\par
3621 \par
3622 String toString({\cf18 int} {\cf18 long} {\cf18 unsigned} in) \{\par
3623     {\cf18 char} buf[64];\par
3624     std::sprintf(buf, {\cf22 "%lu"}, in);\par
3625     {\cf19 return} buf;\par
3626 \}\par
3627 \par
3628 {\cf21 #ifdef DOCTEST_CONFIG_WITH_LONG_LONG}\par
3629 String toString({\cf18 int} {\cf18 long} {\cf18 long} in) \{\par
3630     {\cf18 char} buf[64];\par
3631     std::sprintf(buf, {\cf22 "%lld"}, in);\par
3632     {\cf19 return} buf;\par
3633 \}\par
3634 String toString({\cf18 int} {\cf18 long} {\cf18 long} {\cf18 unsigned} in) \{\par
3635     {\cf18 char} buf[64];\par
3636     std::sprintf(buf, {\cf22 "%llu"}, in);\par
3637     {\cf19 return} buf;\par
3638 \}\par
3639 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
3640 \par
3641 {\cf21 #ifdef DOCTEST_CONFIG_WITH_NULLPTR}\par
3642 String toString(std::nullptr_t) \{ {\cf19 return} {\cf22 "nullptr"}; \}\par
3643 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_NULLPTR}\par
3644 \par
3645 \} {\cf20 // namespace doctest}\par
3646 \par
3647 {\cf21 #ifdef DOCTEST_CONFIG_DISABLE}\par
3648 {\cf17 namespace }doctest\par
3649 \{\par
3650 {\cf18 bool} isRunningInTest() \{ {\cf19 return} {\cf17 false}; \}\par
3651 Context::Context({\cf18 int}, {\cf17 const} {\cf18 char}* {\cf17 const}*) \{\}\par
3652 Context::~Context() \{\}\par
3653 {\cf18 void} Context::applyCommandLine({\cf18 int}, {\cf17 const} {\cf18 char}* {\cf17 const}*) \{\}\par
3654 {\cf18 void} Context::addFilter({\cf17 const} {\cf18 char}*, {\cf17 const} {\cf18 char}*) \{\}\par
3655 {\cf18 void} Context::clearFilters() \{\}\par
3656 {\cf18 void} Context::setOption({\cf17 const} {\cf18 char}*, {\cf18 int}) \{\}\par
3657 {\cf18 void} Context::setOption({\cf17 const} {\cf18 char}*, {\cf17 const} {\cf18 char}*) \{\}\par
3658 {\cf18 bool} Context::shouldExit() \{ {\cf19 return} {\cf17 false}; \}\par
3659 {\cf18 int}  Context::run() \{ {\cf19 return} 0; \}\par
3660 \} {\cf20 // namespace doctest}\par
3661 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
3662 \par
3663 {\cf21 #if !defined(DOCTEST_CONFIG_COLORS_NONE)}\par
3664 {\cf21 #if !defined(DOCTEST_CONFIG_COLORS_WINDOWS) && !defined(DOCTEST_CONFIG_COLORS_ANSI)}\par
3665 {\cf21 #ifdef DOCTEST_PLATFORM_WINDOWS}\par
3666 {\cf21 #define DOCTEST_CONFIG_COLORS_WINDOWS}\par
3667 {\cf21 #else }{\cf20 // linux}\par
3668 {\cf21 #define DOCTEST_CONFIG_COLORS_ANSI}\par
3669 {\cf21 #endif }{\cf20 // platform}\par
3670 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_WINDOWS && DOCTEST_CONFIG_COLORS_ANSI}\par
3671 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_NONE}\par
3672 \par
3673 {\cf21 #if DOCTEST_MSVC || defined(__MINGW32__)}\par
3674 {\cf21 #if DOCTEST_MSVC >= DOCTEST_COMPILER(17, 0, 0)}\par
3675 {\cf21 #define DOCTEST_WINDOWS_SAL_IN_OPT _In_opt_}\par
3676 {\cf21 #else }{\cf20 // MSVC}\par
3677 {\cf21 #define DOCTEST_WINDOWS_SAL_IN_OPT}\par
3678 {\cf21 #endif }{\cf20 // MSVC}\par
3679 {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 void} __stdcall OutputDebugStringA(\par
3680         DOCTEST_WINDOWS_SAL_IN_OPT {\cf17 const} {\cf18 char}*);\par
3681 {\cf17 extern} {\cf22 "C"} __declspec(dllimport) {\cf18 int} __stdcall IsDebuggerPresent();\par
3682 {\cf21 #endif }{\cf20 // MSVC || __MINGW32__}\par
3683 \par
3684 {\cf21 #ifdef DOCTEST_CONFIG_COLORS_ANSI}\par
3685 {\cf21 #include <unistd.h>}\par
3686 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_ANSI}\par
3687 \par
3688 {\cf21 #ifdef DOCTEST_PLATFORM_WINDOWS}\par
3689 \par
3690 {\cf20 // defines for a leaner windows.h}\par
3691 {\cf21 #ifndef WIN32_LEAN_AND_MEAN}\par
3692 {\cf21 #define WIN32_LEAN_AND_MEAN}\par
3693 {\cf21 #endif }{\cf20 // WIN32_LEAN_AND_MEAN}\par
3694 {\cf21 #ifndef VC_EXTRA_LEAN}\par
3695 {\cf21 #define VC_EXTRA_LEAN}\par
3696 {\cf21 #endif }{\cf20 // VC_EXTRA_LEAN}\par
3697 {\cf21 #ifndef NOMINMAX}\par
3698 {\cf21 #define NOMINMAX}\par
3699 {\cf21 #endif }{\cf20 // NOMINMAX}\par
3700 \par
3701 DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN\par
3702 \par
3703 {\cf20 // not sure what AfxWin.h is for - here I do what Catch does}\par
3704 {\cf21 #ifdef __AFXDLL}\par
3705 {\cf21 #include <AfxWin.h>}\par
3706 {\cf21 #else}\par
3707 {\cf21 #include <windows.h>}\par
3708 {\cf21 #endif}\par
3709 {\cf21 #include <io.h>}\par
3710 \par
3711 DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END\par
3712 \par
3713 {\cf21 #else }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
3714 \par
3715 {\cf21 #include <sys/time.h>}\par
3716 \par
3717 {\cf21 #endif }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
3718 \par
3719 {\cf17 namespace }doctest_detail_test_suite_ns\par
3720 \{\par
3721 {\cf20 // holds the current test suite}\par
3722 doctest::detail::TestSuite& getCurrentTestSuite() \{\par
3723     {\cf17 static} doctest::detail::TestSuite data;\par
3724     {\cf19 return} data;\par
3725 \}\par
3726 \} {\cf20 // namespace doctest_detail_test_suite_ns}\par
3727 \par
3728 {\cf17 namespace }doctest\par
3729 \{\par
3730 {\cf17 namespace }detail\par
3731 \{\par
3732     TestCase::TestCase(funcType test, {\cf17 const} {\cf18 char}* file, {\cf18 unsigned} line, {\cf17 const} TestSuite& test_suite,\par
3733                        {\cf17 const} {\cf18 char}* type, {\cf18 int} template_id)\par
3734             : m_test(test)\par
3735             , m_name(0)\par
3736             , m_type(type)\par
3737             , m_test_suite(test_suite.m_test_suite)\par
3738             , m_description(test_suite.m_description)\par
3739             , m_skip(test_suite.m_skip)\par
3740             , m_may_fail(test_suite.m_may_fail)\par
3741             , m_should_fail(test_suite.m_should_fail)\par
3742             , m_expected_failures(test_suite.m_expected_failures)\par
3743             , m_timeout(test_suite.m_timeout)\par
3744             , m_file(file)\par
3745             , m_line(line)\par
3746             , m_template_id(template_id) \{\}\par
3747 \par
3748     TestCase& TestCase::operator*({\cf17 const} {\cf18 char}* in) \{\par
3749         m_name = in;\par
3750         {\cf20 // make a new name with an appended type for templated test case}\par
3751         {\cf19 if}(m_template_id != -1) \{\par
3752             m_full_name = String(m_name) + m_type;\par
3753             {\cf20 // redirect the name to point to the newly constructed full name}\par
3754             m_name = m_full_name.c_str();\par
3755         \}\par
3756         {\cf19 return} *{\cf17 this};\par
3757     \}\par
3758 \par
3759     TestCase& TestCase::operator=({\cf17 const} TestCase& other) \{\par
3760         m_test              = other.m_test;\par
3761         m_full_name         = other.m_full_name;\par
3762         m_name              = other.m_name;\par
3763         m_type              = other.m_type;\par
3764         m_test_suite        = other.m_test_suite;\par
3765         m_description       = other.m_description;\par
3766         m_skip              = other.m_skip;\par
3767         m_may_fail          = other.m_may_fail;\par
3768         m_should_fail       = other.m_should_fail;\par
3769         m_expected_failures = other.m_expected_failures;\par
3770         m_timeout           = other.m_timeout;\par
3771         m_file              = other.m_file;\par
3772         m_line              = other.m_line;\par
3773         m_template_id       = other.m_template_id;\par
3774 \par
3775         {\cf19 if}(m_template_id != -1)\par
3776             m_name = m_full_name.c_str();\par
3777         {\cf19 return} *{\cf17 this};\par
3778     \}\par
3779 \par
3780     {\cf18 bool} TestCase::operator<({\cf17 const} TestCase& other){\cf17  const }\{\par
3781         {\cf19 if}(m_line != other.m_line)\par
3782             {\cf19 return} m_line < other.m_line;\par
3783         {\cf17 const} {\cf18 int} file_cmp = std::strcmp(m_file, other.m_file);\par
3784         {\cf19 if}(file_cmp != 0)\par
3785             {\cf19 return} file_cmp < 0;\par
3786         {\cf19 return} m_template_id < other.m_template_id;\par
3787     \}\par
3788 \par
3789     {\cf17 const} {\cf18 char}* assertString(assertType::Enum val) \{\par
3790         DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(\par
3791                 4062) {\cf20 // enumerator 'x' in switch of enum 'y' is not handled}\par
3792         switch(val) \{ \par
3793             {\cf20 // clang-format off}\par
3794             {\cf19 case} assertType::DT_WARN                    : {\cf19 return} {\cf22 "WARN"};\par
3795             {\cf19 case} assertType::DT_CHECK                   : {\cf19 return} {\cf22 "CHECK"};\par
3796             {\cf19 case} assertType::DT_REQUIRE                 : {\cf19 return} {\cf22 "REQUIRE"};\par
3797 \par
3798             {\cf19 case} assertType::DT_WARN_FALSE              : {\cf19 return} {\cf22 "WARN_FALSE"};\par
3799             {\cf19 case} assertType::DT_CHECK_FALSE             : {\cf19 return} {\cf22 "CHECK_FALSE"};\par
3800             {\cf19 case} assertType::DT_REQUIRE_FALSE           : {\cf19 return} {\cf22 "REQUIRE_FALSE"};\par
3801 \par
3802             {\cf19 case} assertType::DT_WARN_THROWS             : {\cf19 return} {\cf22 "WARN_THROWS"};\par
3803             {\cf19 case} assertType::DT_CHECK_THROWS            : {\cf19 return} {\cf22 "CHECK_THROWS"};\par
3804             {\cf19 case} assertType::DT_REQUIRE_THROWS          : {\cf19 return} {\cf22 "REQUIRE_THROWS"};\par
3805 \par
3806             {\cf19 case} assertType::DT_WARN_THROWS_AS          : {\cf19 return} {\cf22 "WARN_THROWS_AS"};\par
3807             {\cf19 case} assertType::DT_CHECK_THROWS_AS         : {\cf19 return} {\cf22 "CHECK_THROWS_AS"};\par
3808             {\cf19 case} assertType::DT_REQUIRE_THROWS_AS       : {\cf19 return} {\cf22 "REQUIRE_THROWS_AS"};\par
3809 \par
3810             {\cf19 case} assertType::DT_WARN_NOTHROW            : {\cf19 return} {\cf22 "WARN_NOTHROW"};\par
3811             {\cf19 case} assertType::DT_CHECK_NOTHROW           : {\cf19 return} {\cf22 "CHECK_NOTHROW"};\par
3812             {\cf19 case} assertType::DT_REQUIRE_NOTHROW         : {\cf19 return} {\cf22 "REQUIRE_NOTHROW"};\par
3813 \par
3814             {\cf19 case} assertType::DT_WARN_EQ                 : {\cf19 return} {\cf22 "WARN_EQ"};\par
3815             {\cf19 case} assertType::DT_CHECK_EQ                : {\cf19 return} {\cf22 "CHECK_EQ"};\par
3816             {\cf19 case} assertType::DT_REQUIRE_EQ              : {\cf19 return} {\cf22 "REQUIRE_EQ"};\par
3817             {\cf19 case} assertType::DT_WARN_NE                 : {\cf19 return} {\cf22 "WARN_NE"};\par
3818             {\cf19 case} assertType::DT_CHECK_NE                : {\cf19 return} {\cf22 "CHECK_NE"};\par
3819             {\cf19 case} assertType::DT_REQUIRE_NE              : {\cf19 return} {\cf22 "REQUIRE_NE"};\par
3820             {\cf19 case} assertType::DT_WARN_GT                 : {\cf19 return} {\cf22 "WARN_GT"};\par
3821             {\cf19 case} assertType::DT_CHECK_GT                : {\cf19 return} {\cf22 "CHECK_GT"};\par
3822             {\cf19 case} assertType::DT_REQUIRE_GT              : {\cf19 return} {\cf22 "REQUIRE_GT"};\par
3823             {\cf19 case} assertType::DT_WARN_LT                 : {\cf19 return} {\cf22 "WARN_LT"};\par
3824             {\cf19 case} assertType::DT_CHECK_LT                : {\cf19 return} {\cf22 "CHECK_LT"};\par
3825             {\cf19 case} assertType::DT_REQUIRE_LT              : {\cf19 return} {\cf22 "REQUIRE_LT"};\par
3826             {\cf19 case} assertType::DT_WARN_GE                 : {\cf19 return} {\cf22 "WARN_GE"};\par
3827             {\cf19 case} assertType::DT_CHECK_GE                : {\cf19 return} {\cf22 "CHECK_GE"};\par
3828             {\cf19 case} assertType::DT_REQUIRE_GE              : {\cf19 return} {\cf22 "REQUIRE_GE"};\par
3829             {\cf19 case} assertType::DT_WARN_LE                 : {\cf19 return} {\cf22 "WARN_LE"};\par
3830             {\cf19 case} assertType::DT_CHECK_LE                : {\cf19 return} {\cf22 "CHECK_LE"};\par
3831             {\cf19 case} assertType::DT_REQUIRE_LE              : {\cf19 return} {\cf22 "REQUIRE_LE"};\par
3832 \par
3833             {\cf19 case} assertType::DT_WARN_UNARY              : {\cf19 return} {\cf22 "WARN_UNARY"};\par
3834             {\cf19 case} assertType::DT_CHECK_UNARY             : {\cf19 return} {\cf22 "CHECK_UNARY"};\par
3835             {\cf19 case} assertType::DT_REQUIRE_UNARY           : {\cf19 return} {\cf22 "REQUIRE_UNARY"};\par
3836             {\cf19 case} assertType::DT_WARN_UNARY_FALSE        : {\cf19 return} {\cf22 "WARN_UNARY_FALSE"};\par
3837             {\cf19 case} assertType::DT_CHECK_UNARY_FALSE       : {\cf19 return} {\cf22 "CHECK_UNARY_FALSE"};\par
3838             {\cf19 case} assertType::DT_REQUIRE_UNARY_FALSE     : {\cf19 return} {\cf22 "REQUIRE_UNARY_FALSE"};\par
3839 \par
3840             {\cf19 case} assertType::DT_FAST_WARN_EQ            : {\cf19 return} {\cf22 "FAST_WARN_EQ"};\par
3841             {\cf19 case} assertType::DT_FAST_CHECK_EQ           : {\cf19 return} {\cf22 "FAST_CHECK_EQ"};\par
3842             {\cf19 case} assertType::DT_FAST_REQUIRE_EQ         : {\cf19 return} {\cf22 "FAST_REQUIRE_EQ"};\par
3843             {\cf19 case} assertType::DT_FAST_WARN_NE            : {\cf19 return} {\cf22 "FAST_WARN_NE"};\par
3844             {\cf19 case} assertType::DT_FAST_CHECK_NE           : {\cf19 return} {\cf22 "FAST_CHECK_NE"};\par
3845             {\cf19 case} assertType::DT_FAST_REQUIRE_NE         : {\cf19 return} {\cf22 "FAST_REQUIRE_NE"};\par
3846             {\cf19 case} assertType::DT_FAST_WARN_GT            : {\cf19 return} {\cf22 "FAST_WARN_GT"};\par
3847             {\cf19 case} assertType::DT_FAST_CHECK_GT           : {\cf19 return} {\cf22 "FAST_CHECK_GT"};\par
3848             {\cf19 case} assertType::DT_FAST_REQUIRE_GT         : {\cf19 return} {\cf22 "FAST_REQUIRE_GT"};\par
3849             {\cf19 case} assertType::DT_FAST_WARN_LT            : {\cf19 return} {\cf22 "FAST_WARN_LT"};\par
3850             {\cf19 case} assertType::DT_FAST_CHECK_LT           : {\cf19 return} {\cf22 "FAST_CHECK_LT"};\par
3851             {\cf19 case} assertType::DT_FAST_REQUIRE_LT         : {\cf19 return} {\cf22 "FAST_REQUIRE_LT"};\par
3852             {\cf19 case} assertType::DT_FAST_WARN_GE            : {\cf19 return} {\cf22 "FAST_WARN_GE"};\par
3853             {\cf19 case} assertType::DT_FAST_CHECK_GE           : {\cf19 return} {\cf22 "FAST_CHECK_GE"};\par
3854             {\cf19 case} assertType::DT_FAST_REQUIRE_GE         : {\cf19 return} {\cf22 "FAST_REQUIRE_GE"};\par
3855             {\cf19 case} assertType::DT_FAST_WARN_LE            : {\cf19 return} {\cf22 "FAST_WARN_LE"};\par
3856             {\cf19 case} assertType::DT_FAST_CHECK_LE           : {\cf19 return} {\cf22 "FAST_CHECK_LE"};\par
3857             {\cf19 case} assertType::DT_FAST_REQUIRE_LE         : {\cf19 return} {\cf22 "FAST_REQUIRE_LE"};\par
3858 \par
3859             {\cf19 case} assertType::DT_FAST_WARN_UNARY         : {\cf19 return} {\cf22 "FAST_WARN_UNARY"};\par
3860             {\cf19 case} assertType::DT_FAST_CHECK_UNARY        : {\cf19 return} {\cf22 "FAST_CHECK_UNARY"};\par
3861             {\cf19 case} assertType::DT_FAST_REQUIRE_UNARY      : {\cf19 return} {\cf22 "FAST_REQUIRE_UNARY"};\par
3862             {\cf19 case} assertType::DT_FAST_WARN_UNARY_FALSE   : {\cf19 return} {\cf22 "FAST_WARN_UNARY_FALSE"};\par
3863             {\cf19 case} assertType::DT_FAST_CHECK_UNARY_FALSE  : {\cf19 return} {\cf22 "FAST_CHECK_UNARY_FALSE"};\par
3864             {\cf19 case} assertType::DT_FAST_REQUIRE_UNARY_FALSE: {\cf19 return} {\cf22 "FAST_REQUIRE_UNARY_FALSE"};\par
3865                 {\cf20 // clang-format on}\par
3866         \}\par
3867         DOCTEST_MSVC_SUPPRESS_WARNING_POP\par
3868         {\cf19 return} {\cf22 ""};\par
3869     \}\par
3870 \par
3871     {\cf18 bool} checkIfShouldThrow(assertType::Enum at) \{\par
3872         {\cf19 if}(at & assertType::is_require) \par
3873             {\cf19 return} {\cf17 true};\par
3874 \par
3875         {\cf19 if}((at & assertType::is_check) \par
3876            && contextState->abort_after > 0 &&\par
3877            contextState->numFailedAssertions >= contextState->abort_after)\par
3878             {\cf19 return} {\cf17 true};\par
3879 \par
3880         {\cf19 return} {\cf17 false};\par
3881     \}\par
3882     {\cf18 void} throwException() \{\par
3883 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
3884         {\cf19 throw} TestFailureException();\par
3885 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
3886     \}\par
3887     {\cf18 void} fastAssertThrowIfFlagSet({\cf18 int} flags) \{\par
3888         {\cf19 if}(flags & assertAction::shouldthrow) \par
3889             throwException();\par
3890     \}\par
3891 \par
3892     {\cf20 // matching of a string against a wildcard mask (case sensitivity configurable) taken from}\par
3893     {\cf20 // https://www.codeproject.com/Articles/1088/Wildcard-string-compare-globbing}\par
3894     {\cf18 int} wildcmp({\cf17 const} {\cf18 char}* str, {\cf17 const} {\cf18 char}* wild, {\cf18 bool} caseSensitive) \{\par
3895         {\cf17 const} {\cf18 char}* cp = 0;\par
3896         {\cf17 const} {\cf18 char}* mp = 0;\par
3897 \par
3898         {\cf19 while}((*str) && (*wild != {\cf23 '*'})) \{\par
3899             {\cf19 if}((caseSensitive ? (*wild != *str) : (tolower(*wild) != tolower(*str))) &&\par
3900                (*wild != {\cf23 '?'})) \{\par
3901                 {\cf19 return} 0;\par
3902             \}\par
3903             wild++;\par
3904             str++;\par
3905         \}\par
3906 \par
3907         {\cf19 while}(*str) \{\par
3908             {\cf19 if}(*wild == {\cf23 '*'}) \{\par
3909                 {\cf19 if}(!*++wild) \{\par
3910                     {\cf19 return} 1;\par
3911                 \}\par
3912                 mp = wild;\par
3913                 cp = str + 1;\par
3914             \} {\cf19 else} {\cf19 if}((caseSensitive ? (*wild == *str) : (tolower(*wild) == tolower(*str))) ||\par
3915                       (*wild == {\cf23 '?'})) \{\par
3916                 wild++;\par
3917                 str++;\par
3918             \} {\cf19 else} \{\par
3919                 wild = mp;   \par
3920                 str  = cp++; \par
3921             \}\par
3922         \}\par
3923 \par
3924         {\cf19 while}(*wild == {\cf23 '*'}) \{\par
3925             wild++;\par
3926         \}\par
3927         {\cf19 return} !*wild;\par
3928     \}\par
3929 \par
3931     {\cf20 //unsigned hashStr(unsigned const char* str) \{}\par
3932     {\cf20 //    unsigned long hash = 5381;}\par
3933     {\cf20 //    char          c;}\par
3934     {\cf20 //    while((c = *str++))}\par
3935     {\cf20 //        hash = ((hash << 5) + hash) + c; // hash * 33 + c}\par
3936     {\cf20 //    return hash;}\par
3937     {\cf20 //\}}\par
3938 \par
3939     {\cf20 // checks if the name matches any of the filters (and can be configured what to do when empty)}\par
3940     {\cf18 bool} matchesAny({\cf17 const} {\cf18 char}* name, {\cf17 const} std::vector<String>& filters, {\cf18 int} matchEmpty,\par
3941                     {\cf18 bool} caseSensitive) \{\par
3942         {\cf19 if}(filters.empty() && matchEmpty)\par
3943             {\cf19 return} {\cf17 true};\par
3944         {\cf19 for}({\cf18 unsigned} i = 0; i < filters.size(); ++i)\par
3945             {\cf19 if}(wildcmp(name, filters[i].c_str(), caseSensitive))\par
3946                 {\cf19 return} {\cf17 true};\par
3947         {\cf19 return} {\cf17 false};\par
3948     \}\par
3949 \par
3950 {\cf21 #ifdef DOCTEST_PLATFORM_WINDOWS}\par
3951 \par
3952     {\cf17 typedef} {\cf18 unsigned} {\cf18 long} {\cf18 long} UInt64;\par
3953 \par
3954     UInt64 getCurrentTicks() \{\par
3955         {\cf17 static} UInt64 hz = 0, hzo = 0;\par
3956         {\cf19 if}(!hz) \{\par
3957             QueryPerformanceFrequency({\cf17 reinterpret_cast<}LARGE_INTEGER*{\cf17 >}(&hz));\par
3958             QueryPerformanceCounter({\cf17 reinterpret_cast<}LARGE_INTEGER*{\cf17 >}(&hzo));\par
3959         \}\par
3960         UInt64 t;\par
3961         QueryPerformanceCounter({\cf17 reinterpret_cast<}LARGE_INTEGER*{\cf17 >}(&t));\par
3962         {\cf19 return} ((t - hzo) * 1000000) / hz;\par
3963     \}\par
3964 {\cf21 #else  }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
3965 \par
3966     {\cf17 typedef} uint64_t UInt64;\par
3967 \par
3968     UInt64 getCurrentTicks() \{\par
3969         timeval t;\par
3970         gettimeofday(&t, 0);\par
3971         {\cf19 return} {\cf17 static_cast<}UInt64{\cf17 >}(t.tv_sec) * 1000000 + {\cf17 static_cast<}UInt64{\cf17 >}(t.tv_usec);\par
3972     \}\par
3973 {\cf21 #endif }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
3974 \par
3975     {\cf17 class }Timer\par
3976     \{\par
3977     {\cf17 public}:\par
3978         Timer()\par
3979                 : m_ticks(0) \{\}\par
3980         {\cf18 void}         start() \{ m_ticks = getCurrentTicks(); \}\par
3981         {\cf18 unsigned} {\cf18 int} getElapsedMicroseconds(){\cf17  const }\{\par
3982             {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getCurrentTicks() - m_ticks);\par
3983         \}\par
3984         {\cf18 unsigned} {\cf18 int} getElapsedMilliseconds(){\cf17  const }\{\par
3985             {\cf19 return} {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(getElapsedMicroseconds() / 1000);\par
3986         \}\par
3987         {\cf18 double} getElapsedSeconds(){\cf17  const }\{ {\cf19 return} getElapsedMicroseconds() / 1000000.0; \}\par
3988 \par
3989     {\cf17 private}:\par
3990         UInt64 m_ticks;\par
3991     \};\par
3992 \par
3993     TestAccessibleContextState* getTestsContextState() \{ {\cf19 return} contextState; \}\par
3994 \par
3995     {\cf20 // TODO: remove this from here}\par
3996     {\cf18 void} logTestEnd();\par
3997 \par
3998     {\cf18 bool} SubcaseSignature::operator<({\cf17 const} SubcaseSignature& other){\cf17  const }\{\par
3999         {\cf19 if}(m_line != other.m_line)\par
4000             {\cf19 return} m_line < other.m_line;\par
4001         {\cf19 if}(std::strcmp(m_file, other.m_file) != 0)\par
4002             {\cf19 return} std::strcmp(m_file, other.m_file) < 0;\par
4003         {\cf19 return} std::strcmp(m_name, other.m_name) < 0;\par
4004     \}\par
4005 \par
4006     Subcase::Subcase({\cf17 const} {\cf18 char}* name, {\cf17 const} {\cf18 char}* file, {\cf18 int} line)\par
4007             : m_signature(name, file, line)\par
4008             , m_entered(false) \{\par
4009         ContextState* s = contextState;\par
4010 \par
4011         {\cf20 // if we have already completed it}\par
4012         {\cf19 if}(s->subcasesPassed.count(m_signature) != 0)\par
4013             {\cf19 return};\par
4014 \par
4015         {\cf20 // check subcase filters}\par
4016         {\cf19 if}(s->subcasesCurrentLevel < s->subcase_filter_levels) \{\par
4017             {\cf19 if}(!matchesAny(m_signature.m_name, s->filters[6], 1, s->case_sensitive))\par
4018                 {\cf19 return};\par
4019             {\cf19 if}(matchesAny(m_signature.m_name, s->filters[7], 0, s->case_sensitive))\par
4020                 {\cf19 return};\par
4021         \}\par
4022 \par
4023         {\cf20 // if a Subcase on the same level has already been entered}\par
4024         {\cf19 if}(s->subcasesEnteredLevels.count(s->subcasesCurrentLevel) != 0) \{\par
4025             s->subcasesHasSkipped = {\cf17 true};\par
4026             {\cf19 return};\par
4027         \}\par
4028 \par
4029         s->subcasesStack.push_back(*{\cf17 this});\par
4030         {\cf19 if}(s->hasLoggedCurrentTestStart)\par
4031             logTestEnd();\par
4032         s->hasLoggedCurrentTestStart = {\cf17 false};\par
4033 \par
4034         s->subcasesEnteredLevels.insert(s->subcasesCurrentLevel++);\par
4035         m_entered = {\cf17 true};\par
4036     \}\par
4037 \par
4038     Subcase::Subcase({\cf17 const} Subcase& other)\par
4039             : m_signature(other.m_signature.m_name, other.m_signature.m_file,\par
4040                           other.m_signature.m_line)\par
4041             , m_entered(other.m_entered) \{\}\par
4042 \par
4043     Subcase::~Subcase() \{\par
4044         {\cf19 if}(m_entered) \{\par
4045             ContextState* s = contextState;\par
4046 \par
4047             s->subcasesCurrentLevel--;\par
4048             {\cf20 // only mark the subcase as passed if no subcases have been skipped}\par
4049             {\cf19 if}(s->subcasesHasSkipped == {\cf17 false})\par
4050                 s->subcasesPassed.insert(m_signature);\par
4051 \par
4052             {\cf19 if}(!s->subcasesStack.empty())\par
4053                 s->subcasesStack.pop_back();\par
4054             {\cf19 if}(s->hasLoggedCurrentTestStart)\par
4055                 logTestEnd();\par
4056             s->hasLoggedCurrentTestStart = {\cf17 false};\par
4057         \}\par
4058     \}\par
4059 \par
4060     Result::~Result() \{\}\par
4061 \par
4062     Result& Result::operator=({\cf17 const} Result& other) \{\par
4063         m_passed        = other.m_passed;\par
4064         m_decomposition = other.m_decomposition;\par
4065 \par
4066         {\cf19 return} *{\cf17 this};\par
4067     \}\par
4068 \par
4069     {\cf20 // for sorting tests by file/line}\par
4070     {\cf18 int} fileOrderComparator({\cf17 const} {\cf18 void}* a, {\cf17 const} {\cf18 void}* b) \{\par
4071         {\cf17 const} TestCase* lhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(a);\par
4072         {\cf17 const} TestCase* rhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(b);\par
4073 {\cf21 #if DOCTEST_MSVC}\par
4074         {\cf20 // this is needed because MSVC gives different case for drive letters}\par
4075         {\cf20 // for __FILE__ when evaluated in a header and a source file}\par
4076         {\cf17 const} {\cf18 int} res = stricmp(lhs->m_file, rhs->m_file);\par
4077 {\cf21 #else  }{\cf20 // MSVC}\par
4078         {\cf17 const} {\cf18 int} res = std::strcmp(lhs->m_file, rhs->m_file);\par
4079 {\cf21 #endif }{\cf20 // MSVC}\par
4080         {\cf19 if}(res != 0)\par
4081             {\cf19 return} res;\par
4082         {\cf19 return} {\cf17 static_cast<}{\cf18 int}{\cf17 >}(lhs->m_line - rhs->m_line);\par
4083     \}\par
4084 \par
4085     {\cf20 // for sorting tests by suite/file/line}\par
4086     {\cf18 int} suiteOrderComparator({\cf17 const} {\cf18 void}* a, {\cf17 const} {\cf18 void}* b) \{\par
4087         {\cf17 const} TestCase* lhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(a);\par
4088         {\cf17 const} TestCase* rhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(b);\par
4089 \par
4090         {\cf17 const} {\cf18 int} res = std::strcmp(lhs->m_test_suite, rhs->m_test_suite);\par
4091         {\cf19 if}(res != 0)\par
4092             {\cf19 return} res;\par
4093         {\cf19 return} fileOrderComparator(a, b);\par
4094     \}\par
4095 \par
4096     {\cf20 // for sorting tests by name/suite/file/line}\par
4097     {\cf18 int} nameOrderComparator({\cf17 const} {\cf18 void}* a, {\cf17 const} {\cf18 void}* b) \{\par
4098         {\cf17 const} TestCase* lhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(a);\par
4099         {\cf17 const} TestCase* rhs = *{\cf17 static_cast<}TestCase* const*{\cf17 >}(b);\par
4100 \par
4101         {\cf17 const} {\cf18 int} res_name = std::strcmp(lhs->m_name, rhs->m_name);\par
4102         {\cf19 if}(res_name != 0)\par
4103             {\cf19 return} res_name;\par
4104         {\cf19 return} suiteOrderComparator(a, b);\par
4105     \}\par
4106 \par
4107     {\cf20 // sets the current test suite}\par
4108     {\cf18 int} setTestSuite({\cf17 const} TestSuite& ts) \{\par
4109         doctest_detail_test_suite_ns::getCurrentTestSuite() = ts;\par
4110         {\cf19 return} 0;\par
4111     \}\par
4112 \par
4113     {\cf20 // all the registered tests}\par
4114     std::set<TestCase>& getRegisteredTests() \{\par
4115         {\cf17 static} std::set<TestCase> data;\par
4116         {\cf19 return} data;\par
4117     \}\par
4118 \par
4119     {\cf20 // used by the macros for registering tests}\par
4120     {\cf18 int} regTest({\cf17 const} TestCase& tc) \{\par
4121         getRegisteredTests().insert(tc);\par
4122         {\cf19 return} 0;\par
4123     \}\par
4124 \par
4125     {\cf17 namespace }Color\par
4126     \{\par
4127         {\cf17 enum} Code\par
4128         \{\par
4129             None = 0,\par
4130             White,\par
4131             Red,\par
4132             Green,\par
4133             Blue,\par
4134             Cyan,\par
4135             Yellow,\par
4136             Grey,\par
4137 \par
4138             Bright = 0x10,\par
4139 \par
4140             BrightRed   = Bright | Red,\par
4141             BrightGreen = Bright | Green,\par
4142             LightGrey   = Bright | Grey,\par
4143             BrightWhite = Bright | White\par
4144         \};\par
4145 \par
4146 {\cf21 #ifdef DOCTEST_CONFIG_COLORS_WINDOWS}\par
4147         HANDLE g_stdoutHandle;\par
4148         WORD   g_originalForegroundAttributes;\par
4149         WORD   g_originalBackgroundAttributes;\par
4150         {\cf18 bool}   g_attrsInitted = {\cf17 false};\par
4151 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_WINDOWS}\par
4152 \par
4153         {\cf18 void} init() \{\par
4154 {\cf21 #ifdef DOCTEST_CONFIG_COLORS_WINDOWS}\par
4155             {\cf19 if}(!g_attrsInitted) \{\par
4156                 g_stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);\par
4157                 g_attrsInitted = {\cf17 true};\par
4158                 CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\par
4159                 GetConsoleScreenBufferInfo(g_stdoutHandle, &csbiInfo);\par
4160                 g_originalForegroundAttributes =\par
4161                         csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED |\par
4162                                                  BACKGROUND_BLUE | BACKGROUND_INTENSITY);\par
4163                 g_originalBackgroundAttributes =\par
4164                         csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED |\par
4165                                                  FOREGROUND_BLUE | FOREGROUND_INTENSITY);\par
4166             \}\par
4167 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_WINDOWS}\par
4168         \}\par
4169 \par
4170         std::ostream& operator<<(std::ostream&            s, Color::Code\par
4171 #ifndef DOCTEST_CONFIG_COLORS_NONE\par
4172                                                           code\par
4173 #endif {\cf20 // DOCTEST_CONFIG_COLORS_NONE}\par
4174         ) \{\par
4175             {\cf17 const} ContextState* p = contextState;\par
4176             {\cf19 if}(p->no_colors)\par
4177                 {\cf19 return} s;\par
4178 {\cf21 #ifdef DOCTEST_CONFIG_COLORS_ANSI}\par
4179             {\cf19 if}(isatty(STDOUT_FILENO) == {\cf17 false} && p->force_colors == {\cf17 false})\par
4180                 {\cf19 return} s;\par
4181 \par
4182             {\cf17 const} {\cf18 char}* col = {\cf22 ""};\par
4183             {\cf20 // clang-format off}\par
4184             {\cf19 switch}(code) \{ \par
4185                 {\cf19 case} Color::Red:         col = {\cf22 "[0;31m"}; {\cf19 break};\par
4186                 {\cf19 case} Color::Green:       col = {\cf22 "[0;32m"}; {\cf19 break};\par
4187                 {\cf19 case} Color::Blue:        col = {\cf22 "[0;34m"}; {\cf19 break};\par
4188                 {\cf19 case} Color::Cyan:        col = {\cf22 "[0;36m"}; {\cf19 break};\par
4189                 {\cf19 case} Color::Yellow:      col = {\cf22 "[0;33m"}; {\cf19 break};\par
4190                 {\cf19 case} Color::Grey:        col = {\cf22 "[1;30m"}; {\cf19 break};\par
4191                 {\cf19 case} Color::LightGrey:   col = {\cf22 "[0;37m"}; {\cf19 break};\par
4192                 {\cf19 case} Color::BrightRed:   col = {\cf22 "[1;31m"}; {\cf19 break};\par
4193                 {\cf19 case} Color::BrightGreen: col = {\cf22 "[1;32m"}; {\cf19 break};\par
4194                 {\cf19 case} Color::BrightWhite: col = {\cf22 "[1;37m"}; {\cf19 break};\par
4195                 {\cf19 case} Color::Bright: {\cf20 // invalid}\par
4196                 {\cf19 case} Color::None:\par
4197                 {\cf19 case} Color::White:\par
4198                 {\cf19 default}:                 col = {\cf22 "[0m"};\par
4199             \}\par
4200             {\cf20 // clang-format on}\par
4201             s << {\cf22 "\\033"} << col;\par
4202 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_ANSI}\par
4203 \par
4204 {\cf21 #ifdef DOCTEST_CONFIG_COLORS_WINDOWS}\par
4205             {\cf19 if}(isatty(fileno(stdout)) == {\cf17 false} && p->force_colors == {\cf17 false})\par
4206                 {\cf19 return} s;\par
4207 \par
4208 {\cf21 #define DOCTEST_SET_ATTR(x)                                                                        \\}\par
4209 {\cf21     SetConsoleTextAttribute(g_stdoutHandle, x | g_originalBackgroundAttributes)}\par
4210 \par
4211             {\cf20 // clang-format off}\par
4212             {\cf19 switch} (code) \{\par
4213                 {\cf19 case} Color::White:       DOCTEST_SET_ATTR(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); {\cf19 break};\par
4214                 {\cf19 case} Color::Red:         DOCTEST_SET_ATTR(FOREGROUND_RED);                                      {\cf19 break};\par
4215                 {\cf19 case} Color::Green:       DOCTEST_SET_ATTR(FOREGROUND_GREEN);                                    {\cf19 break};\par
4216                 {\cf19 case} Color::Blue:        DOCTEST_SET_ATTR(FOREGROUND_BLUE);                                     {\cf19 break};\par
4217                 {\cf19 case} Color::Cyan:        DOCTEST_SET_ATTR(FOREGROUND_BLUE | FOREGROUND_GREEN);                  {\cf19 break};\par
4218                 {\cf19 case} Color::Yellow:      DOCTEST_SET_ATTR(FOREGROUND_RED | FOREGROUND_GREEN);                   {\cf19 break};\par
4219                 {\cf19 case} Color::Grey:        DOCTEST_SET_ATTR(0);                                                   {\cf19 break};\par
4220                 {\cf19 case} Color::LightGrey:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY);                                {\cf19 break};\par
4221                 {\cf19 case} Color::BrightRed:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_RED);               {\cf19 break};\par
4222                 {\cf19 case} Color::BrightGreen: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN);             {\cf19 break};\par
4223                 {\cf19 case} Color::BrightWhite: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); {\cf19 break};\par
4224                 {\cf19 case} Color::None:\par
4225                 {\cf19 case} Color::Bright: {\cf20 // invalid}\par
4226                 {\cf19 default}:                 DOCTEST_SET_ATTR(g_originalForegroundAttributes);\par
4227             \}\par
4228                 {\cf20 // clang-format on}\par
4229 {\cf21 #undef DOCTEST_SET_ATTR}\par
4230 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_COLORS_WINDOWS}\par
4231             {\cf19 return} s;\par
4232         \}\par
4233     \} {\cf20 // namespace Color}\par
4234 \par
4235     std::vector<const IExceptionTranslator*>& getExceptionTranslators() \{\par
4236         {\cf17 static} std::vector<const IExceptionTranslator*> data;\par
4237         {\cf19 return} data;\par
4238     \}\par
4239 \par
4240     {\cf18 void} registerExceptionTranslatorImpl({\cf17 const} IExceptionTranslator* translateFunction) \{\par
4241         {\cf19 if}(std::find(getExceptionTranslators().begin(), getExceptionTranslators().end(),\par
4242                      translateFunction) == getExceptionTranslators().end())\par
4243             getExceptionTranslators().push_back(translateFunction);\par
4244     \}\par
4245 \par
4246     String translateActiveException() \{\par
4247 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
4248         String                                    res;\par
4249         std::vector<const IExceptionTranslator*>& translators = getExceptionTranslators();\par
4250         {\cf19 for}({\cf18 size_t} i = 0; i < translators.size(); ++i)\par
4251             {\cf19 if}(translators[i]->translate(res))\par
4252                 {\cf19 return} res;\par
4253         {\cf20 // clang-format off}\par
4254         {\cf19 try} \{\par
4255             {\cf19 throw};\par
4256         \} {\cf19 catch}(std::exception& ex) \{\par
4257             {\cf19 return} ex.what();\par
4258         \} {\cf19 catch}(std::string& msg) \{\par
4259             {\cf19 return} msg.c_str();\par
4260         \} {\cf19 catch}({\cf17 const} {\cf18 char}* msg) \{\par
4261             {\cf19 return} msg;\par
4262         \} {\cf19 catch}(...) \{\par
4263             {\cf19 return} {\cf22 "unknown exception"};\par
4264         \}\par
4265 {\cf20 // clang-format on}\par
4266 {\cf21 #else  }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
4267         {\cf19 return} {\cf22 ""};\par
4268 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
4269     \}\par
4270 \par
4271     {\cf18 void} writeStringToStream(std::ostream* s, {\cf17 const} String& str) \{ *s << str; \}\par
4272 \par
4273 {\cf21 #ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
4274     {\cf18 void} toStream(std::ostream* s, {\cf18 char}* in) \{ *s << in; \}\par
4275     {\cf18 void} toStream(std::ostream* s, {\cf17 const} {\cf18 char}* in) \{ *s << in; \}\par
4276 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING}\par
4277     {\cf18 void} toStream(std::ostream* s, {\cf18 bool} in) \{ *s << std::boolalpha << in << std::noboolalpha; \}\par
4278     {\cf18 void} toStream(std::ostream* s, {\cf18 float} in) \{ *s << in; \}\par
4279     {\cf18 void} toStream(std::ostream* s, {\cf18 double} in) \{ *s << in; \}\par
4280     {\cf18 void} toStream(std::ostream* s, {\cf18 double} {\cf18 long} in) \{ *s << in; \}\par
4281 \par
4282     {\cf18 void} toStream(std::ostream* s, {\cf18 char} in) \{ *s << in; \}\par
4283     {\cf18 void} toStream(std::ostream* s, {\cf18 char} {\cf18 signed} in) \{ *s << in; \}\par
4284     {\cf18 void} toStream(std::ostream* s, {\cf18 char} {\cf18 unsigned} in) \{ *s << in; \}\par
4285     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 short} in) \{ *s << in; \}\par
4286     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 short} {\cf18 unsigned} in) \{ *s << in; \}\par
4287     {\cf18 void} toStream(std::ostream* s, {\cf18 int} in) \{ *s << in; \}\par
4288     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 unsigned} in) \{ *s << in; \}\par
4289     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} in) \{ *s << in; \}\par
4290     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 unsigned} in) \{ *s << in; \}\par
4291 \par
4292 {\cf21 #ifdef DOCTEST_CONFIG_WITH_LONG_LONG}\par
4293     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 long} in) \{ *s << in; \}\par
4294     {\cf18 void} toStream(std::ostream* s, {\cf18 int} {\cf18 long} {\cf18 long} {\cf18 unsigned} in) \{ *s << in; \}\par
4295 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_WITH_LONG_LONG}\par
4296 \par
4297     {\cf18 void} addToContexts(IContextScope* ptr) \{ contextState->contexts.push_back(ptr); \}\par
4298     {\cf18 void} popFromContexts() \{ contextState->contexts.pop_back(); \}\par
4299     DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) {\cf20 // std::uncaught_exception is deprecated in C++17}\par
4300     DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH("-Wdeprecated-declarations")\par
4301     {\cf18 void} useContextIfExceptionOccurred(IContextScope* ptr) \{\par
4302         {\cf19 if}(std::uncaught_exception()) \{\par
4303             std::ostringstream s;\par
4304             ptr->build(&s);\par
4305             contextState->exceptionalContexts.push_back(s.str());\par
4306         \}\par
4307     \}\par
4308     DOCTEST_GCC_SUPPRESS_WARNING_POP\par
4309     DOCTEST_MSVC_SUPPRESS_WARNING_POP\par
4310 \par
4311     {\cf18 void} printSummary(std::ostream& s);\par
4312 \par
4313 {\cf21 #if !defined(DOCTEST_CONFIG_POSIX_SIGNALS) && !defined(DOCTEST_CONFIG_WINDOWS_SEH)}\par
4314     {\cf18 void} reportFatal({\cf17 const} std::string&) \{\}\par
4315     {\cf17 struct }FatalConditionHandler\par
4316     \{\par
4317         {\cf18 void} reset() \{\}\par
4318     \};\par
4319 {\cf21 #else }{\cf20 // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH}\par
4320 \par
4321     {\cf18 void} reportFatal({\cf17 const} std::string&);\par
4322 \par
4323 {\cf21 #ifdef DOCTEST_PLATFORM_WINDOWS}\par
4324 \par
4325     {\cf17 struct }SignalDefs\par
4326     \{\par
4327         DWORD       id;\par
4328         {\cf17 const} {\cf18 char}* name;\par
4329     \};\par
4330     {\cf20 // There is no 1-1 mapping between signals and windows exceptions.}\par
4331     {\cf20 // Windows can easily distinguish between SO and SigSegV,}\par
4332     {\cf20 // but SigInt, SigTerm, etc are handled differently.}\par
4333     SignalDefs signalDefs[] = \{\par
4334             \{EXCEPTION_ILLEGAL_INSTRUCTION, {\cf22 "SIGILL - Illegal instruction signal"}\},\par
4335             \{EXCEPTION_STACK_OVERFLOW, {\cf22 "SIGSEGV - Stack overflow"}\},\par
4336             \{EXCEPTION_ACCESS_VIOLATION, {\cf22 "SIGSEGV - Segmentation violation signal"}\},\par
4337             \{EXCEPTION_INT_DIVIDE_BY_ZERO, {\cf22 "Divide by zero error"}\},\par
4338     \};\par
4339 \par
4340     {\cf17 struct }FatalConditionHandler\par
4341     \{\par
4342         {\cf17 static} LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) \{\par
4343             {\cf19 for}({\cf18 size_t} i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) \{\par
4344                 {\cf19 if}(ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) \{\par
4345                     reportFatal(signalDefs[i].name);\par
4346                 \}\par
4347             \}\par
4348             {\cf20 // If its not an exception we care about, pass it along.}\par
4349             {\cf20 // This stops us from eating debugger breaks etc.}\par
4350             {\cf19 return} EXCEPTION_CONTINUE_SEARCH;\par
4351         \}\par
4352 \par
4353         FatalConditionHandler() \{\par
4354             isSet = {\cf17 true};\par
4355             {\cf20 // 32k seems enough for doctest to handle stack overflow,}\par
4356             {\cf20 // but the value was found experimentally, so there is no strong guarantee}\par
4357             guaranteeSize          = 32 * 1024;\par
4358             exceptionHandlerHandle = 0;\par
4359             {\cf20 // Register as first handler in current chain}\par
4360             exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);\par
4361             {\cf20 // Pass in guarantee size to be filled}\par
4362             SetThreadStackGuarantee(&guaranteeSize);\par
4363         \}\par
4364 \par
4365         {\cf17 static} {\cf18 void} reset() \{\par
4366             {\cf19 if}(isSet) \{\par
4367                 {\cf20 // Unregister handler and restore the old guarantee}\par
4368                 RemoveVectoredExceptionHandler(exceptionHandlerHandle);\par
4369                 SetThreadStackGuarantee(&guaranteeSize);\par
4370                 exceptionHandlerHandle = 0;\par
4371                 isSet                  = {\cf17 false};\par
4372             \}\par
4373         \}\par
4374 \par
4375         ~FatalConditionHandler() \{ reset(); \}\par
4376 \par
4377     {\cf17 private}:\par
4378         {\cf17 static} {\cf18 bool}  isSet;\par
4379         {\cf17 static} ULONG guaranteeSize;\par
4380         {\cf17 static} PVOID exceptionHandlerHandle;\par
4381     \};\par
4382 \par
4383     {\cf18 bool}  FatalConditionHandler::isSet                  = {\cf17 false};\par
4384     ULONG FatalConditionHandler::guaranteeSize          = 0;\par
4385     PVOID FatalConditionHandler::exceptionHandlerHandle = 0;\par
4386 \par
4387 {\cf21 #else }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
4388 \par
4389     {\cf17 struct }SignalDefs\par
4390     \{\par
4391         {\cf18 int}         id;\par
4392         {\cf17 const} {\cf18 char}* name;\par
4393     \};\par
4394     SignalDefs signalDefs[] = \{\{SIGINT, {\cf22 "SIGINT - Terminal interrupt signal"}\},\par
4395                                \{SIGILL, {\cf22 "SIGILL - Illegal instruction signal"}\},\par
4396                                \{SIGFPE, {\cf22 "SIGFPE - Floating point error signal"}\},\par
4397                                \{SIGSEGV, {\cf22 "SIGSEGV - Segmentation violation signal"}\},\par
4398                                \{SIGTERM, {\cf22 "SIGTERM - Termination request signal"}\},\par
4399                                \{SIGABRT, {\cf22 "SIGABRT - Abort (abnormal termination) signal"}\}\};\par
4400 \par
4401     {\cf17 struct }FatalConditionHandler\par
4402     \{\par
4403         {\cf17 static} {\cf18 bool}             isSet;\par
4404         {\cf17 static} {\cf17 struct }sigaction oldSigActions[DOCTEST_COUNTOF(signalDefs)];\par
4405         {\cf17 static} stack_t          oldSigStack;\par
4406         {\cf17 static} {\cf18 char}             altStackMem[4 * SIGSTKSZ];\par
4407 \par
4408         {\cf17 static} {\cf18 void} handleSignal({\cf18 int} sig) \{\par
4409             std::string name = {\cf22 "<unknown signal>"};\par
4410             {\cf19 for}(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) \{\par
4411                 SignalDefs& def = signalDefs[i];\par
4412                 {\cf19 if}(sig == def.id) \{\par
4413                     name = def.name;\par
4414                     {\cf19 break};\par
4415                 \}\par
4416             \}\par
4417             reset();\par
4418             reportFatal(name);\par
4419             raise(sig);\par
4420         \}\par
4421 \par
4422         FatalConditionHandler() \{\par
4423             isSet = {\cf17 true};\par
4424             stack_t sigStack;\par
4425             sigStack.ss_sp    = altStackMem;\par
4426             sigStack.ss_size  = {\cf17 sizeof}(altStackMem);\par
4427             sigStack.ss_flags = 0;\par
4428             sigaltstack(&sigStack, &oldSigStack);\par
4429             {\cf17 struct }sigaction sa = \{0\};\par
4430 \par
4431             sa.sa_handler = handleSignal; {\cf20 // NOLINT}\par
4432             sa.sa_flags   = SA_ONSTACK;\par
4433             {\cf19 for}(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) \{\par
4434                 sigaction(signalDefs[i].{\cf18 id}, &sa, &oldSigActions[i]);\par
4435             \}\par
4436         \}\par
4437 \par
4438         ~FatalConditionHandler() \{ reset(); \}\par
4439         {\cf17 static} {\cf18 void} reset() \{\par
4440             {\cf19 if}(isSet) \{\par
4441                 {\cf20 // Set signals back to previous values -- hopefully nobody overwrote them in the meantime}\par
4442                 {\cf19 for}(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) \{\par
4443                     sigaction(signalDefs[i].{\cf18 id}, &oldSigActions[i], 0);\par
4444                 \}\par
4445                 {\cf20 // Return the old stack}\par
4446                 sigaltstack(&oldSigStack, 0);\par
4447                 isSet = {\cf17 false};\par
4448             \}\par
4449         \}\par
4450     \};\par
4451 \par
4452     {\cf18 bool}             FatalConditionHandler::isSet                                      = {\cf17 false};\par
4453     {\cf17 struct }sigaction FatalConditionHandler::oldSigActions[DOCTEST_COUNTOF(signalDefs)] = \{\};\par
4454     stack_t          FatalConditionHandler::oldSigStack                                = \{\};\par
4455     {\cf18 char}             FatalConditionHandler::altStackMem[]                              = \{\};\par
4456 \par
4457 {\cf21 #endif }{\cf20 // DOCTEST_PLATFORM_WINDOWS}\par
4458 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH}\par
4459 \par
4460     {\cf18 void} separator_to_stream(std::ostream& s) \{\par
4461         s << Color::Yellow\par
4462           << {\cf22 "===============================================================================\\n"};\par
4463     \}\par
4464 \par
4465     {\cf20 // depending on the current options this will remove the path of filenames}\par
4466     {\cf17 const} {\cf18 char}* fileForOutput({\cf17 const} {\cf18 char}* file) \{\par
4467         {\cf19 if}(contextState->no_path_in_filenames) \{\par
4468             {\cf17 const} {\cf18 char}* back    = std::strrchr(file, {\cf23 '\\\\'});\par
4469             {\cf17 const} {\cf18 char}* forward = std::strrchr(file, {\cf23 '/'});\par
4470             {\cf19 if}(back || forward) \{\par
4471                 {\cf19 if}(back > forward)\par
4472                     forward = back;\par
4473                 {\cf19 return} forward + 1;\par
4474             \}\par
4475         \}\par
4476         {\cf19 return} file;\par
4477     \}\par
4478 \par
4479     {\cf18 void} file_line_to_stream(std::ostream& s, {\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* tail = {\cf22 ""}) \{\par
4480         s << Color::LightGrey << fileForOutput(file) << (contextState->gnu_file_line ? {\cf22 ":"} : {\cf22 "("})\par
4481           << (contextState->no_line_numbers ? 0 : line) {\cf20 // 0 or the real num depending on the option}\par
4482           << (contextState->gnu_file_line ? {\cf22 ":"} : {\cf22 "):"}) << tail;\par
4483     \}\par
4484 \par
4485     {\cf17 const} {\cf18 char}* getSuccessOrFailString({\cf18 bool} success, assertType::Enum at, {\cf17 const} {\cf18 char}* success_str) \{\par
4486         {\cf19 if}(success)\par
4487             {\cf19 return} success_str;\par
4488         {\cf19 if}(at & assertType::is_warn) \par
4489             {\cf19 return} {\cf22 "WARNING: "};\par
4490         {\cf19 if}(at & assertType::is_check) \par
4491             {\cf19 return} {\cf22 "ERROR: "};\par
4492         {\cf19 if}(at & assertType::is_require) \par
4493             {\cf19 return} {\cf22 "FATAL ERROR: "};\par
4494         {\cf19 return} {\cf22 ""};\par
4495     \}\par
4496 \par
4497     Color::Code getSuccessOrFailColor({\cf18 bool} success, assertType::Enum at) \{\par
4498         {\cf19 return} success ? Color::BrightGreen :\par
4499                          (at & assertType::is_warn) ? Color::Yellow : Color::Red;\par
4500     \}\par
4501 \par
4502     {\cf18 void} successOrFailColoredStringToStream(std::ostream& s, {\cf18 bool} success, assertType::Enum at,\par
4503                                             {\cf17 const} {\cf18 char}* success_str = {\cf22 "SUCCESS: "}) \{\par
4504         s << getSuccessOrFailColor(success, at) << getSuccessOrFailString(success, at, success_str);\par
4505     \}\par
4506 \par
4507 {\cf21 #ifdef DOCTEST_PLATFORM_MAC}\par
4508 {\cf21 #include <sys/types.h>}\par
4509 {\cf21 #include <unistd.h>}\par
4510 {\cf21 #include <sys/sysctl.h>}\par
4511     {\cf20 // The following function is taken directly from the following technical note:}\par
4512     {\cf20 // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html}\par
4513     {\cf20 // Returns true if the current process is being debugged (either}\par
4514     {\cf20 // running under the debugger or has a debugger attached post facto).}\par
4515     {\cf18 bool} isDebuggerActive() \{\par
4516         {\cf18 int}        mib[4];\par
4517         kinfo_proc info;\par
4518         {\cf18 size_t}     size;\par
4519         {\cf20 // Initialize the flags so that, if sysctl fails for some bizarre}\par
4520         {\cf20 // reason, we get a predictable result.}\par
4521         info.kp_proc.p_flag = 0;\par
4522         {\cf20 // Initialize mib, which tells sysctl the info we want, in this case}\par
4523         {\cf20 // we're looking for information about a specific process ID.}\par
4524         mib[0] = CTL_KERN;\par
4525         mib[1] = KERN_PROC;\par
4526         mib[2] = KERN_PROC_PID;\par
4527         mib[3] = getpid();\par
4528         {\cf20 // Call sysctl.}\par
4529         size = {\cf17 sizeof}(info);\par
4530         {\cf19 if}(sysctl(mib, DOCTEST_COUNTOF(mib), &info, &size, 0, 0) != 0) \{\par
4531             fprintf(stderr, {\cf22 "\\n** Call to sysctl failed - unable to determine if debugger is "}\par
4532                             {\cf22 "active **\\n\\n"});\par
4533             {\cf19 return} {\cf17 false};\par
4534         \}\par
4535         {\cf20 // We're being debugged if the P_TRACED flag is set.}\par
4536         {\cf19 return} ((info.kp_proc.p_flag & P_TRACED) != 0);\par
4537     \}\par
4538 {\cf21 #elif DOCTEST_MSVC || defined(__MINGW32__)}\par
4539     {\cf18 bool}  isDebuggerActive() \{ return ::IsDebuggerPresent() != 0; \}\par
4540 {\cf21 #else}\par
4541     {\cf18 bool} isDebuggerActive() \{ {\cf19 return} {\cf17 false}; \}\par
4542 {\cf21 #endif }{\cf20 // Platform}\par
4543 \par
4544 {\cf21 #ifdef DOCTEST_PLATFORM_WINDOWS}\par
4545     {\cf18 void} myOutputDebugString({\cf17 const} String& text) \{ ::OutputDebugStringA(text.c_str()); \}\par
4546 {\cf21 #else}\par
4547     {\cf20 // TODO: integration with XCode and other IDEs}\par
4548     {\cf18 void} myOutputDebugString({\cf17 const} String&) \{\}\par
4549 {\cf21 #endif }{\cf20 // Platform}\par
4550 \par
4551     {\cf18 void} printToDebugConsole({\cf17 const} String& text) \{\par
4552         {\cf19 if}(isDebuggerActive())\par
4553             myOutputDebugString(text);\par
4554     \}\par
4555 \par
4556     {\cf18 void} addFailedAssert(assertType::Enum at) \{\par
4557         {\cf19 if}((at & assertType::is_warn) == 0) \{ \par
4558             contextState->numFailedAssertions++;\par
4559             contextState->numFailedAssertionsForCurrentTestcase++;\par
4560             contextState->hasCurrentTestFailed = {\cf17 true};\par
4561         \}\par
4562     \}\par
4563 \par
4564     std::ostream& operator<<(std::ostream& s, {\cf17 const} std::vector<IContextScope*>& contexts) \{\par
4565         {\cf19 if}(!contexts.empty())\par
4566             s << Color::None << {\cf22 "  logged: "};\par
4567         {\cf19 for}({\cf18 size_t} i = 0; i < contexts.size(); ++i) \{\par
4568             s << (i == 0 ? {\cf22 ""} : {\cf22 "          "});\par
4569             contexts[i]->build(&s);\par
4570             s << {\cf22 "\\n"};\par
4571         \}\par
4572         s << {\cf22 "\\n"};\par
4573         {\cf19 return} s;\par
4574     \}\par
4575 \par
4576     {\cf18 void} logTestStart(std::ostream& s, {\cf17 const} TestCase& tc) \{\par
4577         separator_to_stream(s);\par
4578         file_line_to_stream(s, tc.m_file, tc.m_line, {\cf22 "\\n"});\par
4579         {\cf19 if}(tc.m_description)\par
4580             s << Color::Yellow << {\cf22 "DESCRIPTION: "} << Color::None << tc.m_description << {\cf22 "\\n"};\par
4581         {\cf19 if}(tc.m_test_suite && tc.m_test_suite[0] != {\cf23 '\\0'})\par
4582             s << Color::Yellow << {\cf22 "TEST SUITE: "} << Color::None << tc.m_test_suite << {\cf22 "\\n"};\par
4583         {\cf19 if}(strncmp(tc.m_name, {\cf22 "  Scenario:"}, 11) != 0)\par
4584             s << Color::None << {\cf22 "TEST CASE:  "};\par
4585         s << Color::None << tc.m_name << {\cf22 "\\n"};\par
4586 \par
4587         std::vector<Subcase>& subcasesStack = contextState->subcasesStack;\par
4588         {\cf19 for}({\cf18 unsigned} i = 0; i < subcasesStack.size(); ++i)\par
4589             {\cf19 if}(subcasesStack[i].m_signature.m_name[0] != {\cf23 '\\0'})\par
4590                 s << {\cf22 "  "} << subcasesStack[i].m_signature.m_name << {\cf22 "\\n"};\par
4591 \par
4592         s << {\cf22 "\\n"};\par
4593     \}\par
4594 \par
4595     {\cf18 void} logTestEnd() \{\}\par
4596 \par
4597     {\cf18 void} logTestException_impl(std::ostream& s, {\cf17 const} TestCase& tc, {\cf17 const} String& str, {\cf18 bool} crash) \{\par
4598         file_line_to_stream(s, tc.m_file, tc.m_line, {\cf22 " "});\par
4599         successOrFailColoredStringToStream(s, {\cf17 false},\par
4600                                            crash ? assertType::is_require : assertType::is_check);\par
4601         s << Color::Red << (crash ? {\cf22 "test case CRASHED: "} : {\cf22 "test case THREW exception: "})\par
4602           << Color::Cyan << str << {\cf22 "\\n"};\par
4603 \par
4604         {\cf19 if}(!contextState->exceptionalContexts.empty()) \{\par
4605             s << Color::None << {\cf22 "  logged: "};\par
4606             {\cf19 for}({\cf18 size_t} i = contextState->exceptionalContexts.size(); i > 0; --i)\par
4607                 s << (i == contextState->exceptionalContexts.size() ? {\cf22 ""} : {\cf22 "          "})\par
4608                   << contextState->exceptionalContexts[i - 1] << {\cf22 "\\n"};\par
4609         \}\par
4610         s << {\cf22 "\\n"};\par
4611     \}\par
4612 \par
4613     {\cf18 void} logTestException({\cf17 const} TestCase& tc, {\cf17 const} String& what, {\cf18 bool} crash) \{\par
4614         logTestException_impl(std::cout, tc, what, crash);\par
4615         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4616         logTestException_impl(oss, tc, what, crash);\par
4617         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4618     \}\par
4619 \par
4620 {\cf21 #if defined(DOCTEST_CONFIG_POSIX_SIGNALS) || defined(DOCTEST_CONFIG_WINDOWS_SEH)}\par
4621     {\cf18 void} reportFatal({\cf17 const} std::string& message) \{\par
4622         DOCTEST_LOG_START(std::cout);\par
4623 \par
4624         contextState->numAssertions += contextState->numAssertionsForCurrentTestcase;\par
4625         logTestException(*contextState->currentTest, message.c_str(), {\cf17 true});\par
4626         logTestEnd();\par
4627         contextState->numFailed++;\par
4628 \par
4629         printSummary(std::cout);\par
4630     \}\par
4631 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH}\par
4632 \par
4633     {\cf18 void} logAssert_impl(std::ostream& s, {\cf18 bool} passed, {\cf17 const} String& dec, {\cf18 bool} threw,\par
4634                         {\cf17 const} String& ex, {\cf17 const} {\cf18 char}* expr, assertType::Enum at, {\cf17 const} {\cf18 char}* file,\par
4635                         {\cf18 int} line) \{\par
4636         file_line_to_stream(s, file, line, {\cf22 " "});\par
4637         successOrFailColoredStringToStream(s, passed, at);\par
4638         s << Color::Cyan << assertString(at) << {\cf22 "( "} << expr << {\cf22 " ) "} << Color::None\par
4639           << (threw ? {\cf22 "THREW exception: "} : (passed ? {\cf22 "is correct!\\n"} : {\cf22 "is NOT correct!\\n"}));\par
4640         {\cf19 if}(threw)\par
4641             s << ex << {\cf22 "\\n"};\par
4642         {\cf19 else}\par
4643             s << {\cf22 "  values: "} << assertString(at) << {\cf22 "( "} << dec << {\cf22 " )\\n"};\par
4644         s << contextState->contexts;\par
4645     \}\par
4646 \par
4647     {\cf18 void} logAssert({\cf18 bool} passed, {\cf17 const} String& dec, {\cf18 bool} threw, {\cf17 const} String& ex, {\cf17 const} {\cf18 char}* expr,\par
4648                    assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4649         logAssert_impl(std::cout, passed, dec, threw, ex, expr, at, file, line);\par
4650         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4651         logAssert_impl(oss, passed, dec, threw, ex, expr, at, file, line);\par
4652         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4653     \}\par
4654 \par
4655     {\cf18 void} logAssertThrows_impl(std::ostream& s, {\cf18 bool} threw, {\cf17 const} {\cf18 char}* expr, assertType::Enum at,\par
4656                               {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4657         file_line_to_stream(s, file, line, {\cf22 " "});\par
4658         successOrFailColoredStringToStream(s, threw, at);\par
4659         s << Color::Cyan << assertString(at) << {\cf22 "( "} << expr << {\cf22 " ) "} << Color::None\par
4660           << (threw ? {\cf22 "threw as expected!"} : {\cf22 "did NOT throw at all!"}) << {\cf22 "\\n"};\par
4661         s << contextState->contexts;\par
4662     \}\par
4663 \par
4664     {\cf18 void} logAssertThrows({\cf18 bool} threw, {\cf17 const} {\cf18 char}* expr, assertType::Enum at, {\cf17 const} {\cf18 char}* file,\par
4665                          {\cf18 int} line) \{\par
4666         logAssertThrows_impl(std::cout, threw, expr, at, file, line);\par
4667         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4668         logAssertThrows_impl(oss, threw, expr, at, file, line);\par
4669         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4670     \}\par
4671 \par
4672     {\cf18 void} logAssertThrowsAs_impl(std::ostream& s, {\cf18 bool} threw, {\cf18 bool} threw_as, {\cf17 const} {\cf18 char}* as,\par
4673                                 {\cf17 const} String& ex, {\cf17 const} {\cf18 char}* expr, assertType::Enum at,\par
4674                                 {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4675         file_line_to_stream(s, file, line, {\cf22 " "});\par
4676         successOrFailColoredStringToStream(s, threw_as, at);\par
4677         s << Color::Cyan << assertString(at) << {\cf22 "( "} << expr << {\cf22 ", "} << as << {\cf22 " ) "} << Color::None\par
4678           << (threw ? (threw_as ? {\cf22 "threw as expected!"} : {\cf22 "threw a DIFFERENT exception: "}) :\par
4679                       {\cf22 "did NOT throw at all!"})\par
4680           << Color::Cyan << ex << {\cf22 "\\n"};\par
4681         s << contextState->contexts;\par
4682     \}\par
4683 \par
4684     {\cf18 void} logAssertThrowsAs({\cf18 bool} threw, {\cf18 bool} threw_as, {\cf17 const} {\cf18 char}* as, {\cf17 const} String& ex,\par
4685                            {\cf17 const} {\cf18 char}* expr, assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4686         logAssertThrowsAs_impl(std::cout, threw, threw_as, as, ex, expr, at, file, line);\par
4687         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4688         logAssertThrowsAs_impl(oss, threw, threw_as, as, ex, expr, at, file, line);\par
4689         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4690     \}\par
4691 \par
4692     {\cf18 void} logAssertNothrow_impl(std::ostream& s, {\cf18 bool} threw, {\cf17 const} String& ex, {\cf17 const} {\cf18 char}* expr,\par
4693                                assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4694         file_line_to_stream(s, file, line, {\cf22 " "});\par
4695         successOrFailColoredStringToStream(s, !threw, at);\par
4696         s << Color::Cyan << assertString(at) << {\cf22 "( "} << expr << {\cf22 " ) "} << Color::None\par
4697           << (threw ? {\cf22 "THREW exception: "} : {\cf22 "didn't throw!"}) << Color::Cyan << ex << {\cf22 "\\n"};\par
4698         s << contextState->contexts;\par
4699     \}\par
4700 \par
4701     {\cf18 void} logAssertNothrow({\cf18 bool} threw, {\cf17 const} String& ex, {\cf17 const} {\cf18 char}* expr, assertType::Enum at,\par
4702                           {\cf17 const} {\cf18 char}* file, {\cf18 int} line) \{\par
4703         logAssertNothrow_impl(std::cout, threw, ex, expr, at, file, line);\par
4704         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4705         logAssertNothrow_impl(oss, threw, ex, expr, at, file, line);\par
4706         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4707     \}\par
4708 \par
4709     ResultBuilder::ResultBuilder(assertType::Enum at, {\cf17 const} {\cf18 char}* file, {\cf18 int} line, {\cf17 const} {\cf18 char}* expr,\par
4710                                  {\cf17 const} {\cf18 char}* exception_type)\par
4711             : m_assert_type(at)\par
4712             , m_file(file)\par
4713             , m_line(line)\par
4714             , m_expr(expr)\par
4715             , m_exception_type(exception_type)\par
4716             , m_threw(false)\par
4717             , m_threw_as(false)\par
4718             , m_failed(false) \{\par
4719 {\cf21 #if DOCTEST_MSVC}\par
4720         {\cf19 if}(m_expr[0] == {\cf23 ' '}) {\cf20 // this happens when variadic macros are disabled under MSVC}\par
4721             ++m_expr;\par
4722 {\cf21 #endif }{\cf20 // MSVC}\par
4723     \}\par
4724 \par
4725     ResultBuilder::~ResultBuilder() \{\}\par
4726 \par
4727     {\cf18 void} ResultBuilder::unexpectedExceptionOccurred() \{\par
4728         m_threw = {\cf17 true};\par
4729 \par
4730         m_exception = translateActiveException();\par
4731     \}\par
4732 \par
4733     {\cf18 bool} ResultBuilder::log() \{\par
4734         {\cf19 if}((m_assert_type & assertType::is_warn) == 0) \par
4735             contextState->numAssertionsForCurrentTestcase++;\par
4736 \par
4737         {\cf19 if}(m_assert_type & assertType::is_throws) \{ \par
4738             m_failed = !m_threw;\par
4739         \} {\cf19 else} {\cf19 if}(m_assert_type & \par
4740                   assertType::is_throws_as) \{\par
4741             m_failed = !m_threw_as;\par
4742         \} {\cf19 else} {\cf19 if}(m_assert_type & \par
4743                   assertType::is_nothrow) \{\par
4744             m_failed = m_threw;\par
4745         \} {\cf19 else} \{\par
4746             m_failed = m_result;\par
4747         \}\par
4748 \par
4749         {\cf19 if}(m_failed || contextState->success) \{\par
4750             DOCTEST_LOG_START(std::cout);\par
4751 \par
4752             {\cf19 if}(m_assert_type & assertType::is_throws) \{ \par
4753                 logAssertThrows(m_threw, m_expr, m_assert_type, m_file, m_line);\par
4754             \} {\cf19 else} {\cf19 if}(m_assert_type & \par
4755                       assertType::is_throws_as) \{\par
4756                 logAssertThrowsAs(m_threw, m_threw_as, m_exception_type, m_exception, m_expr,\par
4757                                   m_assert_type, m_file, m_line);\par
4758             \} {\cf19 else} {\cf19 if}(m_assert_type & \par
4759                       assertType::is_nothrow) \{\par
4760                 logAssertNothrow(m_threw, m_exception, m_expr, m_assert_type, m_file, m_line);\par
4761             \} {\cf19 else} \{\par
4762                 logAssert(m_result.m_passed, m_result.m_decomposition, m_threw, m_exception, m_expr,\par
4763                           m_assert_type, m_file, m_line);\par
4764             \}\par
4765         \}\par
4766 \par
4767         {\cf19 if}(m_failed)\par
4768             addFailedAssert(m_assert_type);\par
4769 \par
4770         {\cf19 return} m_failed && isDebuggerActive() && !contextState->no_breaks; {\cf20 // break into debugger}\par
4771     \}\par
4772 \par
4773     {\cf18 void} ResultBuilder::react(){\cf17  const }\{\par
4774         {\cf19 if}(m_failed && checkIfShouldThrow(m_assert_type))\par
4775             throwException();\par
4776     \}\par
4777 \par
4778     MessageBuilder::MessageBuilder({\cf17 const} {\cf18 char}* file, {\cf18 int} line, assertType::Enum severity)\par
4779             : m_stream(createStream())\par
4780             , m_file(file)\par
4781             , m_line(line)\par
4782             , m_severity(severity) \{\}\par
4783 \par
4784     {\cf18 void} MessageBuilder::log(std::ostream& s) \{\par
4785         file_line_to_stream(s, m_file, m_line, {\cf22 " "});\par
4786         s << getSuccessOrFailColor({\cf17 false}, m_severity)\par
4787           << getSuccessOrFailString(m_severity & assertType::is_warn, m_severity, {\cf22 "MESSAGE: "});\par
4788         s << Color::None << getStreamResult(m_stream) << {\cf22 "\\n"};\par
4789         s << contextState->contexts;\par
4790     \}\par
4791 \par
4792     {\cf18 bool} MessageBuilder::log() \{\par
4793         DOCTEST_LOG_START(std::cout);\par
4794 \par
4795         log(std::cout);\par
4796         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_BEGIN;\par
4797         log(oss);\par
4798         DOCTEST_PRINT_TO_OUTPUT_WINDOW_IN_IDE_END;\par
4799         {\cf17 const} {\cf18 bool} isWarn = m_severity & assertType::is_warn;\par
4800 \par
4801         {\cf20 // warn is just a message in this context so we dont treat it as an assert}\par
4802         {\cf19 if}(!isWarn) \{\par
4803             contextState->numAssertionsForCurrentTestcase++;\par
4804             addFailedAssert(m_severity);\par
4805         \}\par
4806 \par
4807         {\cf19 return} isDebuggerActive() && !contextState->no_breaks && !isWarn; {\cf20 // break into debugger}\par
4808     \}\par
4809 \par
4810     {\cf18 void} MessageBuilder::react() \{\par
4811         {\cf19 if}(m_severity & assertType::is_require) \par
4812             throwException();\par
4813     \}\par
4814 \par
4815     MessageBuilder::~MessageBuilder() \{ freeStream(m_stream); \}\par
4816 \par
4817     {\cf20 // the implementation of parseFlag()}\par
4818     {\cf18 bool} parseFlagImpl({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern) \{\par
4819         {\cf19 for}({\cf18 int} i = argc - 1; i >= 0; --i) \{\par
4820             {\cf17 const} {\cf18 char}* temp = std::strstr(argv[i], pattern);\par
4821             {\cf19 if}(temp && strlen(temp) == strlen(pattern)) \{\par
4822                 {\cf20 // eliminate strings in which the chars before the option are not '-'}\par
4823                 {\cf18 bool} noBadCharsFound = {\cf17 true}; \par
4824                 {\cf19 while}(temp != argv[i]) \{\par
4825                     {\cf19 if}(*--temp != {\cf23 '-'}) \{\par
4826                         noBadCharsFound = {\cf17 false};\par
4827                         {\cf19 break};\par
4828                     \}\par
4829                 \}\par
4830                 {\cf19 if}(noBadCharsFound && argv[i][0] == {\cf23 '-'})\par
4831                     {\cf19 return} {\cf17 true};\par
4832             \}\par
4833         \}\par
4834         {\cf19 return} {\cf17 false};\par
4835     \}\par
4836 \par
4837     {\cf20 // locates a flag on the command line}\par
4838     {\cf18 bool} parseFlag({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern) \{\par
4839 {\cf21 #ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4840         {\cf19 if}(!parseFlagImpl(argc, argv, pattern))\par
4841             {\cf19 return} parseFlagImpl(argc, argv, pattern + 3); {\cf20 // 3 for "dt-"}\par
4842         {\cf19 return} {\cf17 true};\par
4843 {\cf21 #else  }{\cf20 // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4844         {\cf19 return} parseFlagImpl(argc, argv, pattern);\par
4845 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4846     \}\par
4847 \par
4848     {\cf20 // the implementation of parseOption()}\par
4849     {\cf18 bool} parseOptionImpl({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern, String& res) \{\par
4850         {\cf19 for}({\cf18 int} i = argc - 1; i >= 0; --i) \{\par
4851             {\cf17 const} {\cf18 char}* temp = std::strstr(argv[i], pattern);\par
4852             {\cf19 if}(temp) \{ \par
4853                 {\cf20 // eliminate matches in which the chars before the option are not '-'}\par
4854                 {\cf18 bool}        noBadCharsFound = {\cf17 true};\par
4855                 {\cf17 const} {\cf18 char}* curr            = argv[i];\par
4856                 {\cf19 while}(curr != temp) \{\par
4857                     {\cf19 if}(*curr++ != {\cf23 '-'}) \{\par
4858                         noBadCharsFound = {\cf17 false};\par
4859                         {\cf19 break};\par
4860                     \}\par
4861                 \}\par
4862                 {\cf19 if}(noBadCharsFound && argv[i][0] == {\cf23 '-'}) \{\par
4863                     temp += strlen(pattern);\par
4864                     {\cf17 const} {\cf18 unsigned} len = strlen(temp);\par
4865                     {\cf19 if}(len) \{\par
4866                         res = temp;\par
4867                         {\cf19 return} {\cf17 true};\par
4868                     \}\par
4869                 \}\par
4870             \}\par
4871         \}\par
4872         {\cf19 return} {\cf17 false};\par
4873     \}\par
4874 \par
4875     {\cf20 // parses an option and returns the string after the '=' character}\par
4876     {\cf18 bool} parseOption({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern, String& res,\par
4877                      {\cf17 const} String& defaultVal = String()) \{\par
4878         res = defaultVal;\par
4879 {\cf21 #ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4880         {\cf19 if}(!parseOptionImpl(argc, argv, pattern, res))\par
4881             {\cf19 return} parseOptionImpl(argc, argv, pattern + 3, res); {\cf20 // 3 for "dt-"}\par
4882         {\cf19 return} {\cf17 true};\par
4883 {\cf21 #else  }{\cf20 // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4884         {\cf19 return} parseOptionImpl(argc, argv, pattern, res);\par
4885 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS}\par
4886     \}\par
4887 \par
4888     {\cf20 // parses a comma separated list of words after a pattern in one of the arguments in argv}\par
4889     {\cf18 bool} parseCommaSepArgs({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern,\par
4890                            std::vector<String>& res) \{\par
4891         String filtersString;\par
4892         {\cf19 if}(parseOption(argc, argv, pattern, filtersString)) \{\par
4893             {\cf20 // tokenize with "," as a separator}\par
4894             {\cf20 // cppcheck-suppress strtokCalled}\par
4895             {\cf18 char}* pch = std::strtok(filtersString.c_str(), {\cf22 ","}); {\cf20 // modifies the string}\par
4896             {\cf19 while}(pch != 0) \{\par
4897                 {\cf19 if}(strlen(pch))\par
4898                     res.push_back(pch);\par
4899                 {\cf20 // uses the strtok() internal state to go to the next token}\par
4900                 {\cf20 // cppcheck-suppress strtokCalled}\par
4901                 pch = std::strtok(0, {\cf22 ","});\par
4902             \}\par
4903             {\cf19 return} {\cf17 true};\par
4904         \}\par
4905         {\cf19 return} {\cf17 false};\par
4906     \}\par
4907 \par
4908     {\cf17 enum} optionType\par
4909     \{\par
4910         option_bool,\par
4911         option_int\par
4912     \};\par
4913 \par
4914     {\cf20 // parses an int/bool option from the command line}\par
4915     {\cf18 bool} parseIntOption({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf17 const} {\cf18 char}* pattern, optionType type,\par
4916                         {\cf18 int}& res) \{\par
4917         String parsedValue;\par
4918         {\cf19 if}(!parseOption(argc, argv, pattern, parsedValue))\par
4919             {\cf19 return} {\cf17 false};\par
4920 \par
4921         {\cf19 if}(type == 0) \{\par
4922             {\cf20 // boolean}\par
4923             {\cf17 const} {\cf18 char} positive[][5] = \{{\cf22 "1"}, {\cf22 "true"}, {\cf22 "on"}, {\cf22 "yes"}\};  {\cf20 // 5 - strlen("true") + 1}\par
4924             {\cf17 const} {\cf18 char} negative[][6] = \{{\cf22 "0"}, {\cf22 "false"}, {\cf22 "off"}, {\cf22 "no"}\}; {\cf20 // 6 - strlen("false") + 1}\par
4925 \par
4926             {\cf20 // if the value matches any of the positive/negative possibilities}\par
4927             {\cf19 for}({\cf18 unsigned} i = 0; i < 4; i++) \{\par
4928                 {\cf19 if}(parsedValue.compare(positive[i], {\cf17 true}) == 0) \{\par
4929                     res = 1; \par
4930                     {\cf19 return} {\cf17 true};\par
4931                 \}\par
4932                 {\cf19 if}(parsedValue.compare(negative[i], {\cf17 true}) == 0) \{\par
4933                     res = 0; \par
4934                     {\cf19 return} {\cf17 true};\par
4935                 \}\par
4936             \}\par
4937         \} {\cf19 else} \{\par
4938             {\cf20 // integer}\par
4939             {\cf18 int} theInt = std::atoi(parsedValue.c_str()); {\cf20 // NOLINT}\par
4940             {\cf19 if}(theInt != 0) \{\par
4941                 res = theInt; \par
4942                 {\cf19 return} {\cf17 true};\par
4943             \}\par
4944         \}\par
4945         {\cf19 return} {\cf17 false};\par
4946     \}\par
4947 \par
4948     {\cf18 void} printVersion(std::ostream& s) \{\par
4949         {\cf19 if}(contextState->no_version == {\cf17 false})\par
4950             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "doctest version is \\""}\par
4951               << DOCTEST_VERSION_STR << {\cf22 "\\"\\n"};\par
4952     \}\par
4953 \par
4954     {\cf18 void} printHelp(std::ostream& s) \{\par
4955         printVersion(s);\par
4956         {\cf20 // clang-format off}\par
4957         s << Color::Cyan << {\cf22 "[doctest]\\n"} << Color::None;\par
4958         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4959         s << {\cf22 "boolean values: \\"1/on/yes/true\\" or \\"0/off/no/false\\"\\n"};\par
4960         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4961         s << {\cf22 "filter  values: \\"str1,str2,str3\\" (comma separated strings)\\n"};\par
4962         s << Color::Cyan << {\cf22 "[doctest]\\n"} << Color::None;\par
4963         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4964         s << {\cf22 "filters use wildcards for matching strings\\n"};\par
4965         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4966         s << {\cf22 "something passes a filter if any of the strings in a filter matches\\n"};\par
4967         s << Color::Cyan << {\cf22 "[doctest]\\n"} << Color::None;\par
4968         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4969         s << {\cf22 "ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A \\"dt-\\" PREFIX!!!\\n"};\par
4970         s << Color::Cyan << {\cf22 "[doctest]\\n"} << Color::None;\par
4971         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4972         s << {\cf22 "Query flags - the program quits after them. Available:\\n\\n"};\par
4973         s << {\cf22 " -?,   --help, -h                      prints this message\\n"};\par
4974         s << {\cf22 " -v,   --version                       prints the version\\n"};\par
4975         s << {\cf22 " -c,   --count                         prints the number of matching tests\\n"};\par
4976         s << {\cf22 " -ltc, --list-test-cases               lists all matching tests by name\\n"};\par
4977         s << {\cf22 " -lts, --list-test-suites              lists all matching test suites\\n\\n"};\par
4978         {\cf20 // ================================================================================== << 79}\par
4979         s << Color::Cyan << {\cf22 "[doctest] "} << Color::None;\par
4980         s << {\cf22 "The available <int>/<string> options/filters are:\\n\\n"};\par
4981         s << {\cf22 " -tc,  --test-case=<filters>           filters     tests by their name\\n"};\par
4982         s << {\cf22 " -tce, --test-case-exclude=<filters>   filters OUT tests by their name\\n"};\par
4983         s << {\cf22 " -sf,  --source-file=<filters>         filters     tests by their file\\n"};\par
4984         s << {\cf22 " -sfe, --source-file-exclude=<filters> filters OUT tests by their file\\n"};\par
4985         s << {\cf22 " -ts,  --test-suite=<filters>          filters     tests by their test suite\\n"};\par
4986         s << {\cf22 " -tse, --test-suite-exclude=<filters>  filters OUT tests by their test suite\\n"};\par
4987         s << {\cf22 " -sc,  --subcase=<filters>             filters     subcases by their name\\n"};\par
4988         s << {\cf22 " -sce, --subcase-exclude=<filters>     filters OUT subcases by their name\\n"};\par
4989         s << {\cf22 " -ob,  --order-by=<string>             how the tests should be ordered\\n"};\par
4990         s << {\cf22 "                                       <string> - by [file/suite/name/rand]\\n"};\par
4991         s << {\cf22 " -rs,  --rand-seed=<int>               seed for random ordering\\n"};\par
4992         s << {\cf22 " -f,   --first=<int>                   the first test passing the filters to\\n"};\par
4993         s << {\cf22 "                                       execute - for range-based execution\\n"};\par
4994         s << {\cf22 " -l,   --last=<int>                    the last test passing the filters to\\n"};\par
4995         s << {\cf22 "                                       execute - for range-based execution\\n"};\par
4996         s << {\cf22 " -aa,  --abort-after=<int>             stop after <int> failed assertions\\n"};\par
4997         s << {\cf22 " -scfl,--subcase-filter-levels=<int>   apply filters for the first <int> levels\\n"};\par
4998         s << Color::Cyan << {\cf22 "\\n[doctest] "} << Color::None;\par
4999         s << {\cf22 "Bool options - can be used like flags and true is assumed. Available:\\n\\n"};\par
5000         s << {\cf22 " -s,   --success=<bool>                include successful assertions in output\\n"};\par
5001         s << {\cf22 " -cs,  --case-sensitive=<bool>         filters being treated as case sensitive\\n"};\par
5002         s << {\cf22 " -e,   --exit=<bool>                   exits after the tests finish\\n"};\par
5003         s << {\cf22 " -d,   --duration=<bool>               prints the time duration of each test\\n"};\par
5004         s << {\cf22 " -nt,  --no-throw=<bool>               skips exceptions-related assert checks\\n"};\par
5005         s << {\cf22 " -ne,  --no-exitcode=<bool>            returns (or exits) always with success\\n"};\par
5006         s << {\cf22 " -nr,  --no-run=<bool>                 skips all runtime doctest operations\\n"};\par
5007         s << {\cf22 " -nv,  --no-version=<bool>             omit the framework version in the output\\n"};\par
5008         s << {\cf22 " -nc,  --no-colors=<bool>              disables colors in output\\n"};\par
5009         s << {\cf22 " -fc,  --force-colors=<bool>           use colors even when not in a tty\\n"};\par
5010         s << {\cf22 " -nb,  --no-breaks=<bool>              disables breakpoints in debuggers\\n"};\par
5011         s << {\cf22 " -ns,  --no-skip=<bool>                don't skip test cases marked as skip\\n"};\par
5012         s << {\cf22 " -gfl, --gnu-file-line=<bool>          :n: vs (n): for line numbers in output\\n"};\par
5013         s << {\cf22 " -npf, --no-path-filenames=<bool>      only filenames and no paths in output\\n"};\par
5014         s << {\cf22 " -nln, --no-line-numbers=<bool>        0 instead of real line numbers in output\\n"};\par
5015         {\cf20 // ================================================================================== << 79}\par
5016         {\cf20 // clang-format on}\par
5017 \par
5018         s << Color::Cyan << {\cf22 "\\n[doctest] "} << Color::None;\par
5019         s << {\cf22 "for more information visit the project documentation\\n\\n"};\par
5020     \}\par
5021 \par
5022     {\cf18 void} printSummary(std::ostream& s) \{\par
5023         {\cf17 const} ContextState* p = contextState;\par
5024 \par
5025         separator_to_stream(s);\par
5026 \par
5027         {\cf19 if}(p->count || p->list_test_cases) \{\par
5028             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None\par
5029               << {\cf22 "unskipped test cases passing the current filters: "} << p->numTestsPassingFilters\par
5030               << {\cf22 "\\n"};\par
5031         \} {\cf19 else} {\cf19 if}(p->list_test_suites) \{\par
5032             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None\par
5033               << {\cf22 "unskipped test cases passing the current filters: "} << p->numTestsPassingFilters\par
5034               << {\cf22 "\\n"};\par
5035             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None\par
5036               << {\cf22 "test suites with unskipped test cases passing the current filters: "}\par
5037               << p->numTestSuitesPassingFilters << {\cf22 "\\n"};\par
5038         \} {\cf19 else} \{\par
5039             {\cf17 const} {\cf18 bool} anythingFailed = p->numFailed > 0 || p->numFailedAssertions > 0;\par
5040             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "test cases: "} << std::setw(6)\par
5041               << p->numTestsPassingFilters << {\cf22 " | "}\par
5042               << ((p->numTestsPassingFilters == 0 || anythingFailed) ? Color::None : Color::Green)\par
5043               << std::setw(6) << p->numTestsPassingFilters - p->numFailed << {\cf22 " passed"}\par
5044               << Color::None << {\cf22 " | "} << (p->numFailed > 0 ? Color::Red : Color::None)\par
5045               << std::setw(6) << p->numFailed << {\cf22 " failed"} << Color::None << {\cf22 " | "};\par
5046             {\cf19 if}(p->no_skipped_summary == {\cf17 false}) \{\par
5047                 {\cf17 const} {\cf18 int} numSkipped = {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(getRegisteredTests().size()) -\par
5048                                        p->numTestsPassingFilters;\par
5049                 s << (numSkipped == 0 ? Color::None : Color::Yellow) << std::setw(6) << numSkipped\par
5050                   << {\cf22 " skipped"} << Color::None;\par
5051             \}\par
5052             s << {\cf22 "\\n"};\par
5053             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "assertions: "} << std::setw(6)\par
5054               << p->numAssertions << {\cf22 " | "}\par
5055               << ((p->numAssertions == 0 || anythingFailed) ? Color::None : Color::Green)\par
5056               << std::setw(6) << (p->numAssertions - p->numFailedAssertions) << {\cf22 " passed"}\par
5057               << Color::None << {\cf22 " | "} << (p->numFailedAssertions > 0 ? Color::Red : Color::None)\par
5058               << std::setw(6) << p->numFailedAssertions << {\cf22 " failed"} << Color::None << {\cf22 " |\\n"};\par
5059             s << Color::Cyan << {\cf22 "[doctest] "} << Color::None\par
5060               << {\cf22 "Status: "} << (p->numFailed > 0 ? Color::Red : Color::Green)\par
5061               << ((p->numFailed > 0) ? {\cf22 "FAILURE!\\n"} : {\cf22 "SUCCESS!\\n"});\par
5062         \}\par
5063 \par
5064         {\cf20 // remove any coloring}\par
5065         s << Color::None;\par
5066     \}\par
5067 \} {\cf20 // namespace detail}\par
5068 \par
5069 {\cf18 bool} isRunningInTest() \{ {\cf19 return} detail::contextState != 0; \}\par
5070 \par
5071 Context::Context({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv)\par
5072         : p(new detail::ContextState) \{\par
5073     parseArgs(argc, argv, {\cf17 true});\par
5074 \}\par
5075 \par
5076 Context::~Context() \{ {\cf17 delete} p; \}\par
5077 \par
5078 {\cf18 void} Context::applyCommandLine({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv) \{ parseArgs(argc, argv); \}\par
5079 \par
5080 {\cf20 // parses args}\par
5081 {\cf18 void} Context::parseArgs({\cf18 int} argc, {\cf17 const} {\cf18 char}* {\cf17 const}* argv, {\cf18 bool} withDefaults) \{\par
5082     {\cf17 using namespace }detail;\par
5083 \par
5084     {\cf20 // clang-format off}\par
5085     parseCommaSepArgs(argc, argv, {\cf22 "dt-source-file="},        p->filters[0]);\par
5086     parseCommaSepArgs(argc, argv, {\cf22 "dt-sf="},                 p->filters[0]);\par
5087     parseCommaSepArgs(argc, argv, {\cf22 "dt-source-file-exclude="},p->filters[1]);\par
5088     parseCommaSepArgs(argc, argv, {\cf22 "dt-sfe="},                p->filters[1]);\par
5089     parseCommaSepArgs(argc, argv, {\cf22 "dt-test-suite="},         p->filters[2]);\par
5090     parseCommaSepArgs(argc, argv, {\cf22 "dt-ts="},                 p->filters[2]);\par
5091     parseCommaSepArgs(argc, argv, {\cf22 "dt-test-suite-exclude="}, p->filters[3]);\par
5092     parseCommaSepArgs(argc, argv, {\cf22 "dt-tse="},                p->filters[3]);\par
5093     parseCommaSepArgs(argc, argv, {\cf22 "dt-test-case="},          p->filters[4]);\par
5094     parseCommaSepArgs(argc, argv, {\cf22 "dt-tc="},                 p->filters[4]);\par
5095     parseCommaSepArgs(argc, argv, {\cf22 "dt-test-case-exclude="},  p->filters[5]);\par
5096     parseCommaSepArgs(argc, argv, {\cf22 "dt-tce="},                p->filters[5]);\par
5097     parseCommaSepArgs(argc, argv, {\cf22 "dt-subcase="},            p->filters[6]);\par
5098     parseCommaSepArgs(argc, argv, {\cf22 "dt-sc="},                 p->filters[6]);\par
5099     parseCommaSepArgs(argc, argv, {\cf22 "dt-subcase-exclude="},    p->filters[7]);\par
5100     parseCommaSepArgs(argc, argv, {\cf22 "dt-sce="},                p->filters[7]);\par
5101     {\cf20 // clang-format on}\par
5102 \par
5103     {\cf18 int}    intRes = 0;\par
5104     String strRes;\par
5105 \par
5106 {\cf21 #define DOCTEST_PARSE_AS_BOOL_OR_FLAG(name, sname, var, default)                                   \\}\par
5107 {\cf21     if(parseIntOption(argc, argv, name "="}, option_bool, intRes) ||                                \\\par
5108        parseIntOption(argc, argv, sname "=", option_bool, intRes))                                 \\\par
5109         p->var = !!intRes;                                                                         \\\par
5110     else if(parseFlag(argc, argv, name) || parseFlag(argc, argv, sname))                           \\\par
5111         p->var = true;                                                                             \\\par
5112     else if(withDefaults)                                                                          \\\par
5113     p->var = default\par
5114 \par
5115 {\cf21 #define DOCTEST_PARSE_INT_OPTION(name, sname, var, default)                                        \\}\par
5116 {\cf21     if(parseIntOption(argc, argv, name "="}, option_int, intRes) ||                                 \\\par
5117        parseIntOption(argc, argv, sname "=", option_int, intRes))                                  \\\par
5118         p->var = intRes;                                                                           \\\par
5119     else if(withDefaults)                                                                          \\\par
5120     p->var = default\par
5121 \par
5122 {\cf21 #define DOCTEST_PARSE_STR_OPTION(name, sname, var, default)                                        \\}\par
5123 {\cf21     if(parseOption(argc, argv, name "="}, strRes, default) ||                                       \\\par
5124        parseOption(argc, argv, sname "=", strRes, default) || withDefaults)                        \\\par
5125     p->var = strRes\par
5126 \par
5127     {\cf20 // clang-format off}\par
5128     DOCTEST_PARSE_STR_OPTION({\cf22 "dt-order-by"}, {\cf22 "dt-ob"}, order_by, {\cf22 "file"});\par
5129     DOCTEST_PARSE_INT_OPTION({\cf22 "dt-rand-seed"}, {\cf22 "dt-rs"}, rand_seed, 0);\par
5130 \par
5131     DOCTEST_PARSE_INT_OPTION({\cf22 "dt-first"}, {\cf22 "dt-f"}, first, 1);\par
5132     DOCTEST_PARSE_INT_OPTION({\cf22 "dt-last"}, {\cf22 "dt-l"}, last, 0);\par
5133 \par
5134     DOCTEST_PARSE_INT_OPTION({\cf22 "dt-abort-after"}, {\cf22 "dt-aa"}, abort_after, 0);\par
5135     DOCTEST_PARSE_INT_OPTION({\cf22 "dt-subcase-filter-levels"}, {\cf22 "dt-scfl"}, subcase_filter_levels, 2000000000);\par
5136 \par
5137     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-success"}, {\cf22 "dt-s"}, success, {\cf17 false});\par
5138     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-case-sensitive"}, {\cf22 "dt-cs"}, case_sensitive, {\cf17 false});\par
5139     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-exit"}, {\cf22 "dt-e"}, exit, {\cf17 false});\par
5140     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-duration"}, {\cf22 "dt-d"}, duration, {\cf17 false});\par
5141     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-throw"}, {\cf22 "dt-nt"}, no_throw, {\cf17 false});\par
5142     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-exitcode"}, {\cf22 "dt-ne"}, no_exitcode, {\cf17 false});\par
5143     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-run"}, {\cf22 "dt-nr"}, no_run, {\cf17 false});\par
5144     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-version"}, {\cf22 "dt-nv"}, no_version, {\cf17 false});\par
5145     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-colors"}, {\cf22 "dt-nc"}, no_colors, {\cf17 false});\par
5146     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-force-colors"}, {\cf22 "dt-fc"}, force_colors, {\cf17 false});\par
5147     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-breaks"}, {\cf22 "dt-nb"}, no_breaks, {\cf17 false});\par
5148     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-skip"}, {\cf22 "dt-ns"}, no_skip, {\cf17 false});\par
5149     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-gnu-file-line"}, {\cf22 "dt-gfl"}, gnu_file_line, {\cf18 bool}(DOCTEST_GCC) || {\cf18 bool}(DOCTEST_CLANG));\par
5150     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-path-filenames"}, {\cf22 "dt-npf"}, no_path_in_filenames, {\cf17 false});\par
5151     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-line-numbers"}, {\cf22 "dt-nln"}, no_line_numbers, {\cf17 false});\par
5152     DOCTEST_PARSE_AS_BOOL_OR_FLAG({\cf22 "dt-no-skipped-summary"}, {\cf22 "dt-nss"}, no_skipped_summary, {\cf17 false});\par
5153     {\cf20 // clang-format on}\par
5154 \par
5155 {\cf21 #undef DOCTEST_PARSE_STR_OPTION}\par
5156 {\cf21 #undef DOCTEST_PARSE_INT_OPTION}\par
5157 {\cf21 #undef DOCTEST_PARSE_AS_BOOL_OR_FLAG}\par
5158 \par
5159     {\cf19 if}(withDefaults) \{\par
5160         p->help             = {\cf17 false};\par
5161         p->version          = {\cf17 false};\par
5162         p->count            = {\cf17 false};\par
5163         p->list_test_cases  = {\cf17 false};\par
5164         p->list_test_suites = {\cf17 false};\par
5165     \}\par
5166     {\cf19 if}(parseFlag(argc, argv, {\cf22 "dt-help"}) || parseFlag(argc, argv, {\cf22 "dt-h"}) ||\par
5167        parseFlag(argc, argv, {\cf22 "dt-?"})) \{\par
5168         p->help = {\cf17 true};\par
5169         p->exit = {\cf17 true};\par
5170     \}\par
5171     {\cf19 if}(parseFlag(argc, argv, {\cf22 "dt-version"}) || parseFlag(argc, argv, {\cf22 "dt-v"})) \{\par
5172         p->version = {\cf17 true};\par
5173         p->exit    = {\cf17 true};\par
5174     \}\par
5175     {\cf19 if}(parseFlag(argc, argv, {\cf22 "dt-count"}) || parseFlag(argc, argv, {\cf22 "dt-c"})) \{\par
5176         p->count = {\cf17 true};\par
5177         p->exit  = {\cf17 true};\par
5178     \}\par
5179     {\cf19 if}(parseFlag(argc, argv, {\cf22 "dt-list-test-cases"}) || parseFlag(argc, argv, {\cf22 "dt-ltc"})) \{\par
5180         p->list_test_cases = {\cf17 true};\par
5181         p->exit            = {\cf17 true};\par
5182     \}\par
5183     {\cf19 if}(parseFlag(argc, argv, {\cf22 "dt-list-test-suites"}) || parseFlag(argc, argv, {\cf22 "dt-lts"})) \{\par
5184         p->list_test_suites = {\cf17 true};\par
5185         p->exit             = {\cf17 true};\par
5186     \}\par
5187 \}\par
5188 \par
5189 {\cf20 // allows the user to add procedurally to the filters from the command line}\par
5190 {\cf18 void} Context::addFilter({\cf17 const} {\cf18 char}* filter, {\cf17 const} {\cf18 char}* value) \{ setOption(filter, value); \}\par
5191 \par
5192 {\cf20 // allows the user to clear all filters from the command line}\par
5193 {\cf18 void} Context::clearFilters() \{\par
5194     {\cf19 for}({\cf18 unsigned} i = 0; i < p->filters.size(); ++i)\par
5195         p->filters[i].clear();\par
5196 \}\par
5197 \par
5198 {\cf20 // allows the user to override procedurally the int/bool options from the command line}\par
5199 {\cf18 void} Context::setOption({\cf17 const} {\cf18 char}* option, {\cf18 int} value) \{\par
5200     setOption(option, toString(value).c_str());\par
5201 \}\par
5202 \par
5203 {\cf20 // allows the user to override procedurally the string options from the command line}\par
5204 {\cf18 void} Context::setOption({\cf17 const} {\cf18 char}* option, {\cf17 const} {\cf18 char}* value) \{\par
5205     String      argv   = String({\cf22 "-"}) + option + {\cf22 "="} + value;\par
5206     {\cf17 const} {\cf18 char}* lvalue = argv.c_str();\par
5207     parseArgs(1, &lvalue);\par
5208 \}\par
5209 \par
5210 {\cf20 // users should query this in their main() and exit the program if true}\par
5211 {\cf18 bool} Context::shouldExit() \{ {\cf19 return} p->exit; \}\par
5212 \par
5213 {\cf20 // the main function that does all the filtering and test running}\par
5214 {\cf18 int} Context::run() \{\par
5215     {\cf17 using namespace }detail;\par
5216 \par
5217     Color::init();\par
5218 \par
5219     contextState = p;\par
5220     p->resetRunData();\par
5221 \par
5222     {\cf20 // handle version, help and no_run}\par
5223     {\cf19 if}(p->no_run || p->version || p->help) \{\par
5224         {\cf19 if}(p->version)\par
5225             printVersion(std::cout);\par
5226         {\cf19 if}(p->help)\par
5227             printHelp(std::cout);\par
5228 \par
5229         contextState = 0;\par
5230 \par
5231         {\cf19 return} EXIT_SUCCESS;\par
5232     \}\par
5233 \par
5234     printVersion(std::cout);\par
5235     std::cout << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "run with \\"--help\\" for options\\n"};\par
5236 \par
5237     {\cf18 unsigned} i = 0; {\cf20 // counter used for loops - here for VC6}\par
5238 \par
5239     std::set<TestCase>& registeredTests = getRegisteredTests();\par
5240 \par
5241     std::vector<const TestCase*> testArray;\par
5242     {\cf19 for}(std::set<TestCase>::iterator it = registeredTests.begin(); it != registeredTests.end();\par
5243         ++it)\par
5244         testArray.push_back(&(*it));\par
5245 \par
5246     {\cf20 // sort the collected records}\par
5247     {\cf19 if}(!testArray.empty()) \{\par
5248         {\cf19 if}(p->order_by.compare({\cf22 "file"}, {\cf17 true}) == 0) \{\par
5249             std::qsort(&testArray[0], testArray.size(), {\cf17 sizeof}(TestCase*), fileOrderComparator);\par
5250         \} {\cf19 else} {\cf19 if}(p->order_by.compare({\cf22 "suite"}, {\cf17 true}) == 0) \{\par
5251             std::qsort(&testArray[0], testArray.size(), {\cf17 sizeof}(TestCase*), suiteOrderComparator);\par
5252         \} {\cf19 else} {\cf19 if}(p->order_by.compare({\cf22 "name"}, {\cf17 true}) == 0) \{\par
5253             std::qsort(&testArray[0], testArray.size(), {\cf17 sizeof}(TestCase*), nameOrderComparator);\par
5254         \} {\cf19 else} {\cf19 if}(p->order_by.compare({\cf22 "rand"}, {\cf17 true}) == 0) \{\par
5255             std::srand(p->rand_seed);\par
5256 \par
5257             {\cf20 // random_shuffle implementation}\par
5258             {\cf17 const} TestCase** first = &testArray[0];\par
5259             {\cf19 for}(i = testArray.size() - 1; i > 0; --i) \{\par
5260                 {\cf18 int} idxToSwap = std::rand() % (i + 1); {\cf20 // NOLINT}\par
5261 \par
5262                 {\cf17 const} TestCase* temp = first[i];\par
5263 \par
5264                 first[i]         = first[idxToSwap];\par
5265                 first[idxToSwap] = temp;\par
5266             \}\par
5267         \}\par
5268     \}\par
5269 \par
5270     {\cf19 if}(p->list_test_cases) \{\par
5271         std::cout << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "listing all test case names\\n"};\par
5272         separator_to_stream(std::cout);\par
5273     \}\par
5274 \par
5275     std::set<String> testSuitesPassingFilters;\par
5276     {\cf19 if}(p->list_test_suites) \{\par
5277         std::cout << Color::Cyan << {\cf22 "[doctest] "} << Color::None << {\cf22 "listing all test suites\\n"};\par
5278         separator_to_stream(std::cout);\par
5279     \}\par
5280 \par
5281     {\cf20 // invoke the registered functions if they match the filter criteria (or just count them)}\par
5282     {\cf19 for}(i = 0; i < testArray.size(); i++) \{\par
5283         {\cf17 const} TestCase& data = *testArray[i];\par
5284 \par
5285         {\cf19 if}(data.m_skip && !p->no_skip)\par
5286             {\cf19 continue};\par
5287 \par
5288         {\cf19 if}(!matchesAny(data.m_file, p->filters[0], 1, p->case_sensitive))\par
5289             {\cf19 continue};\par
5290         {\cf19 if}(matchesAny(data.m_file, p->filters[1], 0, p->case_sensitive))\par
5291             {\cf19 continue};\par
5292         {\cf19 if}(!matchesAny(data.m_test_suite, p->filters[2], 1, p->case_sensitive))\par
5293             {\cf19 continue};\par
5294         {\cf19 if}(matchesAny(data.m_test_suite, p->filters[3], 0, p->case_sensitive))\par
5295             {\cf19 continue};\par
5296         {\cf19 if}(!matchesAny(data.m_name, p->filters[4], 1, p->case_sensitive))\par
5297             {\cf19 continue};\par
5298         {\cf19 if}(matchesAny(data.m_name, p->filters[5], 0, p->case_sensitive))\par
5299             {\cf19 continue};\par
5300 \par
5301         p->numTestsPassingFilters++;\par
5302 \par
5303         {\cf20 // do not execute the test if we are to only count the number of filter passing tests}\par
5304         {\cf19 if}(p->count)\par
5305             {\cf19 continue};\par
5306 \par
5307         {\cf20 // print the name of the test and don't execute it}\par
5308         {\cf19 if}(p->list_test_cases) \{\par
5309             std::cout << Color::None << data.m_name << {\cf22 "\\n"};\par
5310             {\cf19 continue};\par
5311         \}\par
5312 \par
5313         {\cf20 // print the name of the test suite if not done already and don't execute it}\par
5314         {\cf19 if}(p->list_test_suites) \{\par
5315             {\cf19 if}((testSuitesPassingFilters.count(data.m_test_suite) == 0) &&\par
5316                data.m_test_suite[0] != {\cf23 '\\0'}) \{\par
5317                 std::cout << Color::None << data.m_test_suite << {\cf22 "\\n"};\par
5318                 testSuitesPassingFilters.insert(data.m_test_suite);\par
5319                 p->numTestSuitesPassingFilters++;\par
5320             \}\par
5321             {\cf19 continue};\par
5322         \}\par
5323 \par
5324         {\cf20 // skip the test if it is not in the execution range}\par
5325         {\cf19 if}((p->last < p->numTestsPassingFilters && p->first <= p->last) ||\par
5326            (p->first > p->numTestsPassingFilters))\par
5327             {\cf19 continue};\par
5328 \par
5329         {\cf20 // execute the test if it passes all the filtering}\par
5330         \{\par
5331             p->currentTest = &data;\par
5332 \par
5333             {\cf18 bool} failed                              = {\cf17 false};\par
5334             p->hasLoggedCurrentTestStart             = {\cf17 false};\par
5335             p->numFailedAssertionsForCurrentTestcase = 0;\par
5336             p->subcasesPassed.clear();\par
5337             {\cf18 double} duration = 0;\par
5338             Timer  timer;\par
5339             timer.start();\par
5340             {\cf19 do} \{\par
5341                 {\cf20 // if the start has been logged from a previous iteration of this loop}\par
5342                 {\cf19 if}(p->hasLoggedCurrentTestStart)\par
5343                     logTestEnd();\par
5344                 p->hasLoggedCurrentTestStart = {\cf17 false};\par
5345 \par
5346                 {\cf20 // if logging successful tests - force the start log}\par
5347                 {\cf19 if}(p->success)\par
5348                     DOCTEST_LOG_START(std::cout);\par
5349 \par
5350                 {\cf20 // reset the assertion state}\par
5351                 p->numAssertionsForCurrentTestcase = 0;\par
5352                 p->hasCurrentTestFailed            = {\cf17 false};\par
5353 \par
5354                 {\cf20 // reset some of the fields for subcases (except for the set of fully passed ones)}\par
5355                 p->subcasesHasSkipped   = {\cf17 false};\par
5356                 p->subcasesCurrentLevel = 0;\par
5357                 p->subcasesEnteredLevels.clear();\par
5358 \par
5359                 {\cf20 // reset stuff for logging with INFO()}\par
5360                 p->exceptionalContexts.clear();\par
5361 \par
5362 {\cf20 // execute the test}\par
5363 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
5364                 {\cf19 try} \{\par
5365 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
5366                     FatalConditionHandler fatalConditionHandler; {\cf20 // Handle signals}\par
5367                     data.m_test();\par
5368                     fatalConditionHandler.reset();\par
5369                     {\cf19 if}(contextState->hasCurrentTestFailed)\par
5370                         failed = {\cf17 true};\par
5371 {\cf21 #ifndef DOCTEST_CONFIG_NO_EXCEPTIONS}\par
5372                 \} {\cf19 catch}({\cf17 const} TestFailureException&) \{ failed = {\cf17 true}; \} {\cf19 catch}(...) \{\par
5373                     DOCTEST_LOG_START(std::cout);\par
5374                     logTestException(*contextState->currentTest, translateActiveException(), {\cf17 false});\par
5375                     failed = {\cf17 true};\par
5376                 \}\par
5377 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_NO_EXCEPTIONS}\par
5378 \par
5379                 p->numAssertions += p->numAssertionsForCurrentTestcase;\par
5380 \par
5381                 {\cf20 // exit this loop if enough assertions have failed}\par
5382                 {\cf19 if}(p->abort_after > 0 && p->numFailedAssertions >= p->abort_after) \{\par
5383                     p->subcasesHasSkipped = {\cf17 false};\par
5384                     std::cout << Color::Red << {\cf22 "Aborting - too many failed asserts!\\n"};\par
5385                 \}\par
5386 \par
5387             \} {\cf19 while}(p->subcasesHasSkipped == {\cf17 true});\par
5388 \par
5389             duration = timer.getElapsedSeconds();\par
5390 \par
5391             {\cf19 if}(Approx(p->currentTest->m_timeout).epsilon(DBL_EPSILON) != 0 &&\par
5392                Approx(duration).epsilon(DBL_EPSILON) > p->currentTest->m_timeout) \{\par
5393                 failed = {\cf17 true};\par
5394                 DOCTEST_LOG_START(std::cout);\par
5395                 std::cout << Color::Red << {\cf22 "Test case exceeded time limit of "}\par
5396                           << std::setprecision(6) << std::fixed << p->currentTest->m_timeout\par
5397                           << {\cf22 "!\\n"};\par
5398             \}\par
5399 \par
5400             {\cf19 if}(p->duration)\par
5401                 std::cout << Color::None << std::setprecision(6) << std::fixed << duration\par
5402                           << {\cf22 " s: "} << p->currentTest->m_name << {\cf22 "\\n"};\par
5403 \par
5404             {\cf19 if}(data.m_should_fail) \{\par
5405                 DOCTEST_LOG_START(std::cout);\par
5406                 {\cf19 if}(failed)\par
5407                     std::cout << Color::Yellow\par
5408                               << {\cf22 "Failed as expected so marking it as not failed\\n"};\par
5409                 {\cf19 else}\par
5410                     std::cout << Color::Red\par
5411                               << {\cf22 "Should have failed but didn't! Marking it as failed!\\n"};\par
5412                 failed = !failed;\par
5413             \} {\cf19 else} {\cf19 if}(failed && data.m_may_fail) \{\par
5414                 DOCTEST_LOG_START(std::cout);\par
5415                 failed = {\cf17 false};\par
5416                 std::cout << Color::Yellow << {\cf22 "Allowed to fail so marking it as not failed\\n"};\par
5417             \} {\cf19 else} {\cf19 if}(data.m_expected_failures > 0) \{\par
5418                 DOCTEST_LOG_START(std::cout);\par
5419                 {\cf19 if}(p->numFailedAssertionsForCurrentTestcase == data.m_expected_failures) \{\par
5420                     failed = {\cf17 false};\par
5421                     std::cout << Color::Yellow << {\cf22 "Failed exactly "} << data.m_expected_failures\par
5422                               << {\cf22 " times as expected so marking it as not failed!\\n"};\par
5423                 \} {\cf19 else} \{\par
5424                     failed = {\cf17 true};\par
5425                     std::cout << Color::Red << {\cf22 "Didn't fail exactly "} << data.m_expected_failures\par
5426                               << {\cf22 " times so marking it as failed!\\n"};\par
5427                 \}\par
5428             \}\par
5429             std::cout << Color::None;\par
5430 \par
5431             {\cf19 if}(p->hasLoggedCurrentTestStart)\par
5432                 logTestEnd();\par
5433 \par
5434             {\cf19 if}(failed) {\cf20 // if any subcase has failed - the whole test case has failed}\par
5435                 p->numFailed++;\par
5436 \par
5437             {\cf20 // stop executing tests if enough assertions have failed}\par
5438             {\cf19 if}(p->abort_after > 0 && p->numFailedAssertions >= p->abort_after)\par
5439                 {\cf19 break};\par
5440         \}\par
5441     \}\par
5442 \par
5443     printSummary(std::cout);\par
5444 \par
5445     contextState = 0;\par
5446 \par
5447     {\cf19 if}(p->numFailed && !p->no_exitcode)\par
5448         {\cf19 return} EXIT_FAILURE;\par
5449     {\cf19 return} EXIT_SUCCESS;\par
5450 \}\par
5451 \} {\cf20 // namespace doctest}\par
5452 \par
5453 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_DISABLE}\par
5454 \par
5455 {\cf21 #ifdef DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN}\par
5456 {\cf18 int} main({\cf18 int} argc, {\cf18 char}** argv) \{ {\cf19 return} doctest::Context(argc, argv).run(); \}\par
5457 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN}\par
5458 \par
5459 DOCTEST_CLANG_SUPPRESS_WARNING_POP\par
5460 DOCTEST_MSVC_SUPPRESS_WARNING_POP\par
5461 DOCTEST_GCC_SUPPRESS_WARNING_POP\par
5462 \par
5463 {\cf21 #endif }{\cf20 // DOCTEST_LIBRARY_IMPLEMENTATION}\par
5464 {\cf21 #endif }{\cf20 // DOCTEST_CONFIG_IMPLEMENT}\par
}
}